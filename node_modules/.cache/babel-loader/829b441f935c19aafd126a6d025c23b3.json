{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.dragula = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {\n        o(t[i]);\n      }\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n      var cache = {};\n      var start = '(?:^|\\\\s)';\n      var end = '(?:\\\\s|$)';\n\n      function lookupClass(className) {\n        var cached = cache[className];\n\n        if (cached) {\n          cached.lastIndex = 0;\n        } else {\n          cache[className] = cached = new RegExp(start + className + end, 'g');\n        }\n\n        return cached;\n      }\n\n      function addClass(el, className) {\n        var current = el.className;\n\n        if (!current.length) {\n          el.className = className;\n        } else if (!lookupClass(className).test(current)) {\n          el.className += ' ' + className;\n        }\n      }\n\n      function rmClass(el, className) {\n        el.className = el.className.replace(lookupClass(className), ' ').trim();\n      }\n\n      module.exports = {\n        add: addClass,\n        rm: rmClass\n      };\n    }, {}],\n    2: [function (require, module, exports) {\n      (function (global) {\n        'use strict';\n\n        var emitter = require('contra/emitter');\n\n        var crossvent = require('crossvent');\n\n        var classes = require('./classes');\n\n        var doc = document;\n        var documentElement = doc.documentElement;\n\n        function dragula(initialContainers, options) {\n          var len = arguments.length;\n\n          if (len === 1 && Array.isArray(initialContainers) === false) {\n            options = initialContainers;\n            initialContainers = [];\n          }\n\n          var _mirror; // mirror image\n\n\n          var _source; // source container\n\n\n          var _item; // item being dragged\n\n\n          var _offsetX; // reference x\n\n\n          var _offsetY; // reference y\n\n\n          var _moveX; // reference move x\n\n\n          var _moveY; // reference move y\n\n\n          var _initialSibling; // reference sibling when grabbed\n\n\n          var _currentSibling; // reference sibling now\n\n\n          var _copy; // item used for copying\n\n\n          var _renderTimer; // timer for setTimeout renderMirrorImage\n\n\n          var _lastDropTarget = null; // last container item was over\n\n          var _grabbed; // holds mousedown context until first mousemove\n\n\n          var o = options || {};\n\n          if (o.moves === void 0) {\n            o.moves = always;\n          }\n\n          if (o.accepts === void 0) {\n            o.accepts = always;\n          }\n\n          if (o.invalid === void 0) {\n            o.invalid = invalidTarget;\n          }\n\n          if (o.containers === void 0) {\n            o.containers = initialContainers || [];\n          }\n\n          if (o.isContainer === void 0) {\n            o.isContainer = never;\n          }\n\n          if (o.copy === void 0) {\n            o.copy = false;\n          }\n\n          if (o.copySortSource === void 0) {\n            o.copySortSource = false;\n          }\n\n          if (o.revertOnSpill === void 0) {\n            o.revertOnSpill = false;\n          }\n\n          if (o.removeOnSpill === void 0) {\n            o.removeOnSpill = false;\n          }\n\n          if (o.direction === void 0) {\n            o.direction = 'vertical';\n          }\n\n          if (o.ignoreInputTextSelection === void 0) {\n            o.ignoreInputTextSelection = true;\n          }\n\n          if (o.mirrorContainer === void 0) {\n            o.mirrorContainer = doc.body;\n          }\n\n          var drake = emitter({\n            containers: o.containers,\n            start: manualStart,\n            end: end,\n            cancel: cancel,\n            remove: remove,\n            destroy: destroy,\n            canMove: canMove,\n            dragging: false\n          });\n\n          if (o.removeOnSpill === true) {\n            drake.on('over', spillOver).on('out', spillOut);\n          }\n\n          events();\n          return drake;\n\n          function isContainer(el) {\n            return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n          }\n\n          function events(remove) {\n            var op = remove ? 'remove' : 'add';\n            touchy(documentElement, op, 'mousedown', grab);\n            touchy(documentElement, op, 'mouseup', release);\n          }\n\n          function eventualMovements(remove) {\n            var op = remove ? 'remove' : 'add';\n            touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n          }\n\n          function movements(remove) {\n            var op = remove ? 'remove' : 'add';\n            crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n\n            crossvent[op](documentElement, 'click', preventGrabbed);\n          }\n\n          function destroy() {\n            events(true);\n            release({});\n          }\n\n          function preventGrabbed(e) {\n            if (_grabbed) {\n              e.preventDefault();\n            }\n          }\n\n          function grab(e) {\n            _moveX = e.clientX;\n            _moveY = e.clientY;\n            var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n\n            if (ignore) {\n              return; // we only care about honest-to-god left clicks and touch events\n            }\n\n            var item = e.target;\n            var context = canStart(item);\n\n            if (!context) {\n              return;\n            }\n\n            _grabbed = context;\n            eventualMovements();\n\n            if (e.type === 'mousedown') {\n              if (isInput(item)) {\n                // see also: https://github.com/bevacqua/dragula/issues/208\n                item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n              } else {\n                e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n              }\n            }\n          }\n\n          function startBecauseMouseMoved(e) {\n            if (!_grabbed) {\n              return;\n            }\n\n            if (whichMouseButton(e) === 0) {\n              release({});\n              return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n            } // truthy check fixes #239, equality fixes #207, fixes #501\n\n\n            if (e.clientX !== void 0 && Math.abs(e.clientX - _moveX) <= (o.slideFactorX || 0) && e.clientY !== void 0 && Math.abs(e.clientY - _moveY) <= (o.slideFactorY || 0)) {\n              return;\n            }\n\n            if (o.ignoreInputTextSelection) {\n              var clientX = getCoord('clientX', e) || 0;\n              var clientY = getCoord('clientY', e) || 0;\n              var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n\n              if (isInput(elementBehindCursor)) {\n                return;\n              }\n            }\n\n            var grabbed = _grabbed; // call to end() unsets _grabbed\n\n            eventualMovements(true);\n            movements();\n            end();\n            start(grabbed);\n            var offset = getOffset(_item);\n            _offsetX = getCoord('pageX', e) - offset.left;\n            _offsetY = getCoord('pageY', e) - offset.top;\n            classes.add(_copy || _item, 'gu-transit');\n            renderMirrorImage();\n            drag(e);\n          }\n\n          function canStart(item) {\n            if (drake.dragging && _mirror) {\n              return;\n            }\n\n            if (isContainer(item)) {\n              return; // don't drag container itself\n            }\n\n            var handle = item;\n\n            while (getParent(item) && isContainer(getParent(item)) === false) {\n              if (o.invalid(item, handle)) {\n                return;\n              }\n\n              item = getParent(item); // drag target should be a top element\n\n              if (!item) {\n                return;\n              }\n            }\n\n            var source = getParent(item);\n\n            if (!source) {\n              return;\n            }\n\n            if (o.invalid(item, handle)) {\n              return;\n            }\n\n            var movable = o.moves(item, source, handle, nextEl(item));\n\n            if (!movable) {\n              return;\n            }\n\n            return {\n              item: item,\n              source: source\n            };\n          }\n\n          function canMove(item) {\n            return !!canStart(item);\n          }\n\n          function manualStart(item) {\n            var context = canStart(item);\n\n            if (context) {\n              start(context);\n            }\n          }\n\n          function start(context) {\n            if (isCopy(context.item, context.source)) {\n              _copy = context.item.cloneNode(true);\n              drake.emit('cloned', _copy, context.item, 'copy');\n            }\n\n            _source = context.source;\n            _item = context.item;\n            _initialSibling = _currentSibling = nextEl(context.item);\n            drake.dragging = true;\n            drake.emit('drag', _item, _source);\n          }\n\n          function invalidTarget() {\n            return false;\n          }\n\n          function end() {\n            if (!drake.dragging) {\n              return;\n            }\n\n            var item = _copy || _item;\n            drop(item, getParent(item));\n          }\n\n          function ungrab() {\n            _grabbed = false;\n            eventualMovements(true);\n            movements(true);\n          }\n\n          function release(e) {\n            ungrab();\n\n            if (!drake.dragging) {\n              return;\n            }\n\n            var item = _copy || _item;\n            var clientX = getCoord('clientX', e) || 0;\n            var clientY = getCoord('clientY', e) || 0;\n            var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n            var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n\n            if (dropTarget && (_copy && o.copySortSource || !_copy || dropTarget !== _source)) {\n              drop(item, dropTarget);\n            } else if (o.removeOnSpill) {\n              remove();\n            } else {\n              cancel();\n            }\n          }\n\n          function drop(item, target) {\n            var parent = getParent(item);\n\n            if (_copy && o.copySortSource && target === _source) {\n              parent.removeChild(_item);\n            }\n\n            if (isInitialPlacement(target)) {\n              drake.emit('cancel', item, _source, _source);\n            } else {\n              drake.emit('drop', item, target, _source, _currentSibling);\n            }\n\n            cleanup();\n          }\n\n          function remove() {\n            if (!drake.dragging) {\n              return;\n            }\n\n            var item = _copy || _item;\n            var parent = getParent(item);\n\n            if (parent) {\n              parent.removeChild(item);\n            }\n\n            drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n            cleanup();\n          }\n\n          function cancel(revert) {\n            if (!drake.dragging) {\n              return;\n            }\n\n            var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n            var item = _copy || _item;\n            var parent = getParent(item);\n            var initial = isInitialPlacement(parent);\n\n            if (initial === false && reverts) {\n              if (_copy) {\n                if (parent) {\n                  parent.removeChild(_copy);\n                }\n              } else {\n                _source.insertBefore(item, _initialSibling);\n              }\n            }\n\n            if (initial || reverts) {\n              drake.emit('cancel', item, _source, _source);\n            } else {\n              drake.emit('drop', item, parent, _source, _currentSibling);\n            }\n\n            cleanup();\n          }\n\n          function cleanup() {\n            var item = _copy || _item;\n            ungrab();\n            removeMirrorImage();\n\n            if (item) {\n              classes.rm(item, 'gu-transit');\n            }\n\n            if (_renderTimer) {\n              clearTimeout(_renderTimer);\n            }\n\n            drake.dragging = false;\n\n            if (_lastDropTarget) {\n              drake.emit('out', item, _lastDropTarget, _source);\n            }\n\n            drake.emit('dragend', item);\n            _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n          }\n\n          function isInitialPlacement(target, s) {\n            var sibling;\n\n            if (s !== void 0) {\n              sibling = s;\n            } else if (_mirror) {\n              sibling = _currentSibling;\n            } else {\n              sibling = nextEl(_copy || _item);\n            }\n\n            return target === _source && sibling === _initialSibling;\n          }\n\n          function findDropTarget(elementBehindCursor, clientX, clientY) {\n            var target = elementBehindCursor;\n\n            while (target && !accepted()) {\n              target = getParent(target);\n            }\n\n            return target;\n\n            function accepted() {\n              var droppable = isContainer(target);\n\n              if (droppable === false) {\n                return false;\n              }\n\n              var immediate = getImmediateChild(target, elementBehindCursor);\n              var reference = getReference(target, immediate, clientX, clientY);\n              var initial = isInitialPlacement(target, reference);\n\n              if (initial) {\n                return true; // should always be able to drop it right back where it was\n              }\n\n              return o.accepts(_item, target, _source, reference);\n            }\n          }\n\n          function drag(e) {\n            if (!_mirror) {\n              return;\n            }\n\n            e.preventDefault();\n            var clientX = getCoord('clientX', e) || 0;\n            var clientY = getCoord('clientY', e) || 0;\n            var x = clientX - _offsetX;\n            var y = clientY - _offsetY;\n            _mirror.style.left = x + 'px';\n            _mirror.style.top = y + 'px';\n            var item = _copy || _item;\n            var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n            var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n            var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n\n            if (changed || dropTarget === null) {\n              out();\n              _lastDropTarget = dropTarget;\n              over();\n            }\n\n            var parent = getParent(item);\n\n            if (dropTarget === _source && _copy && !o.copySortSource) {\n              if (parent) {\n                parent.removeChild(item);\n              }\n\n              return;\n            }\n\n            var reference;\n            var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n            if (immediate !== null) {\n              reference = getReference(dropTarget, immediate, clientX, clientY);\n            } else if (o.revertOnSpill === true && !_copy) {\n              reference = _initialSibling;\n              dropTarget = _source;\n            } else {\n              if (_copy && parent) {\n                parent.removeChild(item);\n              }\n\n              return;\n            }\n\n            if (reference === null && changed || reference !== item && reference !== nextEl(item)) {\n              _currentSibling = reference;\n              dropTarget.insertBefore(item, reference);\n              drake.emit('shadow', item, dropTarget, _source);\n            }\n\n            function moved(type) {\n              drake.emit(type, item, _lastDropTarget, _source);\n            }\n\n            function over() {\n              if (changed) {\n                moved('over');\n              }\n            }\n\n            function out() {\n              if (_lastDropTarget) {\n                moved('out');\n              }\n            }\n          }\n\n          function spillOver(el) {\n            classes.rm(el, 'gu-hide');\n          }\n\n          function spillOut(el) {\n            if (drake.dragging) {\n              classes.add(el, 'gu-hide');\n            }\n          }\n\n          function renderMirrorImage() {\n            if (_mirror) {\n              return;\n            }\n\n            var rect = _item.getBoundingClientRect();\n\n            _mirror = _item.cloneNode(true);\n            _mirror.style.width = getRectWidth(rect) + 'px';\n            _mirror.style.height = getRectHeight(rect) + 'px';\n            classes.rm(_mirror, 'gu-transit');\n            classes.add(_mirror, 'gu-mirror');\n            o.mirrorContainer.appendChild(_mirror);\n            touchy(documentElement, 'add', 'mousemove', drag);\n            classes.add(o.mirrorContainer, 'gu-unselectable');\n            drake.emit('cloned', _mirror, _item, 'mirror');\n          }\n\n          function removeMirrorImage() {\n            if (_mirror) {\n              classes.rm(o.mirrorContainer, 'gu-unselectable');\n              touchy(documentElement, 'remove', 'mousemove', drag);\n              getParent(_mirror).removeChild(_mirror);\n              _mirror = null;\n            }\n          }\n\n          function getImmediateChild(dropTarget, target) {\n            var immediate = target;\n\n            while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n              immediate = getParent(immediate);\n            }\n\n            if (immediate === documentElement) {\n              return null;\n            }\n\n            return immediate;\n          }\n\n          function getReference(dropTarget, target, x, y) {\n            var horizontal = o.direction === 'horizontal';\n            var reference = target !== dropTarget ? inside() : outside();\n            return reference;\n\n            function outside() {\n              // slower, but able to figure out any position\n              var len = dropTarget.children.length;\n              var i;\n              var el;\n              var rect;\n\n              for (i = 0; i < len; i++) {\n                el = dropTarget.children[i];\n                rect = el.getBoundingClientRect();\n\n                if (horizontal && rect.left + rect.width / 2 > x) {\n                  return el;\n                }\n\n                if (!horizontal && rect.top + rect.height / 2 > y) {\n                  return el;\n                }\n              }\n\n              return null;\n            }\n\n            function inside() {\n              // faster, but only available if dropped inside a child element\n              var rect = target.getBoundingClientRect();\n\n              if (horizontal) {\n                return resolve(x > rect.left + getRectWidth(rect) / 2);\n              }\n\n              return resolve(y > rect.top + getRectHeight(rect) / 2);\n            }\n\n            function resolve(after) {\n              return after ? nextEl(target) : target;\n            }\n          }\n\n          function isCopy(item, container) {\n            return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n          }\n        }\n\n        function touchy(el, op, type, fn) {\n          var touch = {\n            mouseup: 'touchend',\n            mousedown: 'touchstart',\n            mousemove: 'touchmove'\n          };\n          var pointers = {\n            mouseup: 'pointerup',\n            mousedown: 'pointerdown',\n            mousemove: 'pointermove'\n          };\n          var microsoft = {\n            mouseup: 'MSPointerUp',\n            mousedown: 'MSPointerDown',\n            mousemove: 'MSPointerMove'\n          };\n\n          if (global.navigator.pointerEnabled) {\n            crossvent[op](el, pointers[type], fn);\n          } else if (global.navigator.msPointerEnabled) {\n            crossvent[op](el, microsoft[type], fn);\n          } else {\n            crossvent[op](el, touch[type], fn);\n            crossvent[op](el, type, fn);\n          }\n        }\n\n        function whichMouseButton(e) {\n          if (e.touches !== void 0) {\n            return e.touches.length;\n          }\n\n          if (e.which !== void 0 && e.which !== 0) {\n            return e.which;\n          } // see https://github.com/bevacqua/dragula/issues/261\n\n\n          if (e.buttons !== void 0) {\n            return e.buttons;\n          }\n\n          var button = e.button;\n\n          if (button !== void 0) {\n            // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n            return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n          }\n        }\n\n        function getOffset(el) {\n          var rect = el.getBoundingClientRect();\n          return {\n            left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n            top: rect.top + getScroll('scrollTop', 'pageYOffset')\n          };\n        }\n\n        function getScroll(scrollProp, offsetProp) {\n          if (typeof global[offsetProp] !== 'undefined') {\n            return global[offsetProp];\n          }\n\n          if (documentElement.clientHeight) {\n            return documentElement[scrollProp];\n          }\n\n          return doc.body[scrollProp];\n        }\n\n        function getElementBehindPoint(point, x, y) {\n          point = point || {};\n          var state = point.className || '';\n          var el;\n          point.className += ' gu-hide';\n          el = doc.elementFromPoint(x, y);\n          point.className = state;\n          return el;\n        }\n\n        function never() {\n          return false;\n        }\n\n        function always() {\n          return true;\n        }\n\n        function getRectWidth(rect) {\n          return rect.width || rect.right - rect.left;\n        }\n\n        function getRectHeight(rect) {\n          return rect.height || rect.bottom - rect.top;\n        }\n\n        function getParent(el) {\n          return el.parentNode === doc ? null : el.parentNode;\n        }\n\n        function isInput(el) {\n          return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n        }\n\n        function isEditable(el) {\n          if (!el) {\n            return false;\n          } // no parents were editable\n\n\n          if (el.contentEditable === 'false') {\n            return false;\n          } // stop the lookup\n\n\n          if (el.contentEditable === 'true') {\n            return true;\n          } // found a contentEditable element in the chain\n\n\n          return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n        }\n\n        function nextEl(el) {\n          return el.nextElementSibling || manually();\n\n          function manually() {\n            var sibling = el;\n\n            do {\n              sibling = sibling.nextSibling;\n            } while (sibling && sibling.nodeType !== 1);\n\n            return sibling;\n          }\n        }\n\n        function getEventHost(e) {\n          // on touchend event, we have to use `e.changedTouches`\n          // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n          // see https://github.com/bevacqua/dragula/issues/34\n          if (e.targetTouches && e.targetTouches.length) {\n            return e.targetTouches[0];\n          }\n\n          if (e.changedTouches && e.changedTouches.length) {\n            return e.changedTouches[0];\n          }\n\n          return e;\n        }\n\n        function getCoord(coord, e) {\n          var host = getEventHost(e);\n          var missMap = {\n            pageX: 'clientX',\n            // IE8\n            pageY: 'clientY' // IE8\n\n          };\n\n          if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n            coord = missMap[coord];\n          }\n\n          return host[coord];\n        }\n\n        module.exports = dragula;\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./classes\": 1,\n      \"contra/emitter\": 5,\n      \"crossvent\": 6\n    }],\n    3: [function (require, module, exports) {\n      module.exports = function atoa(a, n) {\n        return Array.prototype.slice.call(a, n);\n      };\n    }, {}],\n    4: [function (require, module, exports) {\n      'use strict';\n\n      var ticky = require('ticky');\n\n      module.exports = function debounce(fn, args, ctx) {\n        if (!fn) {\n          return;\n        }\n\n        ticky(function run() {\n          fn.apply(ctx || null, args || []);\n        });\n      };\n    }, {\n      \"ticky\": 10\n    }],\n    5: [function (require, module, exports) {\n      'use strict';\n\n      var atoa = require('atoa');\n\n      var debounce = require('./debounce');\n\n      module.exports = function emitter(thing, options) {\n        var opts = options || {};\n        var evt = {};\n\n        if (thing === undefined) {\n          thing = {};\n        }\n\n        thing.on = function (type, fn) {\n          if (!evt[type]) {\n            evt[type] = [fn];\n          } else {\n            evt[type].push(fn);\n          }\n\n          return thing;\n        };\n\n        thing.once = function (type, fn) {\n          fn._once = true; // thing.off(fn) still works!\n\n          thing.on(type, fn);\n          return thing;\n        };\n\n        thing.off = function (type, fn) {\n          var c = arguments.length;\n\n          if (c === 1) {\n            delete evt[type];\n          } else if (c === 0) {\n            evt = {};\n          } else {\n            var et = evt[type];\n\n            if (!et) {\n              return thing;\n            }\n\n            et.splice(et.indexOf(fn), 1);\n          }\n\n          return thing;\n        };\n\n        thing.emit = function () {\n          var args = atoa(arguments);\n          return thing.emitterSnapshot(args.shift()).apply(this, args);\n        };\n\n        thing.emitterSnapshot = function (type) {\n          var et = (evt[type] || []).slice(0);\n          return function () {\n            var args = atoa(arguments);\n            var ctx = this || thing;\n\n            if (type === 'error' && opts.throws !== false && !et.length) {\n              throw args.length === 1 ? args[0] : args;\n            }\n\n            et.forEach(function emitter(listen) {\n              if (opts.async) {\n                debounce(listen, args, ctx);\n              } else {\n                listen.apply(ctx, args);\n              }\n\n              if (listen._once) {\n                thing.off(type, listen);\n              }\n            });\n            return thing;\n          };\n        };\n\n        return thing;\n      };\n    }, {\n      \"./debounce\": 4,\n      \"atoa\": 3\n    }],\n    6: [function (require, module, exports) {\n      (function (global) {\n        'use strict';\n\n        var customEvent = require('custom-event');\n\n        var eventmap = require('./eventmap');\n\n        var doc = global.document;\n        var addEvent = addEventEasy;\n        var removeEvent = removeEventEasy;\n        var hardCache = [];\n\n        if (!global.addEventListener) {\n          addEvent = addEventHard;\n          removeEvent = removeEventHard;\n        }\n\n        module.exports = {\n          add: addEvent,\n          remove: removeEvent,\n          fabricate: fabricateEvent\n        };\n\n        function addEventEasy(el, type, fn, capturing) {\n          return el.addEventListener(type, fn, capturing);\n        }\n\n        function addEventHard(el, type, fn) {\n          return el.attachEvent('on' + type, wrap(el, type, fn));\n        }\n\n        function removeEventEasy(el, type, fn, capturing) {\n          return el.removeEventListener(type, fn, capturing);\n        }\n\n        function removeEventHard(el, type, fn) {\n          var listener = unwrap(el, type, fn);\n\n          if (listener) {\n            return el.detachEvent('on' + type, listener);\n          }\n        }\n\n        function fabricateEvent(el, type, model) {\n          var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();\n\n          if (el.dispatchEvent) {\n            el.dispatchEvent(e);\n          } else {\n            el.fireEvent('on' + type, e);\n          }\n\n          function makeClassicEvent() {\n            var e;\n\n            if (doc.createEvent) {\n              e = doc.createEvent('Event');\n              e.initEvent(type, true, true);\n            } else if (doc.createEventObject) {\n              e = doc.createEventObject();\n            }\n\n            return e;\n          }\n\n          function makeCustomEvent() {\n            return new customEvent(type, {\n              detail: model\n            });\n          }\n        }\n\n        function wrapperFactory(el, type, fn) {\n          return function wrapper(originalEvent) {\n            var e = originalEvent || global.event;\n            e.target = e.target || e.srcElement;\n\n            e.preventDefault = e.preventDefault || function preventDefault() {\n              e.returnValue = false;\n            };\n\n            e.stopPropagation = e.stopPropagation || function stopPropagation() {\n              e.cancelBubble = true;\n            };\n\n            e.which = e.which || e.keyCode;\n            fn.call(el, e);\n          };\n        }\n\n        function wrap(el, type, fn) {\n          var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);\n          hardCache.push({\n            wrapper: wrapper,\n            element: el,\n            type: type,\n            fn: fn\n          });\n          return wrapper;\n        }\n\n        function unwrap(el, type, fn) {\n          var i = find(el, type, fn);\n\n          if (i) {\n            var wrapper = hardCache[i].wrapper;\n            hardCache.splice(i, 1); // free up a tad of memory\n\n            return wrapper;\n          }\n        }\n\n        function find(el, type, fn) {\n          var i, item;\n\n          for (i = 0; i < hardCache.length; i++) {\n            item = hardCache[i];\n\n            if (item.element === el && item.type === type && item.fn === fn) {\n              return i;\n            }\n          }\n        }\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./eventmap\": 7,\n      \"custom-event\": 8\n    }],\n    7: [function (require, module, exports) {\n      (function (global) {\n        'use strict';\n\n        var eventmap = [];\n        var eventname = '';\n        var ron = /^on/;\n\n        for (eventname in global) {\n          if (ron.test(eventname)) {\n            eventmap.push(eventname.slice(2));\n          }\n        }\n\n        module.exports = eventmap;\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    8: [function (require, module, exports) {\n      (function (global) {\n        var NativeCustomEvent = global.CustomEvent;\n\n        function useNative() {\n          try {\n            var p = new NativeCustomEvent('cat', {\n              detail: {\n                foo: 'bar'\n              }\n            });\n            return 'cat' === p.type && 'bar' === p.detail.foo;\n          } catch (e) {}\n\n          return false;\n        }\n        /**\n         * Cross-browser `CustomEvent` constructor.\n         *\n         * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n         *\n         * @public\n         */\n\n\n        module.exports = useNative() ? NativeCustomEvent : // IE >= 9\n        'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent(type, params) {\n          var e = document.createEvent('CustomEvent');\n\n          if (params) {\n            e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n          } else {\n            e.initCustomEvent(type, false, false, void 0);\n          }\n\n          return e;\n        } : // IE <= 8\n        function CustomEvent(type, params) {\n          var e = document.createEventObject();\n          e.type = type;\n\n          if (params) {\n            e.bubbles = Boolean(params.bubbles);\n            e.cancelable = Boolean(params.cancelable);\n            e.detail = params.detail;\n          } else {\n            e.bubbles = false;\n            e.cancelable = false;\n            e.detail = void 0;\n          }\n\n          return e;\n        };\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    9: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {\n        return [];\n      };\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n    }, {}],\n    10: [function (require, module, exports) {\n      (function (setImmediate) {\n        var si = typeof setImmediate === 'function',\n            tick;\n\n        if (si) {\n          tick = function tick(fn) {\n            setImmediate(fn);\n          };\n        } else {\n          tick = function tick(fn) {\n            setTimeout(fn, 0);\n          };\n        }\n\n        module.exports = tick;\n      }).call(this, require(\"timers\").setImmediate);\n    }, {\n      \"timers\": 11\n    }],\n    11: [function (require, module, exports) {\n      (function (setImmediate, clearImmediate) {\n        var nextTick = require('process/browser.js').nextTick;\n\n        var apply = Function.prototype.apply;\n        var slice = Array.prototype.slice;\n        var immediateIds = {};\n        var nextImmediateId = 0; // DOM APIs, for completeness\n\n        exports.setTimeout = function () {\n          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n        };\n\n        exports.setInterval = function () {\n          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n        };\n\n        exports.clearTimeout = exports.clearInterval = function (timeout) {\n          timeout.close();\n        };\n\n        function Timeout(id, clearFn) {\n          this._id = id;\n          this._clearFn = clearFn;\n        }\n\n        Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n\n        Timeout.prototype.close = function () {\n          this._clearFn.call(window, this._id);\n        }; // Does not start the time, just sets up the members needed.\n\n\n        exports.enroll = function (item, msecs) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = msecs;\n        };\n\n        exports.unenroll = function (item) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = -1;\n        };\n\n        exports._unrefActive = exports.active = function (item) {\n          clearTimeout(item._idleTimeoutId);\n          var msecs = item._idleTimeout;\n\n          if (msecs >= 0) {\n            item._idleTimeoutId = setTimeout(function onTimeout() {\n              if (item._onTimeout) item._onTimeout();\n            }, msecs);\n          }\n        }; // That's not how node.js implements it but the exposed api is the same.\n\n\n        exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\n          var id = nextImmediateId++;\n          var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n          immediateIds[id] = true;\n          nextTick(function onNextTick() {\n            if (immediateIds[id]) {\n              // fn.call() is faster so we optimize for the common use-case\n              // @see http://jsperf.com/call-apply-segu\n              if (args) {\n                fn.apply(null, args);\n              } else {\n                fn.call(null);\n              } // Prevent ids from leaking\n\n\n              exports.clearImmediate(id);\n            }\n          });\n          return id;\n        };\n        exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\n          delete immediateIds[id];\n        };\n      }).call(this, require(\"timers\").setImmediate, require(\"timers\").clearImmediate);\n    }, {\n      \"process/browser.js\": 9,\n      \"timers\": 11\n    }]\n  }, {}, [2])(2);\n});","map":null,"metadata":{},"sourceType":"script"}