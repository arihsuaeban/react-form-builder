{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.filter\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of\");\n\nrequire(\"core-js/modules/es.object.keys\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.reflect.construct\");\n\nrequire(\"core-js/modules/es.reflect.get\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Component2 = _interopRequireDefault(require(\"../_classes/component/Component\"));\n\nvar _Formio = require(\"../../Formio\");\n\nvar _get3 = _interopRequireDefault(require(\"lodash/get\"));\n\nvar _debounce2 = _interopRequireDefault(require(\"lodash/debounce\"));\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _get2() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get2 = Reflect.get;\n  } else {\n    _get2 = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get2.apply(this, arguments);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar ReCaptchaComponent = /*#__PURE__*/function (_Component) {\n  _inherits(ReCaptchaComponent, _Component);\n\n  var _super = _createSuper(ReCaptchaComponent);\n\n  function ReCaptchaComponent() {\n    _classCallCheck(this, ReCaptchaComponent);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ReCaptchaComponent, [{\n    key: \"render\",\n    value: function render() {\n      this.recaptchaResult = null;\n\n      if (this.builderMode) {\n        return _get2(_getPrototypeOf(ReCaptchaComponent.prototype), \"render\", this).call(this, 'reCAPTCHA');\n      } else {\n        return _get2(_getPrototypeOf(ReCaptchaComponent.prototype), \"render\", this).call(this, '', true);\n      }\n    }\n  }, {\n    key: \"createInput\",\n    value: function createInput() {\n      if (this.builderMode) {\n        // We need to see it in builder mode.\n        this.append(this.text(this.name));\n      } else {\n        var siteKey = (0, _get3.default)(this.root.form, 'settings.recaptcha.siteKey');\n\n        if (siteKey) {\n          var recaptchaApiScriptUrl = \"https://www.google.com/recaptcha/api.js?render=\".concat(siteKey);\n          this.recaptchaApiReady = _Formio.GlobalFormio.requireLibrary('googleRecaptcha', 'grecaptcha', recaptchaApiScriptUrl, true);\n        } else {\n          console.warn('There is no Site Key specified in settings in form JSON');\n        }\n      }\n    }\n  }, {\n    key: \"createLabel\",\n    value: function createLabel() {\n      return;\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(actionName) {\n      var _this = this;\n\n      var siteKey = (0, _get3.default)(this.root.form, 'settings.recaptcha.siteKey');\n\n      if (!siteKey) {\n        console.warn('There is no Site Key specified in settings in form JSON');\n        return;\n      }\n\n      if (!this.recaptchaApiReady) {\n        var recaptchaApiScriptUrl = \"https://www.google.com/recaptcha/api.js?render=\".concat((0, _get3.default)(this.root.form, 'settings.recaptcha.siteKey'));\n        this.recaptchaApiReady = _Formio.GlobalFormio.requireLibrary('googleRecaptcha', 'grecaptcha', recaptchaApiScriptUrl, true);\n      }\n\n      if (this.recaptchaApiReady) {\n        this.recaptchaVerifiedPromise = new _nativePromiseOnly.default(function (resolve, reject) {\n          _this.recaptchaApiReady.then(function () {\n            if (!_this.isLoading) {\n              _this.isLoading = true;\n              grecaptcha.ready((0, _debounce2.default)(function () {\n                grecaptcha.execute(siteKey, {\n                  action: actionName\n                }).then(function (token) {\n                  return _this.sendVerificationRequest(token).then(function (_ref) {\n                    var verificationResult = _ref.verificationResult,\n                        token = _ref.token;\n                    _this.recaptchaResult = _objectSpread(_objectSpread({}, verificationResult), {}, {\n                      token: token\n                    });\n\n                    _this.updateValue(_this.recaptchaResult);\n\n                    return resolve(verificationResult);\n                  });\n                }).catch(function () {\n                  _this.isLoading = false;\n                });\n              }, 1000));\n            }\n          }).catch(function () {\n            return reject();\n          });\n        }).then(function () {\n          _this.isLoading = false;\n        });\n      }\n    }\n  }, {\n    key: \"beforeSubmit\",\n    value: function beforeSubmit() {\n      var _this2 = this;\n\n      if (this.recaptchaVerifiedPromise) {\n        return this.recaptchaVerifiedPromise.then(function () {\n          return _get2(_getPrototypeOf(ReCaptchaComponent.prototype), \"beforeSubmit\", _this2).call(_this2);\n        });\n      }\n\n      return _get2(_getPrototypeOf(ReCaptchaComponent.prototype), \"beforeSubmit\", this).call(this);\n    }\n  }, {\n    key: \"sendVerificationRequest\",\n    value: function sendVerificationRequest(token) {\n      return _Formio.GlobalFormio.makeStaticRequest(\"\".concat(_Formio.GlobalFormio.projectUrl, \"/recaptcha?recaptchaToken=\").concat(token)).then(function (verificationResult) {\n        return {\n          verificationResult: verificationResult,\n          token: token\n        };\n      });\n    }\n  }, {\n    key: \"checkComponentValidity\",\n    value: function checkComponentValidity(data, dirty, row) {\n      var _this3 = this;\n\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      data = data || this.rootValue;\n      row = row || this.data;\n      var _options$async = options.async,\n          async = _options$async === void 0 ? false : _options$async; // Verification could be async only\n\n      if (!async) {\n        return _get2(_getPrototypeOf(ReCaptchaComponent.prototype), \"checkComponentValidity\", this).call(this, data, dirty, row, options);\n      }\n\n      var componentData = row[this.component.key];\n\n      if (!componentData || !componentData.token) {\n        this.setCustomValidity('ReCAPTCHA: Token is not specified in submission');\n        return _nativePromiseOnly.default.resolve(false);\n      }\n\n      if (!componentData.success) {\n        this.setCustomValidity('ReCAPTCHA: Token validation error');\n        return _nativePromiseOnly.default.resolve(false);\n      }\n\n      return this.hook('validateReCaptcha', componentData.token, function () {\n        return _nativePromiseOnly.default.resolve(true);\n      }).then(function (success) {\n        return success;\n      }).catch(function (err) {\n        _this3.setCustomValidity(err.message || err);\n\n        return false;\n      });\n    }\n  }, {\n    key: \"normalizeValue\",\n    value: function normalizeValue(newValue) {\n      // If a recaptcha result has already been established, then do not allow it to be reset.\n      return this.recaptchaResult ? this.recaptchaResult : newValue;\n    }\n  }], [{\n    key: \"schema\",\n    value: function schema() {\n      for (var _len = arguments.length, extend = new Array(_len), _key = 0; _key < _len; _key++) {\n        extend[_key] = arguments[_key];\n      }\n\n      return _Component2.default.schema.apply(_Component2.default, [{\n        type: 'recaptcha',\n        key: 'recaptcha',\n        label: 'reCAPTCHA'\n      }].concat(extend));\n    }\n  }, {\n    key: \"builderInfo\",\n    get: function get() {\n      return {\n        title: 'reCAPTCHA',\n        group: 'premium',\n        icon: 'refresh',\n        documentation: '/userguide/#recaptcha',\n        weight: 40,\n        schema: ReCaptchaComponent.schema()\n      };\n    }\n  }]);\n\n  return ReCaptchaComponent;\n}(_Component2.default);\n\nexports.default = ReCaptchaComponent;","map":null,"metadata":{},"sourceType":"script"}