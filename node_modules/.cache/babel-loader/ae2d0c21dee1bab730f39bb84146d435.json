{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.filter\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.array.splice\");\n\nrequire(\"core-js/modules/es.object.assign\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of\");\n\nrequire(\"core-js/modules/es.object.keys\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.reflect.construct\");\n\nrequire(\"core-js/modules/es.reflect.get\");\n\nrequire(\"core-js/modules/es.regexp.exec\");\n\nrequire(\"core-js/modules/es.regexp.flags\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.includes\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.string.split\");\n\nrequire(\"core-js/modules/es.string.starts-with\");\n\nrequire(\"core-js/modules/es.weak-map\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _vanillaTextMask = require(\"@formio/vanilla-text-mask\");\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nvar _tippy = _interopRequireDefault(require(\"tippy.js\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _ismobilejs = _interopRequireDefault(require(\"ismobilejs\"));\n\nvar _Formio = require(\"../../../Formio\");\n\nvar FormioUtils = _interopRequireWildcard(require(\"../../../utils/utils\"));\n\nvar _Validator = _interopRequireDefault(require(\"../../../validator/Validator\"));\n\nvar _Element2 = _interopRequireDefault(require(\"../../../Element\"));\n\nvar _ComponentModal = _interopRequireDefault(require(\"../componentModal/ComponentModal\"));\n\nvar _widgets = _interopRequireDefault(require(\"../../../widgets\"));\n\nvar _addons = _interopRequireDefault(require(\"../../../addons\"));\n\nvar _uploadAdapter = require(\"../../../providers/storage/uploadAdapter\");\n\nvar _en = _interopRequireDefault(require(\"../../../translations/en\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar isIEBrowser = FormioUtils.getBrowserInfo().ie;\nvar CKEDITOR_URL = isIEBrowser ? 'https://cdn.ckeditor.com/4.14.1/standard/ckeditor.js' : 'https://cdn.form.io/ckeditor/19.0.0/ckeditor.js';\nvar QUILL_URL = isIEBrowser ? 'https://cdn.quilljs.com/1.3.7' : 'https://cdn.quilljs.com/2.0.0-dev.3';\nvar QUILL_TABLE_URL = 'https://cdn.form.io/quill/quill-table.js';\nvar ACE_URL = 'https://cdn.form.io/ace/1.4.10/ace.js';\nvar Templates = _Formio.GlobalFormio.Templates;\n\nif (!Templates) {\n  Templates = require('../../../templates/Templates').default;\n}\n/**\n * This is the Component class\n which all elements within the FormioForm derive from.\n */\n\n\nvar Component = /*#__PURE__*/function (_Element) {\n  _inherits(Component, _Element);\n\n  var _super = _createSuper(Component);\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Initialize a new Component.\n   *\n   * @param {Object} component - The component JSON you wish to initialize.\n   * @param {Object} options - The options for this component.\n   * @param {Object} data - The global data submission object this component will belong.\n   */\n\n  /* eslint-disable max-statements */\n\n\n  function Component(component, options, data) {\n    var _this;\n\n    _classCallCheck(this, Component);\n\n    _this = _super.call(this, Object.assign({\n      renderMode: 'form',\n      attachMode: 'full',\n      noDefaults: false\n    }, options || {})); // Restore the component id.\n\n    if (component && component.id) {\n      _this.id = component.id;\n    }\n    /**\n     * Determines if this component has a condition assigned to it.\n     * @type {null}\n     * @private\n     */\n\n\n    _this._hasCondition = null;\n    /**\n     * References to dom elements\n     */\n\n    _this.refs = {}; // Allow global override for any component JSON.\n\n    if (component && _this.options.components && _this.options.components[component.type]) {\n      _lodash.default.merge(component, _this.options.components[component.type]);\n    }\n    /**\n     * Set the validator instance.\n     */\n\n\n    _this.validator = _Validator.default;\n    /**\n     * The data path to this specific component instance.\n     *\n     * @type {string}\n     */\n\n    _this.path = '';\n    /**\n     * The Form.io component JSON schema.\n     * @type {*}\n     */\n\n    _this.component = _this.mergeSchema(component || {}); // Add the id to the component.\n\n    _this.component.id = _this.id; // Save off the original component to be used in logic.\n\n    _this.originalComponent = (0, FormioUtils.fastCloneDeep)(_this.component);\n    /**\n     * If the component has been attached\n     */\n\n    _this.attached = false;\n    /**\n     * If the component has been rendered\n     */\n\n    _this.rendered = false;\n    /**\n     * The data object in which this component resides.\n     * @type {*}\n     */\n\n    _this._data = data || {};\n    /**\n     * The existing error that this component has.\n     * @type {string}\n     */\n\n    _this.error = '';\n    /**\n     * Tool tip text after processing\n     * @type {string}\n     */\n\n    _this.tooltip = '';\n    /**\n     * The row path of this component.\n     * @type {number}\n     */\n\n    _this.row = _this.options.row;\n    /**\n     * Determines if this component is disabled, or not.\n     *\n     * @type {boolean}\n     */\n\n    _this._disabled = (0, FormioUtils.boolValue)(_this.component.disabled) ? _this.component.disabled : false;\n    /**\n     * Points to the root component, usually the FormComponent.\n     *\n     * @type {Component}\n     */\n\n    _this.root = _this.options.root;\n    _this.localRoot = _this.options.localRoot;\n    /**\n     * If this input has been input and provided value.\n     *\n     * @type {boolean}\n     */\n\n    _this.pristine = true;\n    /**\n     * Points to the parent component.\n     *\n     * @type {Component}\n     */\n\n    _this.parent = _this.options.parent;\n    _this.options.name = _this.options.name || 'data';\n    /**\n     * The validators that are assigned to this component.\n     * @type {[string]}\n     */\n\n    _this.validators = ['required', 'minLength', 'maxLength', 'minWords', 'maxWords', 'custom', 'pattern', 'json', 'mask'];\n    _this._path = ''; // Nested forms don't have parents so we need to pass their path in.\n\n    _this._parentPath = _this.options.parentPath || ''; // Needs for Nextgen Rules Engine\n\n    _this.resetCaches();\n    /**\n     * Determines if this component is visible, or not.\n     */\n\n\n    _this._parentVisible = _this.options.hasOwnProperty('parentVisible') ? _this.options.parentVisible : true;\n    _this._visible = _this._parentVisible && _this.conditionallyVisible(null, data);\n    _this._parentDisabled = false;\n    /**\n     * Used to trigger a new change in this component.\n     * @type {function} - Call to trigger a change in this component.\n     */\n\n    var changes = [];\n    var lastChanged = null;\n    var triggerArgs = [];\n\n    var _triggerChange = _lodash.default.debounce(function () {\n      var _this2;\n\n      if (_this.root) {\n        _this.root.changing = false;\n      }\n\n      triggerArgs = [];\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (!args[1] && lastChanged) {\n        // Set the changed component if one isn't provided.\n        args[1] = lastChanged;\n      }\n\n      if (_lodash.default.isEmpty(args[0]) && lastChanged) {\n        // Set the flags if it is empty and lastChanged exists.\n        args[0] = lastChanged.flags;\n      }\n\n      lastChanged = null;\n      args[3] = changes;\n\n      var retVal = (_this2 = _this).onChange.apply(_this2, args);\n\n      changes = [];\n      return retVal;\n    }, 100);\n\n    _this.triggerChange = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      if (args[1]) {\n        // Make sure that during the debounce that we always track lastChanged component, even if they\n        // don't provide one later.\n        lastChanged = args[1];\n        changes.push(lastChanged);\n      }\n\n      if (_this.root) {\n        _this.root.changing = true;\n      }\n\n      if (args.length) {\n        triggerArgs = args;\n      }\n\n      return _triggerChange.apply(void 0, _toConsumableArray(triggerArgs));\n    };\n    /**\n     * Used to trigger a redraw event within this component.\n     *\n     * @type {Function}\n     */\n\n\n    _this.triggerRedraw = _lodash.default.debounce(_this.redraw.bind(_assertThisInitialized(_this)), 100);\n    /**\n     * list of attached tooltips\n     * @type {Array}\n     */\n\n    _this.tooltips = [];\n    /**\n     * List of attached addons\n     * @type {Array}\n     */\n\n    _this.addons = []; // To force this component to be invalid.\n\n    _this.invalid = false;\n\n    if (_this.component) {\n      _this.type = _this.component.type;\n\n      if (_this.allowData && _this.key) {\n        _this.options.name += \"[\".concat(_this.key, \"]\"); // If component is visible or not set to clear on hide, set the default value.\n\n        if (_this.visible || !_this.component.clearOnHide) {\n          if (!_this.hasValue()) {\n            if (_this.shouldAddDefaultValue) {\n              _this.dataValue = _this.defaultValue;\n            }\n          } else {\n            // Ensure the dataValue is set.\n\n            /* eslint-disable  no-self-assign */\n            _this.dataValue = _this.dataValue;\n            /* eslint-enable  no-self-assign */\n          }\n        }\n      }\n      /**\n       * The element information for creating the input element.\n       * @type {*}\n       */\n\n\n      _this.info = _this.elementInfo();\n    } // Allow anyone to hook into the component creation.\n\n\n    _this.hook('component');\n\n    if (!_this.options.skipInit) {\n      _this.init();\n    }\n\n    return _this;\n  }\n  /* eslint-enable max-statements */\n\n\n  _createClass(Component, [{\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    },\n    set: function set(value) {\n      this._data = value;\n    }\n  }, {\n    key: \"mergeSchema\",\n    value: function mergeSchema() {\n      var component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _lodash.default.defaultsDeep(component, this.defaultSchema);\n    } // Allow componets to notify when ready.\n\n  }, {\n    key: \"ready\",\n    get: function get() {\n      return _nativePromiseOnly.default.resolve(this);\n    }\n  }, {\n    key: \"labelInfo\",\n    get: function get() {\n      var label = {};\n      label.hidden = this.labelIsHidden();\n      label.className = '';\n      label.labelPosition = this.component.labelPosition;\n      label.tooltipClass = \"\".concat(this.iconClass('question-sign'), \" text-muted\");\n      var isPDFReadOnlyMode = this.parent && this.parent.form && this.parent.form.display === 'pdf' && this.options.readOnly;\n\n      if (this.hasInput && this.component.validate && (0, FormioUtils.boolValue)(this.component.validate.required) && !isPDFReadOnlyMode) {\n        label.className += ' field-required';\n      }\n\n      if (label.hidden) {\n        label.className += ' control-label--hidden';\n      }\n\n      if (this.info.attr.id) {\n        label.for = this.info.attr.id;\n      }\n\n      return label;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this$component$addon,\n          _this3 = this;\n\n      this.disabled = this.shouldDisabled;\n      this._visible = this.conditionallyVisible(null, null);\n\n      if ((_this$component$addon = this.component.addons) !== null && _this$component$addon !== void 0 && _this$component$addon.length) {\n        this.component.addons.forEach(function (addon) {\n          return _this3.createAddon(addon);\n        });\n      }\n    }\n  }, {\n    key: \"createAddon\",\n    value: function createAddon(addonConfiguration) {\n      var _addonConfiguration$s;\n\n      var name = addonConfiguration.name;\n\n      if (!name) {\n        return;\n      }\n\n      var settings = ((_addonConfiguration$s = addonConfiguration.settings) === null || _addonConfiguration$s === void 0 ? void 0 : _addonConfiguration$s.data) || {};\n      var Addon = _addons.default[name];\n      var addon = null;\n\n      if (Addon) {\n        var supportedComponents = Addon.info.supportedComponents;\n        var supportsThisComponentType = !(supportedComponents !== null && supportedComponents !== void 0 && supportedComponents.length) || supportedComponents.indexOf(this.component.type) !== -1;\n\n        if (supportsThisComponentType) {\n          addon = new Addon(settings, this);\n          this.addons.push(addon);\n        } else {\n          console.warn(\"Addon \".concat(name, \" does not support component of type \").concat(this.component.type, \".\"));\n        }\n      }\n\n      return addon;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Component.prototype), \"destroy\", this).call(this);\n\n      this.detach();\n      this.addons.forEach(function (addon) {\n        return addon.destroy();\n      });\n    }\n  }, {\n    key: \"shouldDisabled\",\n    get: function get() {\n      return this.options.readOnly || this.component.disabled || this.options.hasOwnProperty('disabled') && this.options.disabled[this.key];\n    }\n  }, {\n    key: \"isInputComponent\",\n    get: function get() {\n      return !this.component.hasOwnProperty('input') || this.component.input;\n    }\n  }, {\n    key: \"allowData\",\n    get: function get() {\n      return this.hasInput;\n    }\n  }, {\n    key: \"hasInput\",\n    get: function get() {\n      return this.isInputComponent || this.refs.input && this.refs.input.length;\n    }\n  }, {\n    key: \"defaultSchema\",\n    get: function get() {\n      return Component.schema();\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      return _lodash.default.get(this.component, 'key', '');\n    }\n  }, {\n    key: \"parentVisible\",\n    get: function get() {\n      return this._parentVisible;\n    },\n    set: function set(value) {\n      this._parentVisible = value;\n    }\n  }, {\n    key: \"parentDisabled\",\n    get: function get() {\n      return this._parentDisabled;\n    }\n    /**\n     *\n     * @param value {boolean}\n     */\n    ,\n    set: function set(value) {\n      this._parentDisabled = value;\n    }\n  }, {\n    key: \"visible\",\n    get:\n    /**\n     *\n     * @returns {boolean}\n     */\n    function get() {\n      // Show only if visibility changes or if we are in builder mode or if hidden fields should be shown.\n      if (this.builderMode || this.previewMode || this.options.showHiddenFields) {\n        return true;\n      }\n\n      if (this.options.hide && this.options.hide[this.component.key]) {\n        return false;\n      }\n\n      if (this.options.show && this.options.show[this.component.key]) {\n        return true;\n      }\n\n      return this._visible && this._parentVisible;\n    },\n    set: function set(value) {\n      if (this._visible !== value) {\n        this._visible = value;\n        this.clearOnHide();\n        this.redraw();\n      }\n    }\n  }, {\n    key: \"currentForm\",\n    get: function get() {\n      return this._currentForm;\n    },\n    set: function set(instance) {\n      this._currentForm = instance;\n    }\n  }, {\n    key: \"fullMode\",\n    get: function get() {\n      return this.options.attachMode === 'full';\n    }\n  }, {\n    key: \"builderMode\",\n    get: function get() {\n      return this.options.attachMode === 'builder';\n    }\n  }, {\n    key: \"calculatedPath\",\n    get: function get() {\n      console.error('component.calculatedPath was deprecated, use component.path instead.');\n      return this.path;\n    }\n  }, {\n    key: \"labelPosition\",\n    get: function get() {\n      return this.component.labelPosition;\n    }\n  }, {\n    key: \"labelWidth\",\n    get: function get() {\n      var width = this.component.labelWidth;\n      return width >= 0 ? width : 30;\n    }\n  }, {\n    key: \"labelMargin\",\n    get: function get() {\n      var margin = this.component.labelMargin;\n      return margin >= 0 ? margin : 3;\n    }\n  }, {\n    key: \"isAdvancedLabel\",\n    get: function get() {\n      return ['left-left', 'left-right', 'right-left', 'right-right'].includes(this.labelPosition);\n    }\n  }, {\n    key: \"labelPositions\",\n    get: function get() {\n      return this.labelPosition.split('-');\n    }\n  }, {\n    key: \"skipInEmail\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"rightDirection\",\n    value: function rightDirection(direction) {\n      return direction === 'right';\n    }\n  }, {\n    key: \"getLabelInfo\",\n    value: function getLabelInfo() {\n      var isRightPosition = this.rightDirection(this.labelPositions[0]);\n      var isLeftPosition = this.labelPositions[0] === 'left';\n      var isRightAlign = this.rightDirection(this.labelPositions[1]);\n      var contentMargin = '';\n\n      if (this.component.hideLabel) {\n        var margin = this.labelWidth + this.labelMargin;\n        contentMargin = isRightPosition ? \"margin-right: \".concat(margin, \"%\") : '';\n        contentMargin = isLeftPosition ? \"margin-left: \".concat(margin, \"%\") : '';\n      }\n\n      var labelStyles = \"\\n      flex: \".concat(this.labelWidth, \";\\n      \").concat(isRightPosition ? 'margin-left' : 'margin-right', \": \").concat(this.labelMargin, \"%;\\n    \");\n      var contentStyles = \"\\n      flex: \".concat(100 - this.labelWidth - this.labelMargin, \";\\n      \").concat(contentMargin, \";\\n      \").concat(this.component.hideLabel ? \"max-width: \".concat(100 - this.labelWidth - this.labelMargin) : '', \";\\n    \");\n      return {\n        isRightPosition: isRightPosition,\n        isRightAlign: isRightAlign,\n        labelStyles: labelStyles,\n        contentStyles: contentStyles\n      };\n    }\n    /**\n     * Returns only the schema that is different from the default.\n     *\n     * @param schema\n     * @param defaultSchema\n     */\n\n  }, {\n    key: \"getModifiedSchema\",\n    value: function getModifiedSchema(schema, defaultSchema, recursion) {\n      var _this4 = this;\n\n      var modified = {};\n\n      if (!defaultSchema) {\n        return schema;\n      }\n\n      _lodash.default.each(schema, function (val, key) {\n        if (!_lodash.default.isArray(val) && _lodash.default.isObject(val) && defaultSchema.hasOwnProperty(key)) {\n          var subModified = _this4.getModifiedSchema(val, defaultSchema[key], true);\n\n          if (!_lodash.default.isEmpty(subModified)) {\n            modified[key] = subModified;\n          }\n        } else if (_lodash.default.isArray(val)) {\n          if (val.length !== 0 && !_lodash.default.isEqual(val, defaultSchema[key])) {\n            modified[key] = val;\n          }\n        } else if (!recursion && key === 'type' || !recursion && key === 'key' || !recursion && key === 'label' || !recursion && key === 'input' || !recursion && key === 'tableView' || val !== '' && !defaultSchema.hasOwnProperty(key) || val !== '' && val !== defaultSchema[key] || defaultSchema[key] && val !== defaultSchema[key]) {\n          modified[key] = val;\n        }\n      });\n\n      return modified;\n    }\n    /**\n     * Returns the JSON schema for this component.\n     */\n\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return (0, FormioUtils.fastCloneDeep)(this.getModifiedSchema(_lodash.default.omit(this.component, 'id'), this.defaultSchema));\n    }\n    /**\n     * Returns true if component is inside DataGrid\n     */\n\n  }, {\n    key: \"isInDataGrid\",\n    get: function get() {\n      return this.inDataGrid;\n    }\n    /**\n     * Translate a text using the i18n system.\n     *\n     * @param {string} text - The i18n identifier.\n     * @param {Object} params - The i18n parameters to use for translation.\n     */\n\n  }, {\n    key: \"t\",\n    value: function t(text) {\n      var _get2;\n\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!text) {\n        return '';\n      } // Use _userInput: true to ignore translations from defaults\n\n\n      if (text in _en.default && params._userInput) {\n        return text;\n      }\n\n      params.data = this.rootValue;\n      params.row = this.data;\n      params.component = this.component;\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(Component.prototype), \"t\", this)).call.apply(_get2, [this, text, params].concat(args));\n    }\n  }, {\n    key: \"labelIsHidden\",\n    value: function labelIsHidden() {\n      return !this.component.label || (!this.isInDataGrid && this.component.hideLabel || this.isInDataGrid && !this.component.dataGridLabel || this.options.inputsOnly) && !this.builderMode;\n    }\n  }, {\n    key: \"transform\",\n    get: function get() {\n      return Templates.current.hasOwnProperty('transform') ? Templates.current.transform.bind(Templates.current) : function (type, value) {\n        return value;\n      };\n    }\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate(names, modes) {\n      modes = Array.isArray(modes) ? modes : [modes];\n      names = Array.isArray(names) ? names : [names];\n\n      if (!modes.includes('form')) {\n        modes.push('form');\n      }\n\n      var result = null;\n\n      if (this.options.templates) {\n        result = this.checkTemplate(this.options.templates, names, modes);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      var frameworkTemplates = this.options.template ? Templates.templates[this.options.template] : Templates.current;\n      result = this.checkTemplate(frameworkTemplates, names, modes);\n\n      if (result) {\n        return result;\n      } // Default back to bootstrap if not defined.\n\n\n      var name = names[names.length - 1];\n      var templatesByName = Templates.defaultTemplates[name];\n\n      if (!templatesByName) {\n        return \"Unknown template: \".concat(name);\n      }\n\n      var templateByMode = this.checkTemplateMode(templatesByName, modes);\n\n      if (templateByMode) {\n        return templateByMode;\n      }\n\n      return templatesByName.form;\n    }\n  }, {\n    key: \"checkTemplate\",\n    value: function checkTemplate(templates, names, modes) {\n      var _iterator = _createForOfIteratorHelper(names),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var name = _step.value;\n          var templatesByName = templates[name];\n\n          if (templatesByName) {\n            var templateByMode = this.checkTemplateMode(templatesByName, modes);\n\n            if (templateByMode) {\n              return templateByMode;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"checkTemplateMode\",\n    value: function checkTemplateMode(templatesByName, modes) {\n      var _iterator2 = _createForOfIteratorHelper(modes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var mode = _step2.value;\n          var templateByMode = templatesByName[mode];\n\n          if (templateByMode) {\n            return templateByMode;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getFormattedTooltip\",\n    value: function getFormattedTooltip(tooltipValue) {\n      var tooltip = this.interpolate(tooltipValue || '').replace(/(?:\\r\\n|\\r|\\n)/g, '<br />');\n      return tooltip ? this.t(tooltip, {\n        _userInput: true\n      }).replace(/\"/g, '&quot;') : '';\n    }\n  }, {\n    key: \"isHtmlRenderMode\",\n    value: function isHtmlRenderMode() {\n      return this.options.renderMode === 'html';\n    }\n  }, {\n    key: \"renderTemplate\",\n    value: function renderTemplate(name) {\n      var _this5 = this;\n\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var modeOption = arguments.length > 2 ? arguments[2] : undefined; // Need to make this fall back to form if renderMode is not found similar to how we search templates.\n\n      var mode = modeOption || this.options.renderMode || 'form';\n      data.component = this.component;\n      data.self = this;\n      data.options = this.options;\n      data.readOnly = this.options.readOnly;\n      data.iconClass = this.iconClass.bind(this);\n      data.size = this.size.bind(this);\n      data.t = this.t.bind(this);\n      data.transform = this.transform;\n      data.id = data.id || this.id;\n      data.key = data.key || this.key;\n      data.value = data.value || this.dataValue;\n      data.disabled = this.disabled;\n      data.builder = this.builderMode;\n\n      data.render = function () {\n        console.warn(\"Form.io 'render' template function is deprecated.\\n      If you need to render template (template A) inside of another template (template B),\\n      pass pre-compiled template A (use this.renderTemplate('template_A_name') as template context variable for template B\");\n        return _this5.renderTemplate.apply(_this5, arguments);\n      };\n\n      data.label = this.labelInfo;\n      data.tooltip = this.getFormattedTooltip(this.component.tooltip); // Allow more specific template names\n\n      var names = [\"\".concat(name, \"-\").concat(this.component.type, \"-\").concat(this.key), \"\".concat(name, \"-\").concat(this.component.type), \"\".concat(name, \"-\").concat(this.key), \"\".concat(name)]; // Allow template alters.\n\n      return this.hook(\"render\".concat(name.charAt(0).toUpperCase() + name.substring(1, name.length)), this.interpolate(this.getTemplate(names, mode), data), data, mode);\n    }\n    /**\n     * Sanitize an html string.\n     *\n     * @param string\n     * @returns {*}\n     */\n\n  }, {\n    key: \"sanitize\",\n    value: function sanitize(dirty, forceSanitize, options) {\n      var _this$options; // No need to sanitize when generating PDF'S since no users interact with the form.\n\n\n      if (!this.shouldSanitizeValue && !forceSanitize || this.options.pdf && !forceSanitize) {\n        return dirty;\n      }\n\n      return FormioUtils.sanitize(dirty, {\n        sanitizeConfig: _lodash.default.merge(((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.sanitizeConfig) || {}, options || {})\n      });\n    }\n    /**\n     * Render a template string into html.\n     *\n     * @param template\n     * @param data\n     * @param actions\n     *\n     * @return {HTMLElement|String} - The created element or an empty string if template is not specified.\n     */\n\n  }, {\n    key: \"renderString\",\n    value: function renderString(template, data) {\n      if (!template) {\n        return '';\n      } // Interpolate the template and populate\n\n\n      return this.interpolate(template, data);\n    }\n  }, {\n    key: \"performInputMapping\",\n    value: function performInputMapping(input) {\n      return input;\n    }\n  }, {\n    key: \"widget\",\n    get: function get() {\n      var _this$root;\n\n      var settings = this.component.widget;\n\n      if (settings && (_this$root = this.root) !== null && _this$root !== void 0 && _this$root.shadowRoot) {\n        settings.shadowRoot = this.root.shadowRoot;\n      }\n\n      var widget = settings && _widgets.default[settings.type] ? new _widgets.default[settings.type](settings, this.component, this) : null;\n      return widget;\n    }\n  }, {\n    key: \"getBrowserLanguage\",\n    value: function getBrowserLanguage() {\n      var nav = window.navigator;\n      var browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'];\n      var language; // support for HTML 5.1 \"navigator.languages\"\n\n      if (Array.isArray(nav.languages)) {\n        for (var i = 0; i < nav.languages.length; i++) {\n          language = nav.languages[i];\n\n          if (language && language.length) {\n            return language.split(';')[0];\n          }\n        }\n      } // support for other well known properties in browsers\n\n\n      for (var _i = 0; _i < browserLanguagePropertyKeys.length; _i++) {\n        language = nav[browserLanguagePropertyKeys[_i]];\n\n        if (language && language.length) {\n          return language.split(';')[0];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Called before a next and previous page is triggered allowing the components\n     * to perform special functions.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforePage\",\n    value: function beforePage() {\n      return _nativePromiseOnly.default.resolve(true);\n    }\n  }, {\n    key: \"beforeNext\",\n    value: function beforeNext() {\n      return this.beforePage(true);\n    }\n    /**\n     * Called before a submission is triggered allowing the components\n     * to perform special async functions.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforeSubmit\",\n    value: function beforeSubmit() {\n      return _nativePromiseOnly.default.resolve(true);\n    }\n    /**\n     * Return the submission timezone.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"submissionTimezone\",\n    get: function get() {\n      this.options.submissionTimezone = this.options.submissionTimezone || _lodash.default.get(this.root, 'options.submissionTimezone');\n      return this.options.submissionTimezone;\n    }\n  }, {\n    key: \"loadRefs\",\n    value: function loadRefs(element, refs) {\n      for (var ref in refs) {\n        var refType = refs[ref];\n        var isString = typeof refType === 'string';\n        var selector = isString && refType.includes('scope') ? \":scope > [ref=\\\"\".concat(ref, \"\\\"]\") : \"[ref=\\\"\".concat(ref, \"\\\"]\");\n\n        if (isString && refType.startsWith('single')) {\n          this.refs[ref] = element.querySelector(selector);\n        } else {\n          this.refs[ref] = element.querySelectorAll(selector);\n        }\n      }\n    }\n  }, {\n    key: \"setOpenModalElement\",\n    value: function setOpenModalElement(template) {\n      this.componentModal.setOpenModalElement(template || this.getModalPreviewTemplate());\n    }\n  }, {\n    key: \"getModalPreviewTemplate\",\n    value: function getModalPreviewTemplate() {\n      var dataValue = this.component.type === 'password' ? this.dataValue.replace(/./g, '•') : this.dataValue;\n      var message = this.error ? {\n        level: 'error',\n        message: this.error.message\n      } : '';\n      return this.renderTemplate('modalPreview', {\n        previewText: this.getValueAsString(dataValue, {\n          modalPreview: true\n        }) || this.t('Click to set value'),\n        messages: message && this.renderTemplate('message', message)\n      });\n    }\n  }, {\n    key: \"build\",\n    value: function build(element) {\n      element = element || this.element;\n      this.empty(element);\n      this.setContent(element, this.render());\n      return this.attach(element);\n    }\n  }, {\n    key: \"hasModalSaveButton\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Unknown component: \".concat(this.component.type);\n      var topLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var isVisible = this.visible;\n      this.rendered = true;\n\n      if (!this.builderMode && !this.previewMode && this.component.modalEdit) {\n        return _ComponentModal.default.render(this, {\n          visible: isVisible,\n          showSaveButton: this.hasModalSaveButton,\n          id: this.id,\n          classes: this.className,\n          styles: this.customStyle,\n          children: children\n        }, topLevel);\n      } else {\n        return this.renderTemplate('component', {\n          visible: isVisible,\n          id: this.id,\n          classes: this.className,\n          styles: this.customStyle,\n          children: children\n        }, topLevel);\n      }\n    }\n  }, {\n    key: \"attachTooltips\",\n    value: function attachTooltips(toolTipsRefs) {\n      var _this6 = this;\n\n      toolTipsRefs === null || toolTipsRefs === void 0 ? void 0 : toolTipsRefs.forEach(function (tooltip, index) {\n        if (tooltip) {\n          var tooltipAttribute = tooltip.getAttribute('data-tooltip');\n          var tooltipDataTitle = tooltip.getAttribute('data-title');\n\n          var tooltipText = _this6.interpolate(tooltipDataTitle || tooltipAttribute).replace(/(?:\\r\\n|\\r|\\n)/g, '<br />');\n\n          _this6.tooltips[index] = (0, _tippy.default)(tooltip, {\n            allowHTML: true,\n            trigger: 'mouseenter click focus',\n            placement: 'right',\n            zIndex: 10000,\n            interactive: true,\n            content: _this6.t(tooltipText, {\n              _userInput: true\n            })\n          });\n        }\n      });\n    }\n  }, {\n    key: \"createComponentModal\",\n    value: function createComponentModal(element, modalShouldBeOpened, currentValue) {\n      return new _ComponentModal.default(this, element, modalShouldBeOpened, currentValue);\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(element) {\n      if (!this.builderMode && !this.previewMode && this.component.modalEdit) {\n        var modalShouldBeOpened = this.componentModal ? this.componentModal.isOpened : false;\n        var currentValue = modalShouldBeOpened ? this.componentModal.currentValue : this.dataValue;\n        var openModalTemplate = this.componentModal && modalShouldBeOpened ? this.componentModal.openModalTemplate : null;\n        this.componentModal = this.createComponentModal(element, modalShouldBeOpened, currentValue);\n        this.setOpenModalElement(openModalTemplate);\n      }\n\n      this.attached = true;\n      this.element = element;\n      element.component = this; // If this already has an id, get it from the dom. If SSR, it could be different from the initiated id.\n\n      if (this.element.id) {\n        this.id = this.element.id;\n        this.component.id = this.id;\n      }\n\n      this.loadRefs(element, {\n        messageContainer: 'single',\n        tooltip: 'multiple'\n      });\n      this.attachTooltips(this.refs.tooltip); // Attach logic.\n\n      this.attachLogic();\n      this.autofocus(); // Allow global attach.\n\n      this.hook('attachComponent', element, this); // Allow attach per component type.\n\n      var type = this.component.type;\n\n      if (type) {\n        this.hook(\"attach\".concat(type.charAt(0).toUpperCase() + type.substring(1, type.length)), element, this);\n      }\n\n      this.restoreFocus();\n      this.addons.forEach(function (addon) {\n        return addon.attach(element);\n      });\n      return _nativePromiseOnly.default.resolve();\n    }\n  }, {\n    key: \"restoreFocus\",\n    value: function restoreFocus() {\n      var _this$root2, _this$root2$focusedCo;\n\n      var isFocused = ((_this$root2 = this.root) === null || _this$root2 === void 0 ? void 0 : (_this$root2$focusedCo = _this$root2.focusedComponent) === null || _this$root2$focusedCo === void 0 ? void 0 : _this$root2$focusedCo.path) === this.path;\n\n      if (isFocused) {\n        var _this$root$currentSel;\n\n        this.loadRefs(this.element, {\n          input: 'multiple'\n        });\n        this.focus((_this$root$currentSel = this.root.currentSelection) === null || _this$root$currentSel === void 0 ? void 0 : _this$root$currentSel.index);\n        this.restoreCaretPosition();\n      }\n    }\n  }, {\n    key: \"addShortcut\",\n    value: function addShortcut(element, shortcut) {\n      // Avoid infinite recursion.\n      if (!element || !this.root || this.root === this) {\n        return;\n      }\n\n      if (!shortcut) {\n        shortcut = this.component.shortcut;\n      }\n\n      this.root.addShortcut(element, shortcut);\n    }\n  }, {\n    key: \"removeShortcut\",\n    value: function removeShortcut(element, shortcut) {\n      // Avoid infinite recursion.\n      if (!element || this.root === this) {\n        return;\n      }\n\n      if (!shortcut) {\n        shortcut = this.component.shortcut;\n      }\n\n      this.root.removeShortcut(element, shortcut);\n    }\n    /**\n     * Remove all event handlers.\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.refs = {};\n      this.removeEventListeners();\n      this.detachLogic();\n\n      if (this.tooltip) {\n        this.tooltip.destroy();\n      }\n    }\n  }, {\n    key: \"checkRefresh\",\n    value: function checkRefresh(refreshData, changed, flags) {\n      var changePath = _lodash.default.get(changed, 'instance.path', false); // Don't let components change themselves.\n\n\n      if (changePath && this.path === changePath) {\n        return;\n      }\n\n      if (refreshData === 'data') {\n        this.refresh(this.data, changed, flags);\n      } else if (changePath && (0, FormioUtils.getComponentPath)(changed.instance) === refreshData && changed && changed.instance && // Make sure the changed component is not in a different \"context\". Solves issues where refreshOn being set\n      // in fields inside EditGrids could alter their state from other rows (which is bad).\n      this.inContext(changed.instance)) {\n        this.refresh(changed.value, changed, flags);\n      }\n    }\n  }, {\n    key: \"checkRefreshOn\",\n    value: function checkRefreshOn(changes) {\n      var _this7 = this;\n\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      changes = changes || [];\n\n      if (flags.noRefresh) {\n        return;\n      }\n\n      if (!changes.length && flags.changed) {\n        changes = [flags.changed];\n      }\n\n      var refreshOn = flags.fromBlur ? this.component.refreshOnBlur : this.component.refreshOn || this.component.redrawOn; // If they wish to refresh on a value, then add that here.\n\n      if (refreshOn) {\n        if (Array.isArray(refreshOn)) {\n          refreshOn.forEach(function (refreshData) {\n            return changes.forEach(function (changed) {\n              return _this7.checkRefresh(refreshData, changed, flags);\n            });\n          });\n        } else {\n          changes.forEach(function (changed) {\n            return _this7.checkRefresh(refreshOn, changed, flags);\n          });\n        }\n      }\n    }\n    /**\n     * Refreshes the component with a new value.\n     *\n     * @param value\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh(value) {\n      if (this.hasOwnProperty('refreshOnValue')) {\n        this.refreshOnChanged = !_lodash.default.isEqual(value, this.refreshOnValue);\n      } else {\n        this.refreshOnChanged = true;\n      }\n\n      this.refreshOnValue = (0, FormioUtils.fastCloneDeep)(value);\n\n      if (this.refreshOnChanged) {\n        if (this.component.clearOnRefresh) {\n          this.setValue(null);\n        }\n\n        this.triggerRedraw();\n      }\n    }\n    /**\n     * Checks to see if a separate component is in the \"context\" of this component. This is determined by first checking\n     * if they share the same \"data\" object. It will then walk up the parent tree and compare its parents data objects\n     * with the components data and returns true if they are in the same context.\n     *\n     * Different rows of the same EditGrid, for example, are in different contexts.\n     *\n     * @param component\n     */\n\n  }, {\n    key: \"inContext\",\n    value: function inContext(component) {\n      if (component.data === this.data) {\n        return true;\n      }\n\n      var parent = this.parent;\n\n      while (parent) {\n        if (parent.data === component.data) {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"viewOnly\",\n    get: function get() {\n      return this.options.readOnly && this.options.viewAsHtml;\n    }\n  }, {\n    key: \"createViewOnlyElement\",\n    value: function createViewOnlyElement() {\n      this.element = this.ce('dl', {\n        id: this.id\n      });\n\n      if (this.element) {\n        // Ensure you can get the component info from the element.\n        this.element.component = this;\n      }\n\n      return this.element;\n    }\n  }, {\n    key: \"defaultViewOnlyValue\",\n    get: function get() {\n      return '-';\n    }\n    /**\n     * Uses the widget to determine the output string.\n     *\n     * @param value\n     * @return {*}\n     */\n\n  }, {\n    key: \"getWidgetValueAsString\",\n    value: function getWidgetValueAsString(value, options) {\n      var _this8 = this;\n\n      var noInputWidget = !this.refs.input || !this.refs.input[0] || !this.refs.input[0].widget;\n\n      if (!value || noInputWidget) {\n        if (!this.widget || !value) {\n          return value;\n        } else {\n          return this.widget.getValueAsString(value);\n        }\n      }\n\n      if (Array.isArray(value)) {\n        var values = [];\n        value.forEach(function (val, index) {\n          var widget = _this8.refs.input[index] && _this8.refs.input[index].widget;\n\n          if (widget) {\n            values.push(widget.getValueAsString(val, options));\n          }\n        });\n        return values;\n      }\n\n      var widget = this.refs.input[0].widget;\n      return widget.getValueAsString(value, options);\n    }\n  }, {\n    key: \"getValueAsString\",\n    value: function getValueAsString(value, options) {\n      if (!value) {\n        return '';\n      }\n\n      value = this.getWidgetValueAsString(value, options);\n\n      if (Array.isArray(value)) {\n        return value.join(', ');\n      }\n\n      if (_lodash.default.isPlainObject(value)) {\n        return JSON.stringify(value);\n      }\n\n      if (value === null || value === undefined) {\n        return '';\n      }\n\n      var stringValue = value.toString();\n      return this.sanitize(stringValue);\n    }\n  }, {\n    key: \"getView\",\n    value: function getView(value, options) {\n      if (this.component.protected) {\n        return '--- PROTECTED ---';\n      }\n\n      return this.getValueAsString(value, options);\n    }\n  }, {\n    key: \"updateItems\",\n    value: function updateItems() {\n      this.restoreValue();\n      this.onChange.apply(this, arguments);\n    }\n    /**\n     * @param {*} data\n     * @param {boolean} [forceUseValue=false] - if true, return 'value' property of the data\n     * @return {*}\n     */\n\n  }, {\n    key: \"itemValue\",\n    value: function itemValue(data) {\n      var forceUseValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (_lodash.default.isObject(data)) {\n        if (this.valueProperty) {\n          return _lodash.default.get(data, this.valueProperty);\n        }\n\n        if (forceUseValue) {\n          return data.value;\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"itemValueForHTMLMode\",\n    value: function itemValueForHTMLMode(value) {\n      var _this9 = this;\n\n      if (Array.isArray(value)) {\n        var values = value.map(function (item) {\n          return Array.isArray(item) ? _this9.itemValueForHTMLMode(item) : _this9.itemValue(item);\n        });\n        return values.join(', ');\n      }\n\n      return this.itemValue(value);\n    }\n  }, {\n    key: \"createModal\",\n    value: function createModal(element, attr, confirm) {\n      var _this10 = this;\n\n      var dialog = this.ce('div', attr || {});\n      this.setContent(dialog, this.renderTemplate('dialog')); // Add refs to dialog, not \"this\".\n\n      dialog.refs = {};\n      this.loadRefs.call(dialog, dialog, {\n        dialogOverlay: 'single',\n        dialogContents: 'single',\n        dialogClose: 'single'\n      });\n      dialog.refs.dialogContents.appendChild(element);\n      document.body.appendChild(dialog);\n      document.body.classList.add('modal-open');\n\n      dialog.close = function () {\n        document.body.classList.remove('modal-open');\n        dialog.dispatchEvent(new CustomEvent('close'));\n      };\n\n      this.addEventListener(dialog, 'close', function () {\n        return _this10.removeChildFrom(dialog, document.body);\n      });\n\n      var close = function close(event) {\n        event.preventDefault();\n        dialog.close();\n      };\n\n      var handleCloseClick = function handleCloseClick(e) {\n        if (confirm) {\n          confirm().then(function () {\n            return close(e);\n          }).catch(function () {});\n        } else {\n          close(e);\n        }\n      };\n\n      this.addEventListener(dialog.refs.dialogOverlay, 'click', handleCloseClick);\n      this.addEventListener(dialog.refs.dialogClose, 'click', handleCloseClick);\n      return dialog;\n    }\n  }, {\n    key: \"optimizeRedraw\",\n    get: function get() {\n      if (this.options.optimizeRedraw && this.element && !this.visible) {\n        this.addClass(this.element, 'formio-removed');\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Retrieves the CSS class name of this component.\n     * @returns {string} - The class name of this component.\n     */\n\n  }, {\n    key: \"className\",\n    get: function get() {\n      var className = this.hasInput ? 'form-group has-feedback ' : '';\n      className += \"formio-component formio-component-\".concat(this.component.type, \" \"); // TODO: find proper way to avoid overriding of default type-based component styles\n\n      if (this.key && this.key !== 'form') {\n        className += \"formio-component-\".concat(this.key, \" \");\n      }\n\n      if (this.component.multiple) {\n        className += 'formio-component-multiple ';\n      }\n\n      if (this.component.customClass) {\n        className += this.component.customClass;\n      }\n\n      if (this.hasInput && this.component.validate && (0, FormioUtils.boolValue)(this.component.validate.required)) {\n        className += ' required';\n      }\n\n      if (this.labelIsHidden()) {\n        className += ' formio-component-label-hidden';\n      }\n\n      if (!this.visible) {\n        className += ' formio-hidden';\n      }\n\n      return className;\n    }\n    /**\n     * Build the custom style from the layout values\n     * @return {string} - The custom style\n     */\n\n  }, {\n    key: \"customStyle\",\n    get: function get() {\n      var customCSS = '';\n\n      _lodash.default.each(this.component.style, function (value, key) {\n        if (value !== '') {\n          customCSS += \"\".concat(key, \":\").concat(value, \";\");\n        }\n      });\n\n      return customCSS;\n    }\n  }, {\n    key: \"isMobile\",\n    get: function get() {\n      return (0, _ismobilejs.default)();\n    }\n    /**\n     * Returns the outside wrapping element of this component.\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"getElement\",\n    value: function getElement() {\n      return this.element;\n    }\n    /**\n     * Create an evaluation context for all script executions and interpolations.\n     *\n     * @param additional\n     * @return {*}\n     */\n\n  }, {\n    key: \"evalContext\",\n    value: function evalContext(additional) {\n      return _get(_getPrototypeOf(Component.prototype), \"evalContext\", this).call(this, Object.assign({\n        component: this.component,\n        row: this.data,\n        rowIndex: this.rowIndex,\n        data: this.rootValue,\n        iconClass: this.iconClass.bind(this),\n        // Bind the translate function to the data context of any interpolated string.\n        // It is useful to translate strings in different scenarions (eg: custom edit grid templates, custom error messages etc.)\n        // and desirable to be publicly available rather than calling the internal {instance.t} function in the template string.\n        t: this.t.bind(this),\n        submission: this.root ? this.root._submission : {\n          data: this.rootValue\n        },\n        form: this.root ? this.root._form : {},\n        options: this.options\n      }, additional));\n    }\n    /**\n     * Sets the pristine flag for this component.\n     *\n     * @param pristine {boolean} - TRUE to make pristine, FALSE not pristine.\n     */\n\n  }, {\n    key: \"setPristine\",\n    value: function setPristine(pristine) {\n      this.pristine = pristine;\n    }\n  }, {\n    key: \"isPristine\",\n    get: function get() {\n      return this.pristine;\n    }\n  }, {\n    key: \"setDirty\",\n    value: function setDirty(dirty) {\n      this.dirty = dirty;\n    }\n  }, {\n    key: \"isDirty\",\n    get: function get() {\n      return this.dirty;\n    }\n    /**\n     * Removes a value out of the data array and rebuild the rows.\n     * @param {number} index - The index of the data element to remove.\n     */\n\n  }, {\n    key: \"removeValue\",\n    value: function removeValue(index) {\n      this.splice(index);\n      this.redraw();\n      this.restoreValue();\n      this.triggerRootChange();\n    }\n  }, {\n    key: \"iconClass\",\n    value: function iconClass(name, spinning) {\n      var iconset = this.options.iconset || Templates.current.defaultIconset || 'fa';\n      return Templates.current.hasOwnProperty('iconClass') ? Templates.current.iconClass(iconset, name, spinning) : this.options.iconset === 'fa' ? Templates.defaultTemplates.iconClass(iconset, name, spinning) : name;\n    }\n  }, {\n    key: \"size\",\n    value: function size(_size) {\n      return Templates.current.hasOwnProperty('size') ? Templates.current.size(_size) : _size;\n    }\n    /**\n     * The readible name for this component.\n     * @returns {string} - The name of the component.\n     */\n\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.t(this.component.label || this.component.placeholder || this.key, {\n        _userInput: true\n      });\n    }\n    /**\n     * Returns the error label for this component.\n     * @return {*}\n     */\n\n  }, {\n    key: \"errorLabel\",\n    get: function get() {\n      return this.t(this.component.errorLabel || this.component.label || this.component.placeholder || this.key);\n    }\n    /**\n     * Get the error message provided a certain type of error.\n     * @param type\n     * @return {*}\n     */\n\n  }, {\n    key: \"errorMessage\",\n    value: function errorMessage(type) {\n      return this.component.errors && this.component.errors[type] ? this.component.errors[type] : type;\n    }\n  }, {\n    key: \"setContent\",\n    value: function setContent(element, content, forceSanitize, sanitizeOptions) {\n      if (element instanceof HTMLElement) {\n        element.innerHTML = this.sanitize(content, forceSanitize, sanitizeOptions);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"restoreCaretPosition\",\n    value: function restoreCaretPosition() {\n      var _this$root3;\n\n      if ((_this$root3 = this.root) !== null && _this$root3 !== void 0 && _this$root3.currentSelection) {\n        var _this$refs$input;\n\n        if ((_this$refs$input = this.refs.input) !== null && _this$refs$input !== void 0 && _this$refs$input.length) {\n          var _this$root$currentSel2 = this.root.currentSelection,\n              selection = _this$root$currentSel2.selection,\n              index = _this$root$currentSel2.index;\n          var input = this.refs.input[index];\n          var isInputRangeSelectable = /text|search|password|tel|url/i.test(input.type || '');\n\n          if (input) {\n            if (isInputRangeSelectable) {\n              var _input;\n\n              (_input = input).setSelectionRange.apply(_input, _toConsumableArray(selection));\n            }\n          } else {\n            var _input$value;\n\n            input = this.refs.input[this.refs.input.length];\n            var lastCharacter = ((_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.length) || 0;\n\n            if (isInputRangeSelectable) {\n              input.setSelectionRange(lastCharacter, lastCharacter);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      // Don't bother if we have not built yet.\n      if (!this.element || !this.element.parentNode || this.optimizeRedraw) {\n        // Return a non-resolving promise.\n        return _nativePromiseOnly.default.resolve();\n      }\n\n      this.detach();\n      this.emit('redraw'); // Since we are going to replace the element, we need to know it's position so we can find it in the parent's children.\n\n      var parent = this.element.parentNode;\n      var index = Array.prototype.indexOf.call(parent.children, this.element);\n      this.element.outerHTML = this.sanitize(this.render());\n      this.element = parent.children[index];\n      return this.attach(this.element);\n    }\n  }, {\n    key: \"rebuild\",\n    value: function rebuild() {\n      this.destroy();\n      this.init();\n      this.visible = this.conditionallyVisible(null, null);\n      return this.redraw();\n    }\n  }, {\n    key: \"removeEventListeners\",\n    value: function removeEventListeners() {\n      _get(_getPrototypeOf(Component.prototype), \"removeEventListeners\", this).call(this);\n\n      this.tooltips.forEach(function (tooltip) {\n        return tooltip.destroy();\n      });\n      this.tooltips = [];\n    }\n  }, {\n    key: \"hasClass\",\n    value: function hasClass(element, className) {\n      if (!element) {\n        return;\n      }\n\n      return _get(_getPrototypeOf(Component.prototype), \"hasClass\", this).call(this, element, this.transform('class', className));\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass(element, className) {\n      if (!element) {\n        return;\n      }\n\n      return _get(_getPrototypeOf(Component.prototype), \"addClass\", this).call(this, element, this.transform('class', className));\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(element, className) {\n      if (!element) {\n        return;\n      }\n\n      return _get(_getPrototypeOf(Component.prototype), \"removeClass\", this).call(this, element, this.transform('class', className));\n    }\n    /**\n     * Determines if this component has a condition defined.\n     *\n     * @return {null}\n     */\n\n  }, {\n    key: \"hasCondition\",\n    value: function hasCondition() {\n      if (this._hasCondition !== null) {\n        return this._hasCondition;\n      }\n\n      this._hasCondition = FormioUtils.hasCondition(this.component);\n      return this._hasCondition;\n    }\n    /**\n     * Check if this component is conditionally visible.\n     *\n     * @param data\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"conditionallyVisible\",\n    value: function conditionallyVisible(data, row) {\n      data = data || this.rootValue;\n      row = row || this.data;\n\n      if (this.builderMode || this.previewMode || !this.hasCondition()) {\n        return !this.component.hidden;\n      }\n\n      data = data || (this.root ? this.root.data : {});\n      return this.checkCondition(row, data);\n    }\n    /**\n     * Checks the condition of this component.\n     *\n     * TODO: Switch row and data parameters to be consistent with other methods.\n     *\n     * @param row - The row contextual data.\n     * @param data - The global data object.\n     * @return {boolean} - True if the condition applies to this component.\n     */\n\n  }, {\n    key: \"checkCondition\",\n    value: function checkCondition(row, data) {\n      return FormioUtils.checkCondition(this.component, row || this.data, data || this.rootValue, this.root ? this.root._form : {}, this);\n    }\n    /**\n     * Check for conditionals and hide/show the element based on those conditions.\n     */\n\n  }, {\n    key: \"checkComponentConditions\",\n    value: function checkComponentConditions(data, flags, row) {\n      data = data || this.rootValue;\n      flags = flags || {};\n      row = row || this.data;\n\n      if (!this.builderMode & !this.previewMode && this.fieldLogic(data, row)) {\n        this.redraw();\n      } // Check advanced conditions\n\n\n      var visible = this.conditionallyVisible(data, row);\n\n      if (this.visible !== visible) {\n        this.visible = visible;\n      }\n\n      return visible;\n    }\n    /**\n     * Checks conditions for this component and any sub components.\n     * @param args\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"checkConditions\",\n    value: function checkConditions(data, flags, row) {\n      data = data || this.rootValue;\n      flags = flags || {};\n      row = row || this.data;\n      return this.checkComponentConditions(data, flags, row);\n    }\n  }, {\n    key: \"logic\",\n    get: function get() {\n      return this.component.logic || [];\n    }\n    /**\n     * Check all triggers and apply necessary actions.\n     *\n     * @param data\n     */\n\n  }, {\n    key: \"fieldLogic\",\n    value: function fieldLogic(data, row) {\n      var _this11 = this;\n\n      data = data || this.rootValue;\n      row = row || this.data;\n      var logics = this.logic; // If there aren't logic, don't go further.\n\n      if (logics.length === 0) {\n        return;\n      }\n\n      var newComponent = (0, FormioUtils.fastCloneDeep)(this.originalComponent);\n      var changed = logics.reduce(function (changed, logic) {\n        var result = FormioUtils.checkTrigger(newComponent, logic.trigger, row, data, _this11.root ? _this11.root._form : {}, _this11);\n        return (result ? _this11.applyActions(newComponent, logic.actions, result, row, data) : false) || changed;\n      }, false); // If component definition changed, replace and mark as changed.\n\n      if (!_lodash.default.isEqual(this.component, newComponent)) {\n        this.component = newComponent;\n        changed = true;\n        var disabled = this.shouldDisabled; // Change disabled state if it has changed\n\n        if (this.disabled !== disabled) {\n          this.disabled = disabled;\n        }\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"isIE\",\n    value: function isIE() {\n      if (typeof window === 'undefined') {\n        return false;\n      }\n\n      var userAgent = window.navigator.userAgent;\n      var msie = userAgent.indexOf('MSIE ');\n\n      if (msie > 0) {\n        // IE 10 or older => return version number\n        return parseInt(userAgent.substring(msie + 5, userAgent.indexOf('.', msie)), 10);\n      }\n\n      var trident = userAgent.indexOf('Trident/');\n\n      if (trident > 0) {\n        // IE 11 => return version number\n        var rv = userAgent.indexOf('rv:');\n        return parseInt(userAgent.substring(rv + 3, userAgent.indexOf('.', rv)), 10);\n      }\n\n      var edge = userAgent.indexOf('Edge/');\n\n      if (edge > 0) {\n        // IE 12 (aka Edge) => return version number\n        return parseInt(userAgent.substring(edge + 5, userAgent.indexOf('.', edge)), 10);\n      } // other browser\n\n\n      return false;\n    }\n  }, {\n    key: \"defineActionValue\",\n    value: function defineActionValue(action, argsObject) {\n      return this.evaluate(action.value, argsObject, 'value');\n    }\n  }, {\n    key: \"applyActions\",\n    value: function applyActions(newComponent, actions, result, row, data) {\n      var _this12 = this;\n\n      data = data || this.rootValue;\n      row = row || this.data;\n      return actions.reduce(function (changed, action) {\n        switch (action.type) {\n          case 'property':\n            {\n              FormioUtils.setActionProperty(newComponent, action, result, row, data, _this12);\n              var property = action.property.value;\n\n              if (!_lodash.default.isEqual(_lodash.default.get(_this12.component, property), _lodash.default.get(newComponent, property))) {\n                changed = true;\n              }\n\n              break;\n            }\n\n          case 'value':\n            {\n              var oldValue = _this12.getValue();\n\n              var newValue = _this12.defineActionValue(action, {\n                value: _lodash.default.clone(oldValue),\n                data: data,\n                row: row,\n                component: newComponent,\n                result: result\n              });\n\n              if (!_lodash.default.isEqual(oldValue, newValue)) {\n                _this12.setValue(newValue);\n\n                if (_this12.viewOnly) {\n                  _this12.dataValue = newValue;\n                }\n\n                changed = true;\n              }\n\n              break;\n            }\n\n          case 'mergeComponentSchema':\n            {\n              var schema = _this12.evaluate(action.schemaDefinition, {\n                value: _lodash.default.clone(_this12.getValue()),\n                data: data,\n                row: row,\n                component: newComponent,\n                result: result\n              }, 'schema');\n\n              _lodash.default.assign(newComponent, schema);\n\n              if (!_lodash.default.isEqual(_this12.component, newComponent)) {\n                changed = true;\n              }\n\n              break;\n            }\n\n          case 'customAction':\n            {\n              var _oldValue = _this12.getValue();\n\n              var _newValue = _this12.evaluate(action.customAction, {\n                value: _lodash.default.clone(_oldValue),\n                data: data,\n                row: row,\n                input: _oldValue,\n                component: newComponent,\n                result: result\n              }, 'value');\n\n              if (!_lodash.default.isEqual(_oldValue, _newValue)) {\n                _this12.setValue(_newValue);\n\n                if (_this12.viewOnly) {\n                  _this12.dataValue = _newValue;\n                }\n\n                changed = true;\n              }\n\n              break;\n            }\n        }\n\n        return changed;\n      }, false);\n    } // Deprecated\n\n  }, {\n    key: \"addInputError\",\n    value: function addInputError(message, dirty, elements) {\n      this.addMessages(message);\n      this.setErrorClasses(elements, dirty, !!message);\n    } // Deprecated\n\n  }, {\n    key: \"removeInputError\",\n    value: function removeInputError(elements) {\n      this.setErrorClasses(elements, true, false);\n    }\n    /**\n     * Add a new input error to this element.\n     *\n     * @param message\n     * @param dirty\n     */\n\n  }, {\n    key: \"addMessages\",\n    value: function addMessages(messages) {\n      var _this13 = this;\n\n      if (!messages) {\n        return;\n      } // Standardize on array of objects for message.\n\n\n      if (typeof messages === 'string') {\n        messages = {\n          messages: messages,\n          level: 'error'\n        };\n      }\n\n      if (!Array.isArray(messages)) {\n        messages = [messages];\n      }\n\n      messages = _lodash.default.uniqBy(messages, function (message) {\n        return message.message;\n      });\n\n      if (this.refs.messageContainer) {\n        this.setContent(this.refs.messageContainer, messages.map(function (message) {\n          return _this13.renderTemplate('message', message);\n        }).join(''));\n      }\n    }\n  }, {\n    key: \"setErrorClasses\",\n    value: function setErrorClasses(elements, dirty, hasErrors, hasMessages) {\n      var _this14 = this;\n\n      var element = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.element;\n      this.clearErrorClasses();\n      elements.forEach(function (element) {\n        _this14.setElementInvalid(_this14.performInputMapping(element), false);\n      });\n      this.setInputWidgetErrorClasses(elements, hasErrors);\n\n      if (hasErrors) {\n        // Add error classes\n        elements.forEach(function (input) {\n          _this14.setElementInvalid(_this14.performInputMapping(input), true);\n        });\n\n        if (dirty && this.options.highlightErrors) {\n          this.addClass(element, this.options.componentErrorClass);\n        } else {\n          this.addClass(element, 'has-error');\n        }\n      }\n\n      if (hasMessages) {\n        this.addClass(element, 'has-message');\n      }\n    }\n  }, {\n    key: \"setElementInvalid\",\n    value: function setElementInvalid(element, invalid) {\n      if (!element) return;\n\n      if (invalid) {\n        this.addClass(element, 'is-invalid');\n      } else {\n        this.removeClass(element, 'is-invalid');\n      }\n\n      element.setAttribute('aria-invalid', invalid ? 'true' : 'false');\n    }\n  }, {\n    key: \"clearOnHide\",\n    value: function clearOnHide() {\n      // clearOnHide defaults to true for old forms (without the value set) so only trigger if the value is false.\n      if ( // if change happens inside EditGrid's row, it doesn't trigger change on the root level, so rootPristine will be true\n      (!this.rootPristine || this.options.server || (0, FormioUtils.isInsideScopingComponent)(this)) && this.component.clearOnHide !== false && !this.options.readOnly && !this.options.showHiddenFields) {\n        if (!this.visible) {\n          this.deleteValue();\n        } else if (!this.hasValue() && this.shouldAddDefaultValue) {\n          // If shown, ensure the default is set.\n          this.setValue(this.defaultValue, {\n            noUpdateEvent: true\n          });\n        }\n      }\n    }\n  }, {\n    key: \"triggerRootChange\",\n    value: function triggerRootChange() {\n      if (this.options.onChange) {\n        var _this$options2;\n\n        (_this$options2 = this.options).onChange.apply(_this$options2, arguments);\n      } else if (this.root) {\n        var _this$root4;\n\n        (_this$root4 = this.root).triggerChange.apply(_this$root4, arguments);\n      }\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(flags, fromRoot) {\n      flags = flags || {};\n\n      if (flags.modified) {\n        if (!flags.noPristineChangeOnModified) {\n          this.pristine = false;\n        }\n\n        this.addClass(this.getElement(), 'formio-modified');\n      } // If we are supposed to validate on blur, then don't trigger validation yet.\n\n\n      if (this.component.validateOn === 'blur' && !this.errors.length) {\n        flags.noValidate = true;\n      }\n\n      if (this.component.onChange) {\n        this.evaluate(this.component.onChange, {\n          flags: flags\n        });\n      } // Set the changed variable.\n\n\n      var changed = {\n        instance: this,\n        component: this.component,\n        value: this.dataValue,\n        flags: flags\n      }; // Emit the change.\n\n      this.emit('componentChange', changed); // Do not propogate the modified flag.\n\n      var modified = false;\n\n      if (flags.modified) {\n        modified = true;\n        delete flags.modified;\n      } // Bubble this change up to the top.\n\n\n      if (!fromRoot) {\n        this.triggerRootChange(flags, changed, modified);\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"wysiwygDefault\",\n    get: function get() {\n      return {\n        quill: {\n          theme: 'snow',\n          placeholder: this.t(this.component.placeholder, {\n            _userInput: true\n          }),\n          modules: {\n            toolbar: [[{\n              'size': ['small', false, 'large', 'huge']\n            }], // custom dropdown\n            [{\n              'header': [1, 2, 3, 4, 5, 6, false]\n            }], [{\n              'font': []\n            }], ['bold', 'italic', 'underline', 'strike', {\n              'script': 'sub'\n            }, {\n              'script': 'super'\n            }, 'clean'], [{\n              'color': []\n            }, {\n              'background': []\n            }], [{\n              'list': 'ordered'\n            }, {\n              'list': 'bullet'\n            }, {\n              'indent': '-1'\n            }, {\n              'indent': '+1'\n            }, {\n              'align': []\n            }], ['blockquote', 'code-block'], ['link', 'image', 'video', 'formula', 'source']]\n          }\n        },\n        ace: {\n          theme: 'ace/theme/xcode',\n          maxLines: 12,\n          minLines: 12,\n          tabSize: 2,\n          mode: 'ace/mode/javascript',\n          placeholder: this.t(this.component.placeholder, {\n            _userInput: true\n          })\n        },\n        ckeditor: {\n          image: {\n            toolbar: ['imageTextAlternative', '|', 'imageStyle:full', 'imageStyle:alignLeft', 'imageStyle:alignCenter', 'imageStyle:alignRight'],\n            styles: ['full', 'alignLeft', 'alignCenter', 'alignRight']\n          },\n          extraPlugins: []\n        },\n        default: {}\n      };\n    }\n  }, {\n    key: \"addCKE\",\n    value: function addCKE(element, settings, onChange) {\n      settings = _lodash.default.isEmpty(settings) ? {} : settings;\n      settings.base64Upload = this.component.isUploadEnabled ? false : true;\n      settings.mediaEmbed = {\n        previewsInData: true\n      };\n      settings = _lodash.default.merge(this.wysiwygDefault.ckeditor, _lodash.default.get(this.options, 'editors.ckeditor.settings', {}), settings);\n\n      if (this.component.isUploadEnabled) {\n        settings.extraPlugins.push((0, _uploadAdapter.getFormioUploadAdapterPlugin)(this.fileService, this));\n      }\n\n      return _Formio.GlobalFormio.requireLibrary('ckeditor', isIEBrowser ? 'CKEDITOR' : 'ClassicEditor', _lodash.default.get(this.options, 'editors.ckeditor.src', CKEDITOR_URL), true).then(function () {\n        if (!element.parentNode) {\n          return _nativePromiseOnly.default.reject();\n        }\n\n        if (isIEBrowser) {\n          var editor = CKEDITOR.replace(element);\n          editor.on('change', function () {\n            return onChange(editor.getData());\n          });\n          return _nativePromiseOnly.default.resolve(editor);\n        } else {\n          return ClassicEditor.create(element, settings).then(function (editor) {\n            editor.model.document.on('change', function () {\n              return onChange(editor.data.get());\n            });\n            return editor;\n          });\n        }\n      });\n    }\n  }, {\n    key: \"addQuill\",\n    value: function addQuill(element, settings, onChange) {\n      var _this15 = this;\n\n      settings = _lodash.default.isEmpty(settings) ? this.wysiwygDefault.quill : settings;\n      settings = _lodash.default.merge(this.wysiwygDefault.quill, _lodash.default.get(this.options, 'editors.quill.settings', {}), settings);\n      settings = _objectSpread(_objectSpread({}, settings), {}, {\n        modules: _objectSpread({\n          table: true\n        }, settings.modules)\n      }); // Lazy load the quill css.\n\n      _Formio.GlobalFormio.requireLibrary(\"quill-css-\".concat(settings.theme), 'Quill', [{\n        type: 'styles',\n        src: \"\".concat(QUILL_URL, \"/quill.\").concat(settings.theme, \".css\")\n      }], true); // Lazy load the quill library.\n\n\n      return _Formio.GlobalFormio.requireLibrary('quill', 'Quill', _lodash.default.get(this.options, 'editors.quill.src', \"\".concat(QUILL_URL, \"/quill.min.js\")), true).then(function () {\n        return _Formio.GlobalFormio.requireLibrary('quill-table', 'Quill', QUILL_TABLE_URL, true).then(function () {\n          if (!element.parentNode) {\n            return _nativePromiseOnly.default.reject();\n          }\n\n          _this15.quill = new Quill(element, isIEBrowser ? _objectSpread(_objectSpread({}, settings), {}, {\n            modules: {}\n          }) : settings);\n          /** This block of code adds the [source] capabilities.  See https://codepen.io/anon/pen/ZyEjrQ **/\n\n          var txtArea = document.createElement('textarea');\n          txtArea.setAttribute('class', 'quill-source-code');\n\n          _this15.quill.addContainer('ql-custom').appendChild(txtArea);\n\n          var qlSource = element.parentNode.querySelector('.ql-source');\n\n          if (qlSource) {\n            _this15.addEventListener(qlSource, 'click', function (event) {\n              event.preventDefault();\n\n              if (txtArea.style.display === 'inherit') {\n                _this15.quill.setContents(_this15.quill.clipboard.convert(txtArea.value));\n              }\n\n              txtArea.style.display = txtArea.style.display === 'none' ? 'inherit' : 'none';\n            });\n          }\n          /** END CODEBLOCK **/\n          // Make sure to select cursor when they click on the element.\n\n\n          _this15.addEventListener(element, 'click', function () {\n            return _this15.quill.focus();\n          }); // Allows users to skip toolbar items when tabbing though form\n\n\n          var elm = document.querySelectorAll('.ql-formats > button');\n\n          for (var i = 0; i < elm.length; i++) {\n            elm[i].setAttribute('tabindex', '-1');\n          }\n\n          _this15.quill.on('text-change', function () {\n            txtArea.value = _this15.quill.root.innerHTML;\n            onChange(txtArea);\n          });\n\n          return _this15.quill;\n        });\n      });\n    }\n  }, {\n    key: \"shouldSanitizeValue\",\n    get: function get() {\n      var _this$options3; // Sanitize value if sanitizing for thw whole content is turned off\n\n\n      return ((_this$options3 = this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.sanitize) !== false;\n    }\n  }, {\n    key: \"addAce\",\n    value: function addAce(element, settings, onChange) {\n      if (!settings || settings.theme === 'snow') {\n        var mode = settings ? settings.mode : '';\n        settings = {};\n\n        if (mode) {\n          settings.mode = mode;\n        }\n      }\n\n      settings = _lodash.default.merge(this.wysiwygDefault.ace, _lodash.default.get(this.options, 'editors.ace.settings', {}), settings || {});\n      return _Formio.GlobalFormio.requireLibrary('ace', 'ace', _lodash.default.get(this.options, 'editors.ace.src', ACE_URL), true).then(function (editor) {\n        editor = editor.edit(element);\n        editor.removeAllListeners('change');\n        editor.setOptions(settings);\n        editor.getSession().setMode(settings.mode);\n        editor.on('change', function () {\n          return onChange(editor.getValue());\n        });\n\n        if (settings.isUseWorkerDisabled) {\n          editor.session.setUseWorker(false);\n        }\n\n        return editor;\n      });\n    }\n  }, {\n    key: \"tree\",\n    get: function get() {\n      return this.component.tree || false;\n    }\n    /**\n     * The empty value for this component.\n     *\n     * @return {null}\n     */\n\n  }, {\n    key: \"emptyValue\",\n    get: function get() {\n      return null;\n    }\n    /**\n     * Returns if this component has a value set.\n     *\n     */\n\n  }, {\n    key: \"hasValue\",\n    value: function hasValue(data) {\n      return _lodash.default.has(data || this.data, this.key);\n    }\n    /**\n     * Get the data value at the root level.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"rootValue\",\n    get: function get() {\n      return this.root ? this.root.data : this.data;\n    }\n  }, {\n    key: \"rootPristine\",\n    get: function get() {\n      return _lodash.default.get(this, 'root.pristine', false);\n    }\n    /**\n     * Get the static value of this component.\n     * @return {*}\n     */\n\n  }, {\n    key: \"dataValue\",\n    get: function get() {\n      if (!this.key || !this.visible && this.component.clearOnHide && !this.rootPristine) {\n        return this.emptyValue;\n      }\n\n      if (!this.hasValue() && this.shouldAddDefaultValue) {\n        var empty = this.component.multiple ? [] : this.emptyValue;\n\n        if (!this.rootPristine) {\n          this.dataValue = empty;\n        }\n\n        return empty;\n      }\n\n      return _lodash.default.get(this._data, this.key);\n    }\n    /**\n     * Sets the static value of this component.\n     *\n     * @param value\n     */\n    ,\n    set: function set(value) {\n      if (!this.allowData || !this.key || !this.visible && this.component.clearOnHide && !this.rootPristine) {\n        return;\n      }\n\n      if (value !== null && value !== undefined) {\n        value = this.hook('setDataValue', value, this.key, this._data);\n      }\n\n      if (value === null || value === undefined) {\n        this.unset();\n        return;\n      }\n\n      _lodash.default.set(this._data, this.key, value);\n\n      return;\n    }\n    /**\n     * Splice a value from the dataValue.\n     *\n     * @param index\n     */\n\n  }, {\n    key: \"splice\",\n    value: function splice(index) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.hasValue()) {\n        var dataValue = this.dataValue || [];\n\n        if (_lodash.default.isArray(dataValue) && dataValue.hasOwnProperty(index)) {\n          dataValue.splice(index, 1);\n          this.dataValue = dataValue;\n          this.triggerChange(flags);\n        }\n      }\n    }\n  }, {\n    key: \"unset\",\n    value: function unset() {\n      _lodash.default.unset(this._data, this.key);\n    }\n    /**\n     * Deletes the value of the component.\n     */\n\n  }, {\n    key: \"deleteValue\",\n    value: function deleteValue() {\n      this.setValue(null, {\n        noUpdateEvent: true,\n        noDefault: true\n      });\n      this.unset();\n    }\n  }, {\n    key: \"getCustomDefaultValue\",\n    value: function getCustomDefaultValue(defaultValue) {\n      if (this.component.customDefaultValue && !this.options.preview) {\n        defaultValue = this.evaluate(this.component.customDefaultValue, {\n          value: ''\n        }, 'value');\n      }\n\n      return defaultValue;\n    }\n  }, {\n    key: \"shouldAddDefaultValue\",\n    get: function get() {\n      return !this.options.noDefaults || this.component.defaultValue && !this.isEmpty(this.component.defaultValue) || this.component.customDefaultValue;\n    }\n  }, {\n    key: \"defaultValue\",\n    get: function get() {\n      var _this16 = this;\n\n      var defaultValue = this.emptyValue;\n\n      if (this.component.defaultValue) {\n        defaultValue = this.component.defaultValue;\n      }\n\n      defaultValue = this.getCustomDefaultValue(defaultValue);\n\n      var checkMask = function checkMask(value) {\n        if (typeof value === 'string') {\n          var placeholderChar = _this16.placeholderChar;\n          value = (0, _vanillaTextMask.conformToMask)(value, _this16.defaultMask, {\n            placeholderChar: placeholderChar\n          }).conformedValue;\n\n          if (!FormioUtils.matchInputMask(value, _this16.defaultMask)) {\n            value = '';\n          }\n        } else {\n          value = '';\n        }\n\n        return value;\n      };\n\n      if (this.defaultMask) {\n        if (Array.isArray(defaultValue)) {\n          defaultValue = defaultValue.map(checkMask);\n        } else {\n          defaultValue = checkMask(defaultValue);\n        }\n      } // Clone so that it creates a new instance.\n\n\n      return _lodash.default.cloneDeep(defaultValue);\n    }\n    /**\n     * Get the input value of this component.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (!this.hasInput || this.viewOnly || !this.refs.input || !this.refs.input.length) {\n        return this.dataValue;\n      }\n\n      var values = [];\n\n      for (var i in this.refs.input) {\n        if (this.refs.input.hasOwnProperty(i)) {\n          if (!this.component.multiple) {\n            return this.getValueAt(i);\n          }\n\n          values.push(this.getValueAt(i));\n        }\n      }\n\n      if (values.length === 0 && !this.component.multiple) {\n        return '';\n      }\n\n      return values;\n    }\n    /**\n     * Get the value at a specific index.\n     *\n     * @param index\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getValueAt\",\n    value: function getValueAt(index) {\n      var input = this.performInputMapping(this.refs.input[index]);\n      return input ? input.value : undefined;\n    }\n    /**\n     * Set the value of this component.\n     *\n     * @param value\n     * @param flags\n     *\n     * @return {boolean} - If the value changed.\n     */\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var changed = this.updateValue(value, flags);\n      value = this.dataValue;\n\n      if (!this.hasInput) {\n        return changed;\n      }\n\n      var isArray = Array.isArray(value);\n      var valueInput = this.refs.fileLink || this.refs.input;\n\n      if (isArray && Array.isArray(this.defaultValue) && this.refs.hasOwnProperty('input') && valueInput && valueInput.length !== value.length && this.visible) {\n        this.redraw();\n      }\n\n      if (this.isHtmlRenderMode() && flags && flags.fromSubmission && changed) {\n        this.redraw();\n        return changed;\n      }\n\n      for (var i in this.refs.input) {\n        if (this.refs.input.hasOwnProperty(i)) {\n          this.setValueAt(i, isArray ? value[i] : value, flags);\n        }\n      }\n\n      return changed;\n    }\n    /**\n     * Set the value at a specific index.\n     *\n     * @param index\n     * @param value\n     */\n\n  }, {\n    key: \"setValueAt\",\n    value: function setValueAt(index, value) {\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!flags.noDefault && (value === null || value === undefined) && !this.component.multiple) {\n        value = this.defaultValue;\n      }\n\n      var input = this.performInputMapping(this.refs.input[index]);\n      var valueMaskInput = this.refs.valueMaskInput;\n\n      if (valueMaskInput !== null && valueMaskInput !== void 0 && valueMaskInput.mask) {\n        valueMaskInput.mask.textMaskInputElement.update(value);\n      }\n\n      if (input.mask) {\n        input.mask.textMaskInputElement.update(value);\n      } else if (input.widget && input.widget.setValue) {\n        input.widget.setValue(value);\n      } else {\n        input.value = value;\n      }\n    }\n  }, {\n    key: \"hasSetValue\",\n    get: function get() {\n      return this.hasValue() && !this.isEmpty(this.dataValue);\n    }\n  }, {\n    key: \"setDefaultValue\",\n    value: function setDefaultValue() {\n      if (this.defaultValue && this.shouldAddDefaultValue) {\n        var defaultValue = this.component.multiple && !this.dataValue.length ? [] : this.defaultValue;\n        this.setValue(defaultValue, {\n          noUpdateEvent: true\n        });\n      }\n    }\n    /**\n     * Restore the value of a control.\n     */\n\n  }, {\n    key: \"restoreValue\",\n    value: function restoreValue() {\n      if (this.hasSetValue) {\n        this.setValue(this.dataValue, {\n          noUpdateEvent: true\n        });\n      } else {\n        this.setDefaultValue();\n      }\n    }\n    /**\n     * Normalize values coming into updateValue.\n     *\n     * @param value\n     * @return {*}\n     */\n\n  }, {\n    key: \"normalizeValue\",\n    value: function normalizeValue(value) {\n      if (this.component.multiple && !Array.isArray(value)) {\n        value = value ? [value] : [];\n      }\n\n      return value;\n    }\n    /**\n     * Update a value of this component.\n     *\n     * @param flags\n     */\n\n  }, {\n    key: \"updateComponentValue\",\n    value: function updateComponentValue(value) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var newValue = !flags.resetValue && (value === undefined || value === null) ? this.getValue() : value;\n      newValue = this.normalizeValue(newValue, flags);\n      var oldValue = this.dataValue;\n      var changed = newValue !== undefined ? this.hasChanged(newValue, oldValue) : false;\n\n      if (changed) {\n        this.dataValue = newValue;\n        changed = this.dataValue !== oldValue;\n        this.updateOnChange(flags, changed);\n      }\n\n      if (this.componentModal && flags && flags.fromSubmission) {\n        this.componentModal.setValue(value);\n      }\n\n      return changed;\n    }\n    /**\n     * Updates the value of this component plus all sub-components.\n     *\n     * @param args\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"updateValue\",\n    value: function updateValue() {\n      return this.updateComponentValue.apply(this, arguments);\n    }\n  }, {\n    key: \"getIcon\",\n    value: function getIcon(name, content, styles) {\n      var ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'icon';\n      return this.renderTemplate('icon', {\n        className: this.iconClass(name),\n        ref: ref,\n        styles: styles,\n        content: content\n      });\n    }\n    /**\n     * Resets the value of this component.\n     */\n\n  }, {\n    key: \"resetValue\",\n    value: function resetValue() {\n      this.unset();\n      this.setValue(this.emptyValue, {\n        noUpdateEvent: true,\n        noValidate: true,\n        resetValue: true\n      });\n    }\n    /**\n     * Determine if the value of this component has changed.\n     *\n     * @param newValue\n     * @param oldValue\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"hasChanged\",\n    value: function hasChanged(newValue, oldValue) {\n      if ((newValue === undefined || newValue === null) && (oldValue === undefined || oldValue === null || this.isEmpty(oldValue))) {\n        return false;\n      } // If we do not have a value and are getting set to anything other than undefined or null, then we changed.\n\n\n      if (newValue !== undefined && newValue !== null && this.allowData && !this.hasValue()) {\n        return true;\n      }\n\n      return !_lodash.default.isEqual(newValue, oldValue);\n    }\n    /**\n     * Update the value on change.\n     *\n     * @param flags\n     */\n\n  }, {\n    key: \"updateOnChange\",\n    value: function updateOnChange() {\n      var flags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var changed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!flags.noUpdateEvent && changed) {\n        this.triggerChange(flags);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Perform a calculated value operation.\n     *\n     * @param data - The global data object.\n     *\n     * @return {boolean} - If the value changed during calculation.\n     */\n\n  }, {\n    key: \"convertNumberOrBoolToString\",\n    value: function convertNumberOrBoolToString(value) {\n      if (typeof value === 'number' || typeof value === 'boolean') {\n        return value.toString();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"doValueCalculation\",\n    value: function doValueCalculation(dataValue, data, row) {\n      return this.evaluate(this.component.calculateValue, {\n        value: dataValue,\n        data: data,\n        row: row || this.data\n      }, 'value');\n    }\n    /* eslint-disable max-statements */\n\n  }, {\n    key: \"calculateComponentValue\",\n    value: function calculateComponentValue(data, flags, row) {\n      // If no calculated value or\n      // hidden and set to clearOnHide (Don't calculate a value for a hidden field set to clear when hidden)\n      var clearOnHide = this.component.clearOnHide;\n      var shouldBeCleared = !this.visible && clearOnHide;\n\n      var allowOverride = _lodash.default.get(this.component, 'allowCalculateOverride', false); // Handle all cases when calculated values should not fire.\n\n\n      if (this.options.readOnly && !this.options.pdf || !(this.component.calculateValue || this.component.calculateValueVariable) || shouldBeCleared || this.options.server && !this.component.calculateServer || flags.dataSourceInitialLoading && allowOverride) {\n        return false;\n      }\n\n      var dataValue = this.dataValue; // Calculate the new value.\n\n      var calculatedValue = this.doValueCalculation(dataValue, data, row, flags);\n\n      if (_lodash.default.isNil(calculatedValue)) {\n        calculatedValue = this.emptyValue;\n      }\n\n      var changed = !_lodash.default.isEqual(dataValue, calculatedValue); // Do not override calculations on server if they have calculateServer set.\n\n      if (allowOverride) {\n        // The value is considered locked if it is not empty and comes from a submission value.\n        var fromSubmission = flags.fromSubmission && this.component.persistent === true;\n\n        if (this.isEmpty(dataValue)) {\n          // Reset the calculation lock if ever the data is cleared.\n          this.calculationLocked = false;\n        } else if (this.calculationLocked || fromSubmission) {\n          this.calculationLocked = true;\n          return false;\n        }\n\n        var firstPass = this.calculatedValue === undefined;\n\n        if (firstPass) {\n          this.calculatedValue = null;\n        }\n\n        var newCalculatedValue = this.normalizeValue(this.convertNumberOrBoolToString(calculatedValue));\n        var previousCalculatedValue = this.normalizeValue(this.convertNumberOrBoolToString(this.calculatedValue));\n        var normalizedDataValue = this.normalizeValue(this.convertNumberOrBoolToString(dataValue));\n        var calculationChanged = !_lodash.default.isEqual(previousCalculatedValue, newCalculatedValue);\n        var previousChanged = !_lodash.default.isEqual(normalizedDataValue, previousCalculatedValue);\n\n        if (calculationChanged && previousChanged && !firstPass) {\n          return false;\n        } // Check to ensure that the calculated value is different than the previously calculated value.\n\n\n        if (previousCalculatedValue && previousChanged && !calculationChanged) {\n          return false;\n        }\n\n        if (flags.isReordered || !calculationChanged) {\n          return false;\n        }\n\n        if (fromSubmission) {\n          // If we set value from submission and it differs from calculated one, set the calculated value to prevent overriding dataValue in the next pass\n          this.calculatedValue = calculatedValue;\n          return false;\n        } // If this is the firstPass, and the dataValue is different than to the calculatedValue.\n\n\n        if (firstPass && !this.isEmpty(dataValue) && changed && calculationChanged) {\n          // Return that we have a change so it will perform another pass.\n          return true;\n        }\n      }\n\n      this.calculatedValue = calculatedValue;\n\n      if (changed) {\n        if (!flags.noPristineChangeOnModified) {\n          this.pristine = false;\n        }\n\n        flags.triggeredComponentId = this.id;\n        return this.setValue(calculatedValue, flags);\n      }\n\n      return false;\n    }\n    /* eslint-enable max-statements */\n\n    /**\n     * Performs calculations in this component plus any child components.\n     *\n     * @param args\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"calculateValue\",\n    value: function calculateValue(data, flags, row) {\n      data = data || this.rootValue;\n      flags = flags || {};\n      row = row || this.data;\n      return this.calculateComponentValue(data, flags, row);\n    }\n    /**\n     * Get this component's label text.\n     *\n     */\n\n  }, {\n    key: \"label\",\n    get: function get() {\n      return this.component.label;\n    }\n    /**\n     * Set this component's label text and render it.\n     *\n     * @param value - The new label text.\n     */\n    ,\n    set: function set(value) {\n      this.component.label = value;\n\n      if (this.labelElement) {\n        this.labelElement.innerText = value;\n      }\n    }\n    /**\n     * Get FormioForm element at the root of this component tree.\n     *\n     */\n\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      return this.root;\n    }\n    /**\n     * Returns the invalid message, or empty string if the component is valid.\n     *\n     * @param data\n     * @param dirty\n     * @return {*}\n     */\n\n  }, {\n    key: \"invalidMessage\",\n    value: function invalidMessage(data, dirty, ignoreCondition, row) {\n      if (!ignoreCondition && !this.checkCondition(row, data)) {\n        return '';\n      } // See if this is forced invalid.\n\n\n      if (this.invalid) {\n        return this.invalid;\n      } // No need to check for errors if there is no input or if it is pristine.\n\n\n      if (!this.hasInput || !dirty && this.pristine) {\n        return '';\n      }\n\n      return _lodash.default.map(_Validator.default.checkComponent(this, data), 'message').join('\\n\\n');\n    }\n    /**\n     * Returns if the component is valid or not.\n     *\n     * @param data\n     * @param dirty\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(data, dirty) {\n      return !this.invalidMessage(data, dirty);\n    }\n  }, {\n    key: \"setComponentValidity\",\n    value: function setComponentValidity(messages, dirty, silentCheck) {\n      var hasErrors = !!messages.filter(function (message) {\n        return message.level === 'error' && !message.fromServer;\n      }).length;\n\n      if (messages.length && (!silentCheck || this.error) && (!this.isEmpty(this.defaultValue) || dirty || !this.pristine)) {\n        this.setCustomValidity(messages, dirty);\n      } else if (!silentCheck) {\n        this.setCustomValidity('');\n      }\n\n      return !hasErrors;\n    }\n    /**\n     * Checks the validity of this component and sets the error message if it is invalid.\n     *\n     * @param data\n     * @param dirty\n     * @param row\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"checkComponentValidity\",\n    value: function checkComponentValidity(data, dirty, row) {\n      var _this$serverErrors,\n          _this17 = this;\n\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      data = data || this.rootValue;\n      row = row || this.data;\n      var _options$async = options.async,\n          async = _options$async === void 0 ? false : _options$async,\n          _options$silentCheck = options.silentCheck,\n          silentCheck = _options$silentCheck === void 0 ? false : _options$silentCheck;\n\n      if (this.shouldSkipValidation(data, dirty, row)) {\n        this.setCustomValidity('');\n        return async ? _nativePromiseOnly.default.resolve(true) : true;\n      }\n\n      var check = _Validator.default.checkComponent(this, data, row, true, async);\n\n      var validations = check;\n\n      if ((_this$serverErrors = this.serverErrors) !== null && _this$serverErrors !== void 0 && _this$serverErrors.length) {\n        validations = check.concat(this.serverErrors);\n      }\n\n      return async ? validations.then(function (messages) {\n        return _this17.setComponentValidity(messages, dirty, silentCheck);\n      }) : this.setComponentValidity(validations, dirty, silentCheck);\n    }\n  }, {\n    key: \"checkValidity\",\n    value: function checkValidity(data, dirty, row, silentCheck) {\n      data = data || this.rootValue;\n      row = row || this.data;\n      var isValid = this.checkComponentValidity(data, dirty, row, {\n        silentCheck: silentCheck\n      });\n      this.checkModal();\n      return isValid;\n    }\n  }, {\n    key: \"checkAsyncValidity\",\n    value: function checkAsyncValidity(data, dirty, row, silentCheck) {\n      return _nativePromiseOnly.default.resolve(this.checkComponentValidity(data, dirty, row, {\n        async: true,\n        silentCheck: silentCheck\n      }));\n    }\n    /**\n     * Check the conditions, calculations, and validity of a single component and triggers an update if\n     * something changed.\n     *\n     * @param data - The root data of the change event.\n     * @param flags - The flags from this change event.\n     *\n     * @return boolean - If component is valid or not.\n     */\n\n  }, {\n    key: \"checkData\",\n    value: function checkData(data, flags, row) {\n      data = data || this.rootValue;\n      flags = flags || {};\n      row = row || this.data; // Needs for Nextgen Rules Engine\n\n      this.resetCaches(); // Do not trigger refresh if change was triggered on blur event since components with Refresh on Blur have their own listeners\n\n      if (!flags.fromBlur) {\n        this.checkRefreshOn(flags.changes, flags);\n      }\n\n      if (flags.noCheck) {\n        return true;\n      }\n\n      this.checkComponentConditions(data, flags, row);\n\n      if (this.id !== flags.triggeredComponentId) {\n        this.calculateComponentValue(data, flags, row);\n      }\n\n      if (flags.noValidate && !flags.validateOnInit && !flags.fromIframe) {\n        if (flags.fromSubmission && this.rootPristine && this.pristine && this.error && flags.changed) {\n          this.checkComponentValidity(data, !!this.options.alwaysDirty, row, true);\n        }\n\n        return true;\n      }\n\n      var isDirty = false; // We need to set dirty if they explicitly set noValidate to false.\n\n      if (this.options.alwaysDirty || flags.dirty) {\n        isDirty = true;\n      } // See if they explicitely set the values with setSubmission.\n\n\n      if (flags.fromSubmission && this.hasValue(data)) {\n        isDirty = true;\n      }\n\n      this.setDirty(isDirty);\n\n      if (this.component.validateOn === 'blur' && flags.fromSubmission) {\n        return true;\n      }\n\n      var isValid = this.checkComponentValidity(data, isDirty, row, flags);\n      this.checkModal();\n      return isValid;\n    }\n  }, {\n    key: \"checkModal\",\n    value: function checkModal() {\n      var isValid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var dirty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!this.component.modalEdit || !this.componentModal) {\n        return;\n      }\n\n      if (dirty && !isValid) {\n        this.setErrorClasses([this.refs.openModal], dirty, !isValid, !!this.errors.length, this.refs.openModalWrapper);\n      } else {\n        this.clearErrorClasses(this.refs.openModalWrapper);\n      }\n    }\n  }, {\n    key: \"validationValue\",\n    get: function get() {\n      return this.dataValue;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dataValue;\n      var isEmptyArray = _lodash.default.isArray(value) && value.length === 1 ? _lodash.default.isEqual(value[0], this.emptyValue) : false;\n      return value == null || value.length === 0 || _lodash.default.isEqual(value, this.emptyValue) || isEmptyArray;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(valueA) {\n      var valueB = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dataValue;\n      return this.isEmpty(valueA) && this.isEmpty(valueB) || _lodash.default.isEqual(valueA, valueB);\n    }\n    /**\n     * Check if a component is eligible for multiple validation\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"validateMultiple\",\n    value: function validateMultiple() {\n      return true;\n    }\n  }, {\n    key: \"errors\",\n    get: function get() {\n      return this.error ? [this.error] : [];\n    }\n  }, {\n    key: \"clearErrorClasses\",\n    value: function clearErrorClasses() {\n      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element;\n      this.removeClass(element, this.options.componentErrorClass);\n      this.removeClass(element, 'alert alert-danger');\n      this.removeClass(element, 'has-error');\n      this.removeClass(element, 'has-message');\n    }\n  }, {\n    key: \"setInputWidgetErrorClasses\",\n    value: function setInputWidgetErrorClasses(inputRefs, hasErrors) {\n      if (!this.isInputComponent || !this.component.widget || !(inputRefs !== null && inputRefs !== void 0 && inputRefs.length)) {\n        return;\n      }\n\n      inputRefs.forEach(function (input) {\n        if (input !== null && input !== void 0 && input.widget && input.widget.setErrorClasses) {\n          input.widget.setErrorClasses(hasErrors);\n        }\n      });\n    }\n  }, {\n    key: \"setCustomValidity\",\n    value: function setCustomValidity(messages, dirty, external) {\n      var _this18 = this;\n\n      var inputRefs = this.isInputComponent ? this.refs.input || [] : null;\n\n      if (typeof messages === 'string' && messages) {\n        messages = {\n          level: 'error',\n          message: messages\n        };\n      }\n\n      if (!Array.isArray(messages)) {\n        if (messages) {\n          messages = [messages];\n        } else {\n          messages = [];\n        }\n      }\n\n      var hasErrors = !!messages.filter(function (message) {\n        return message.level === 'error';\n      }).length;\n      var invalidInputRefs = inputRefs;\n\n      if (this.component.multiple) {\n        var inputRefsArray = Array.from(inputRefs);\n        inputRefsArray.forEach(function (input) {\n          _this18.setElementInvalid(_this18.performInputMapping(input), false);\n        });\n        invalidInputRefs = inputRefsArray.filter(function (ref) {\n          var _messages$some, _messages;\n\n          return (_messages$some = (_messages = messages).some) === null || _messages$some === void 0 ? void 0 : _messages$some.call(_messages, function (msg) {\n            var _msg$context;\n\n            return (msg === null || msg === void 0 ? void 0 : (_msg$context = msg.context) === null || _msg$context === void 0 ? void 0 : _msg$context.input) === ref;\n          });\n        });\n      }\n\n      if (messages.length) {\n        if (this.refs.messageContainer) {\n          this.empty(this.refs.messageContainer);\n        }\n\n        this.error = {\n          component: this.component,\n          message: messages[0].message,\n          messages: messages,\n          external: !!external\n        };\n        this.emit('componentError', this.error);\n        this.addMessages(messages, dirty, invalidInputRefs);\n\n        if (invalidInputRefs) {\n          this.setErrorClasses(invalidInputRefs, dirty, hasErrors, !!messages.length);\n        }\n      } else if (!this.error || this.error && this.error.external === !!external) {\n        if (this.refs.messageContainer) {\n          this.empty(this.refs.messageContainer);\n        }\n\n        if (this.refs.modalMessageContainer) {\n          this.empty(this.refs.modalMessageContainer);\n        }\n\n        this.error = null;\n\n        if (invalidInputRefs) {\n          this.setErrorClasses(invalidInputRefs, dirty, hasErrors, !!messages.length);\n        }\n\n        this.clearErrorClasses();\n      } // if (!this.refs.input) {\n      //   return;\n      // }\n      // this.refs.input.forEach(input => {\n      //   input = this.performInputMapping(input);\n      //   if (typeof input.setCustomValidity === 'function') {\n      //     input.setCustomValidity(message, dirty);\n      //   }\n      // });\n\n    }\n    /**\n     * Determines if the value of this component is hidden from the user as if it is coming from the server, but is\n     * protected.\n     *\n     * @return {boolean|*}\n     */\n\n  }, {\n    key: \"isValueHidden\",\n    value: function isValueHidden() {\n      if (this.component.protected && this.root.editing) {\n        return false;\n      }\n\n      if (!this.root || !this.root.hasOwnProperty('editing')) {\n        return false;\n      }\n\n      if (!this.root || !this.root.editing) {\n        return false;\n      }\n\n      return this.component.protected || !this.component.persistent || this.component.persistent === 'client-only';\n    }\n  }, {\n    key: \"shouldSkipValidation\",\n    value: function shouldSkipValidation(data, dirty, row) {\n      var _this19 = this;\n\n      var rules = [// Force valid if component is read-only\n      function () {\n        return _this19.options.readOnly;\n      }, // Do not check validations if component is not an input component.\n      function () {\n        return !_this19.hasInput;\n      }, // Check to see if we are editing and if so, check component persistence.\n      function () {\n        return _this19.isValueHidden();\n      }, // Force valid if component is hidden.\n      function () {\n        return !_this19.visible;\n      }, // Force valid if component is conditionally hidden.\n      function () {\n        return !_this19.checkCondition(row, data);\n      }];\n      return rules.some(function (pred) {\n        return pred();\n      });\n    } // Maintain reverse compatibility.\n\n  }, {\n    key: \"whenReady\",\n    value: function whenReady() {\n      console.warn('The whenReady() method has been deprecated. Please use the dataReady property instead.');\n      return this.dataReady;\n    }\n  }, {\n    key: \"dataReady\",\n    get: function get() {\n      return _nativePromiseOnly.default.resolve();\n    }\n    /**\n     * Prints out the value of this component as a string value.\n     */\n\n  }, {\n    key: \"asString\",\n    value: function asString(value) {\n      value = value || this.getValue();\n      return (Array.isArray(value) ? value : [value]).map(_lodash.default.toString).join(', ');\n    }\n    /**\n     * Return if the component is disabled.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this._disabled || this.parentDisabled;\n    }\n    /**\n     * Disable this component.\n     *\n     * @param {boolean} disabled\n     */\n    ,\n    set: function set(disabled) {\n      this._disabled = disabled;\n    }\n  }, {\n    key: \"setDisabled\",\n    value: function setDisabled(element, disabled) {\n      if (!element) {\n        return;\n      }\n\n      element.disabled = disabled;\n\n      if (disabled) {\n        element.setAttribute('disabled', 'disabled');\n      } else {\n        element.removeAttribute('disabled');\n      }\n    }\n  }, {\n    key: \"setLoading\",\n    value: function setLoading(element, loading) {\n      if (!element || element.loading === loading) {\n        return;\n      }\n\n      element.loading = loading;\n\n      if (!element.loader && loading) {\n        element.loader = this.ce('i', {\n          class: \"\".concat(this.iconClass('refresh', true), \" button-icon-right\")\n        });\n      }\n\n      if (element.loader) {\n        if (loading) {\n          this.appendTo(element.loader, element);\n        } else {\n          this.removeChildFrom(element.loader, element);\n        }\n      }\n    }\n  }, {\n    key: \"selectOptions\",\n    value: function selectOptions(select, tag, options, defaultValue) {\n      var _this20 = this;\n\n      _lodash.default.each(options, function (option) {\n        var attrs = {\n          value: option.value\n        };\n\n        if (defaultValue !== undefined && option.value === defaultValue) {\n          attrs.selected = 'selected';\n        }\n\n        var optionElement = _this20.ce('option', attrs);\n\n        optionElement.appendChild(_this20.text(option.label));\n        select.appendChild(optionElement);\n      });\n    }\n  }, {\n    key: \"setSelectValue\",\n    value: function setSelectValue(select, value) {\n      var options = select.querySelectorAll('option');\n\n      _lodash.default.each(options, function (option) {\n        if (option.value === value) {\n          option.setAttribute('selected', 'selected');\n        } else {\n          option.removeAttribute('selected');\n        }\n      });\n\n      if (select.onchange) {\n        select.onchange();\n      }\n\n      if (select.onselect) {\n        select.onselect();\n      }\n    }\n  }, {\n    key: \"getRelativePath\",\n    value: function getRelativePath(path) {\n      var keyPart = \".\".concat(this.key);\n      var thisPath = this.isInputComponent ? this.path : this.path.slice(0).replace(keyPart, '');\n      return path.replace(thisPath, '');\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.detach();\n      this.empty(this.getElement());\n    }\n  }, {\n    key: \"append\",\n    value: function append(element) {\n      this.appendTo(element, this.element);\n    }\n  }, {\n    key: \"prepend\",\n    value: function prepend(element) {\n      this.prependTo(element, this.element);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(element) {\n      this.removeChildFrom(element, this.element);\n    }\n  }, {\n    key: \"detachLogic\",\n    value: function detachLogic() {\n      var _this21 = this;\n\n      this.logic.forEach(function (logic) {\n        if (logic.trigger.type === 'event') {\n          var event = _this21.interpolate(logic.trigger.event);\n\n          _this21.off(event); // only applies to callbacks on this component\n\n        }\n      });\n    }\n  }, {\n    key: \"attachLogic\",\n    value: function attachLogic() {\n      var _this22 = this; // Do not attach logic during builder mode.\n\n\n      if (this.builderMode) {\n        return;\n      }\n\n      this.logic.forEach(function (logic) {\n        if (logic.trigger.type === 'event') {\n          var event = _this22.interpolate(logic.trigger.event);\n\n          _this22.on(event, function () {\n            var newComponent = (0, FormioUtils.fastCloneDeep)(_this22.originalComponent);\n\n            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              args[_key4] = arguments[_key4];\n            }\n\n            if (_this22.applyActions(newComponent, logic.actions, args)) {\n              // If component definition changed, replace it.\n              if (!_lodash.default.isEqual(_this22.component, newComponent)) {\n                _this22.component = newComponent;\n\n                var visible = _this22.conditionallyVisible(null, null);\n\n                var disabled = _this22.shouldDisabled; // Change states which won't be recalculated during redrawing\n\n                if (_this22.visible !== visible) {\n                  _this22.visible = visible;\n                }\n\n                if (_this22.disabled !== disabled) {\n                  _this22.disabled = disabled;\n                }\n\n                _this22.redraw();\n              }\n            }\n          }, true);\n        }\n      });\n    }\n    /**\n     * Get the element information.\n     */\n\n  }, {\n    key: \"elementInfo\",\n    value: function elementInfo() {\n      var attributes = {\n        name: this.options.name,\n        type: this.component.inputType || 'text',\n        class: 'form-control',\n        lang: this.options.language\n      };\n\n      if (this.component.placeholder) {\n        attributes.placeholder = this.t(this.component.placeholder, {\n          _userInput: true\n        });\n      }\n\n      if (this.component.tabindex) {\n        attributes.tabindex = this.component.tabindex;\n      }\n\n      if (this.disabled) {\n        attributes.disabled = 'disabled';\n      }\n\n      _lodash.default.defaults(attributes, this.component.attributes);\n\n      return {\n        type: 'input',\n        component: this.component,\n        changeEvent: 'change',\n        attr: attributes\n      };\n    }\n  }, {\n    key: \"autofocus\",\n    value: function autofocus() {\n      var _this23 = this;\n\n      var hasAutofocus = this.component.autofocus && !this.builderMode && !this.options.preview;\n\n      if (hasAutofocus) {\n        this.on('render', function () {\n          return _this23.focus();\n        }, true);\n      }\n    }\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView() {\n      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element;\n\n      if (!element) {\n        return;\n      }\n\n      var _element$getBoundingC = element.getBoundingClientRect(),\n          left = _element$getBoundingC.left,\n          top = _element$getBoundingC.top;\n\n      window.scrollTo(left + window.scrollX, top + window.scrollY);\n    }\n  }, {\n    key: \"focus\",\n    value: function focus(index) {\n      var _this$refs$input2;\n\n      if ('beforeFocus' in this.parent) {\n        this.parent.beforeFocus(this);\n      }\n\n      if ((_this$refs$input2 = this.refs.input) !== null && _this$refs$input2 !== void 0 && _this$refs$input2.length) {\n        var _this$component$widge;\n\n        var focusingInput = typeof index === 'number' && this.refs.input[index] ? this.refs.input[index] : this.refs.input[this.refs.input.length - 1];\n\n        if (((_this$component$widge = this.component.widget) === null || _this$component$widge === void 0 ? void 0 : _this$component$widge.type) === 'calendar') {\n          var sibling = focusingInput.nextSibling;\n\n          if (sibling) {\n            sibling.focus();\n          }\n        } else {\n          focusingInput.focus();\n        }\n      }\n\n      if (this.refs.openModal) {\n        this.refs.openModal.focus();\n      }\n\n      if (this.parent.refs.openModal) {\n        this.parent.refs.openModal.focus();\n      }\n    }\n    /**\n     * Get `Formio` instance for working with files\n     */\n\n  }, {\n    key: \"fileService\",\n    get: function get() {\n      if (this.options.fileService) {\n        return this.options.fileService;\n      }\n\n      if (this.options.formio) {\n        return this.options.formio;\n      }\n\n      if (this.root && this.root.formio) {\n        return this.root.formio;\n      }\n\n      var formio = new _Formio.GlobalFormio(); // If a form is loaded, then make sure to set the correct formUrl.\n\n      if (this.root && this.root._form && this.root._form._id) {\n        formio.formUrl = \"\".concat(formio.projectUrl, \"/form/\").concat(this.root._form._id);\n      }\n\n      return formio;\n    }\n  }, {\n    key: \"resetCaches\",\n    value: function resetCaches() {}\n  }, {\n    key: \"previewMode\",\n    get: function get() {\n      return false;\n    }\n  }], [{\n    key: \"schema\",\n    value: function schema() {\n      for (var _len5 = arguments.length, sources = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        sources[_key5] = arguments[_key5];\n      }\n\n      return _lodash.default.merge.apply(_lodash.default, [{\n        /**\n         * Determines if this component provides an input.\n         */\n        input: true,\n\n        /**\n         * The data key for this component (how the data is stored in the database).\n         */\n        key: '',\n\n        /**\n         * The input placeholder for this component.\n         */\n        placeholder: '',\n\n        /**\n         * The input prefix\n         */\n        prefix: '',\n\n        /**\n         * The custom CSS class to provide to this component.\n         */\n        customClass: '',\n\n        /**\n         * The input suffix.\n         */\n        suffix: '',\n\n        /**\n         * If this component should allow an array of values to be captured.\n         */\n        multiple: false,\n\n        /**\n         * The default value of this component.\n         */\n        defaultValue: null,\n\n        /**\n         * If the data of this component should be protected (no GET api requests can see the data)\n         */\n        protected: false,\n\n        /**\n         * Validate if the value of this component should be unique within the form.\n         */\n        unique: false,\n\n        /**\n         * If the value of this component should be persisted within the backend api database.\n         */\n        persistent: true,\n\n        /**\n         * Determines if the component should be within the form, but not visible.\n         */\n        hidden: false,\n\n        /**\n         * If the component should be cleared when hidden.\n         */\n        clearOnHide: true,\n\n        /**\n         * This will refresh this component options when this field changes.\n         */\n        refreshOn: '',\n\n        /**\n         * This will redraw the component when this field changes.\n         */\n        redrawOn: '',\n\n        /**\n         * If this component should be included as a column within a submission table.\n         */\n        tableView: false,\n\n        /**\n         * If this component should be rendering in modal.\n         */\n        modalEdit: false,\n\n        /**\n         * The input label provided to this component.\n         */\n        label: '',\n        dataGridLabel: false,\n        labelPosition: 'top',\n        description: '',\n        errorLabel: '',\n        tooltip: '',\n        hideLabel: false,\n        tabindex: '',\n        disabled: false,\n        autofocus: false,\n        dbIndex: false,\n        customDefaultValue: '',\n        calculateValue: '',\n        calculateServer: false,\n        widget: null,\n\n        /**\n         * Attributes that will be assigned to the input elements of this component.\n         */\n        attributes: {},\n\n        /**\n         * This will perform the validation on either \"change\" or \"blur\" of the input element.\n         */\n        validateOn: 'change',\n\n        /**\n         * The validation criteria for this component.\n         */\n        validate: {\n          /**\n           * If this component is required.\n           */\n          required: false,\n\n          /**\n           * Custom JavaScript validation.\n           */\n          custom: '',\n\n          /**\n           * If the custom validation should remain private (only the backend will see it and execute it).\n           */\n          customPrivate: false,\n\n          /**\n           * If this component should implement a strict date validation if the Calendar widget is implemented.\n           */\n          strictDateValidation: false,\n          multiple: false,\n          unique: false\n        },\n\n        /**\n         * The simple conditional settings for a component.\n         */\n        conditional: {\n          show: null,\n          when: null,\n          eq: ''\n        },\n        overlay: {\n          style: '',\n          left: '',\n          top: '',\n          width: '',\n          height: ''\n        },\n        allowCalculateOverride: false,\n        encrypted: false,\n        showCharCount: false,\n        showWordCount: false,\n        properties: {},\n        allowMultipleMasks: false,\n        addons: []\n      }].concat(sources));\n    }\n    /**\n     * Return the validator as part of the component.\n     *\n     * @return {ValidationChecker}\n     * @constructor\n     */\n\n  }, {\n    key: \"Validator\",\n    get: function get() {\n      return _Validator.default;\n    }\n    /**\n     * Provides a table view for this component. Override if you wish to do something different than using getView\n     * method of your instance.\n     *\n     * @param value\n     * @param options\n     */\n\n    /* eslint-disable no-unused-vars */\n\n  }, {\n    key: \"tableView\",\n    value: function tableView(value, options) {}\n  }]);\n\n  return Component;\n}(_Element2.default);\n\nexports.default = Component;\nComponent.externalLibraries = {};\n\nComponent.requireLibrary = function (name, property, src, polling) {\n  if (!Component.externalLibraries.hasOwnProperty(name)) {\n    Component.externalLibraries[name] = {};\n    Component.externalLibraries[name].ready = new _nativePromiseOnly.default(function (resolve, reject) {\n      Component.externalLibraries[name].resolve = resolve;\n      Component.externalLibraries[name].reject = reject;\n    });\n    var callbackName = \"\".concat(name, \"Callback\");\n\n    if (!polling && !window[callbackName]) {\n      window[callbackName] = function () {\n        this.resolve();\n      }.bind(Component.externalLibraries[name]);\n    } // See if the plugin already exists.\n\n\n    var plugin = _lodash.default.get(window, property);\n\n    if (plugin) {\n      Component.externalLibraries[name].resolve(plugin);\n    } else {\n      src = Array.isArray(src) ? src : [src];\n      src.forEach(function (lib) {\n        var attrs = {};\n        var elementType = '';\n\n        if (typeof lib === 'string') {\n          lib = {\n            type: 'script',\n            src: lib\n          };\n        }\n\n        switch (lib.type) {\n          case 'script':\n            elementType = 'script';\n            attrs = {\n              src: lib.src,\n              type: 'text/javascript',\n              defer: true,\n              async: true\n            };\n            break;\n\n          case 'styles':\n            elementType = 'link';\n            attrs = {\n              href: lib.src,\n              rel: 'stylesheet'\n            };\n            break;\n        } // Add the script to the top page.\n\n\n        var script = document.createElement(elementType);\n\n        for (var attr in attrs) {\n          script.setAttribute(attr, attrs[attr]);\n        }\n\n        document.getElementsByTagName('head')[0].appendChild(script);\n      }); // if no callback is provided, then check periodically for the script.\n\n      if (polling) {\n        setTimeout(function checkLibrary() {\n          var plugin = _lodash.default.get(window, property);\n\n          if (plugin) {\n            Component.externalLibraries[name].resolve(plugin);\n          } else {\n            // check again after 200 ms.\n            setTimeout(checkLibrary, 200);\n          }\n        }, 200);\n      }\n    }\n  }\n\n  return Component.externalLibraries[name].ready;\n};\n\nComponent.libraryReady = function (name) {\n  if (Component.externalLibraries.hasOwnProperty(name) && Component.externalLibraries[name].ready) {\n    return Component.externalLibraries[name].ready;\n  }\n\n  return _nativePromiseOnly.default.reject(\"\".concat(name, \" library was not required.\"));\n};","map":null,"metadata":{},"sourceType":"script"}