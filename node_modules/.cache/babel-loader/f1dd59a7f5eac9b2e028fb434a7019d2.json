{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.filter\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.array.sort\");\n\nrequire(\"core-js/modules/es.number.constructor\");\n\nrequire(\"core-js/modules/es.object.assign\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.regexp.constructor\");\n\nrequire(\"core-js/modules/es.regexp.exec\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.includes\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.match\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.string.search\");\n\nrequire(\"core-js/modules/es.string.split\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.GlobalFormio = void 0;\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nvar _fetchPonyfill2 = _interopRequireDefault(require(\"fetch-ponyfill\"));\n\nvar _EventEmitter = _interopRequireDefault(require(\"./EventEmitter\"));\n\nvar _browserCookies = _interopRequireDefault(require(\"browser-cookies\"));\n\nvar _providers = _interopRequireDefault(require(\"./providers\"));\n\nvar _intersection2 = _interopRequireDefault(require(\"lodash/intersection\"));\n\nvar _get2 = _interopRequireDefault(require(\"lodash/get\"));\n\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\nvar _defaults2 = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _utils = require(\"./utils/utils\");\n\nvar _jwtDecode = _interopRequireDefault(require(\"jwt-decode\"));\n\nrequire(\"./polyfills\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nvar _fetchPonyfill = (0, _fetchPonyfill2.default)({\n  Promise: _nativePromiseOnly.default\n}),\n    fetch = _fetchPonyfill.fetch,\n    Headers = _fetchPonyfill.Headers;\n\nvar isBoolean = function isBoolean(val) {\n  return _typeof(val) === _typeof(true);\n};\n\nvar isNil = function isNil(val) {\n  return val === null || val === undefined;\n};\n\nvar isObject = function isObject(val) {\n  return val && _typeof(val) === 'object';\n};\n\nfunction cloneResponse(response) {\n  var copy = (0, _cloneDeep2.default)(response);\n\n  if (Array.isArray(response)) {\n    copy.skip = response.skip;\n    copy.limit = response.limit;\n    copy.serverCount = response.serverCount;\n  }\n\n  return copy;\n}\n/**\n * The Formio interface class.\n *\n *   let formio = new Formio('https://examples.form.io/example');\n */\n\n\nvar Formio = /*#__PURE__*/function () {\n  /* eslint-disable max-statements */\n  function Formio(path) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Formio); // Ensure we have an instance of Formio.\n\n\n    if (!(this instanceof Formio)) {\n      return new Formio(path);\n    } // Initialize our variables.\n\n\n    this.base = '';\n    this.projectsUrl = '';\n    this.projectUrl = '';\n    this.projectId = '';\n    this.roleUrl = '';\n    this.rolesUrl = '';\n    this.roleId = '';\n    this.formUrl = '';\n    this.formsUrl = '';\n    this.formId = '';\n    this.submissionsUrl = '';\n    this.submissionUrl = '';\n    this.submissionId = '';\n    this.actionsUrl = '';\n    this.actionId = '';\n    this.actionUrl = '';\n    this.vsUrl = '';\n    this.vId = '';\n    this.vUrl = '';\n    this.query = ''; // Store the original path and options.\n\n    this.path = path;\n    this.options = options;\n\n    if (options.hasOwnProperty('base')) {\n      this.base = options.base;\n    } else if (Formio.baseUrl) {\n      this.base = Formio.baseUrl;\n    } else if (typeof window !== 'undefined') {\n      this.base = window.location.href.match(/http[s]?:\\/\\/api./)[0];\n    }\n\n    if (!path) {\n      // Allow user to create new projects if this was instantiated without\n      // a url\n      this.projectUrl = Formio.projectUrl || \"\".concat(this.base, \"/project\");\n      this.projectsUrl = \"\".concat(this.base, \"/project\");\n      this.projectId = false;\n      this.query = '';\n      return;\n    }\n\n    if (options.hasOwnProperty('project')) {\n      this.projectUrl = options.project;\n    }\n\n    var project = this.projectUrl || Formio.projectUrl;\n    var projectRegEx = /(^|\\/)(project)($|\\/[^/]+)/;\n    var isProjectUrl = path.search(projectRegEx) !== -1; // The baseURL is the same as the projectUrl, and does not contain \"/project/MONGO_ID\" in\n    // its domain. This is almost certainly against the Open Source server.\n\n    if (project && this.base === project && !isProjectUrl) {\n      this.noProject = true;\n      this.projectUrl = this.base;\n    } // Normalize to an absolute path.\n\n\n    if (path.indexOf('http') !== 0 && path.indexOf('//') !== 0) {\n      path = this.base + path;\n    }\n\n    var hostparts = this.getUrlParts(path);\n    var parts = [];\n    var hostName = hostparts[1] + hostparts[2];\n    path = hostparts.length > 3 ? hostparts[3] : '';\n    var queryparts = path.split('?');\n\n    if (queryparts.length > 1) {\n      path = queryparts[0];\n      this.query = \"?\".concat(queryparts[1]);\n    } // Register a specific path.\n\n\n    var registerPath = function registerPath(name, base) {\n      _this[\"\".concat(name, \"sUrl\")] = \"\".concat(base, \"/\").concat(name);\n      var regex = new RegExp(\"/\".concat(name, \"/([^/]+)\"));\n\n      if (path.search(regex) !== -1) {\n        parts = path.match(regex);\n        _this[\"\".concat(name, \"Url\")] = parts ? base + parts[0] : '';\n        _this[\"\".concat(name, \"Id\")] = parts.length > 1 ? parts[1] : '';\n        base += parts[0];\n      }\n\n      return base;\n    }; // Register an array of items.\n\n\n    var registerItems = function registerItems(items, base, staticBase) {\n      for (var i in items) {\n        if (items.hasOwnProperty(i)) {\n          var item = items[i];\n\n          if (Array.isArray(item)) {\n            registerItems(item, base, true);\n          } else {\n            var newBase = registerPath(item, base);\n            base = staticBase ? base : newBase;\n          }\n        }\n      }\n    };\n\n    if (!this.projectUrl || this.projectUrl === this.base) {\n      // If a project uses Subdirectories path type, we need to specify a projectUrl\n      if (!this.projectUrl && !isProjectUrl && Formio.pathType === 'Subdirectories') {\n        var regex = \"^\".concat(hostName.replace(/\\//g, '\\\\/'), \".[^/]+\");\n        var match = project.match(new RegExp(regex));\n        this.projectUrl = match ? match[0] : hostName;\n      } else {\n        this.projectUrl = hostName;\n      }\n    } // Check if we have a specified path type.\n\n\n    var isNotSubdomainType = false;\n\n    if (Formio.pathType) {\n      isNotSubdomainType = Formio.pathType !== 'Subdomains';\n    }\n\n    if (!this.noProject) {\n      // Determine the projectUrl and projectId\n      if (isProjectUrl) {\n        // Get project id as project/:projectId.\n        registerItems(['project'], hostName);\n        path = path.replace(projectRegEx, '');\n      } else if (hostName === this.base) {\n        // Get project id as first part of path (subdirectory).\n        if (hostparts.length > 3 && path.split('/').length > 1) {\n          var pathParts = path.split('/');\n          pathParts.shift(); // Throw away the first /.\n\n          this.projectId = pathParts.shift();\n          path = \"/\".concat(pathParts.join('/'));\n          this.projectUrl = \"\".concat(hostName, \"/\").concat(this.projectId);\n        }\n      } else {\n        // Get project id from subdomain.\n        if (hostparts.length > 2 && (hostparts[2].split('.').length > 2 || hostName.includes('localhost')) && !isNotSubdomainType) {\n          this.projectUrl = hostName;\n          this.projectId = hostparts[2].split('.')[0];\n        }\n      }\n\n      this.projectsUrl = this.projectsUrl || \"\".concat(this.base, \"/project\");\n    } // Configure Role urls and role ids.\n\n\n    registerItems(['role'], this.projectUrl); // Configure Form urls and form ids.\n\n    if (/(^|\\/)(form)($|\\/)/.test(path)) {\n      registerItems(['form', ['submission', 'action', 'v']], this.projectUrl);\n    } else {\n      var subRegEx = new RegExp('/(submission|action|v)($|/.*)');\n      var subs = path.match(subRegEx);\n      this.pathType = subs && subs.length > 1 ? subs[1] : '';\n      path = path.replace(subRegEx, '');\n      path = path.replace(/\\/$/, '');\n      this.formsUrl = \"\".concat(this.projectUrl, \"/form\");\n      this.formUrl = path ? this.projectUrl + path : '';\n      this.formId = path.replace(/^\\/+|\\/+$/g, '');\n      var items = ['submission', 'action', 'v'];\n\n      for (var i in items) {\n        if (items.hasOwnProperty(i)) {\n          var item = items[i];\n          this[\"\".concat(item, \"sUrl\")] = \"\".concat(this.projectUrl + path, \"/\").concat(item);\n\n          if (this.pathType === item && subs.length > 2 && subs[2]) {\n            this[\"\".concat(item, \"Id\")] = subs[2].replace(/^\\/+|\\/+$/g, '');\n            this[\"\".concat(item, \"Url\")] = this.projectUrl + path + subs[0];\n          }\n        }\n      }\n    } // Set the app url if it is not set.\n\n\n    if (!Formio.projectUrlSet) {\n      Formio.projectUrl = this.projectUrl;\n    }\n  }\n  /* eslint-enable max-statements */\n\n\n  _createClass(Formio, [{\n    key: \"delete\",\n    value: function _delete(type, opts) {\n      var _id = \"\".concat(type, \"Id\");\n\n      var _url = \"\".concat(type, \"Url\");\n\n      if (!this[_id]) {\n        return _nativePromiseOnly.default.reject('Nothing to delete');\n      }\n\n      Formio.cache = {};\n      return this.makeRequest(type, this[_url], 'delete', null, opts);\n    }\n  }, {\n    key: \"index\",\n    value: function index(type, query, opts) {\n      var _url = \"\".concat(type, \"Url\");\n\n      query = query || '';\n\n      if (query && isObject(query)) {\n        query = \"?\".concat(Formio.serialize(query.params));\n      }\n\n      return this.makeRequest(type, this[_url] + query, 'get', null, opts);\n    }\n  }, {\n    key: \"save\",\n    value: function save(type, data, opts) {\n      var _id = \"\".concat(type, \"Id\");\n\n      var _url = \"\".concat(type, \"Url\");\n\n      var method = this[_id] || data._id ? 'put' : 'post';\n      var reqUrl = this[_id] ? this[_url] : this[\"\".concat(type, \"sUrl\")];\n\n      if (!this[_id] && data._id && method === 'put' && !reqUrl.includes(data._id)) {\n        reqUrl += \"/\".concat(data._id);\n      }\n\n      Formio.cache = {};\n      return this.makeRequest(type, reqUrl + this.query, method, data, opts);\n    }\n  }, {\n    key: \"load\",\n    value: function load(type, query, opts) {\n      var _id = \"\".concat(type, \"Id\");\n\n      var _url = \"\".concat(type, \"Url\");\n\n      if (query && isObject(query)) {\n        query = Formio.serialize(query.params);\n      }\n\n      if (query) {\n        query = this.query ? \"\".concat(this.query, \"&\").concat(query) : \"?\".concat(query);\n      } else {\n        query = this.query;\n      }\n\n      if (!this[_id]) {\n        return _nativePromiseOnly.default.reject(\"Missing \".concat(_id));\n      }\n\n      var url = this[_url] + query;\n\n      if (type === 'form' && !isNaN(parseInt(this.vId)) && parseInt(this.vId) !== 0) {\n        url += url.match(/\\?/) ? '&' : '?';\n        url += \"formRevision=\".concat(this.vId);\n      }\n\n      return this.makeRequest(type, url, 'get', null, opts);\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return Formio.makeRequest.apply(Formio, [this].concat(args));\n    }\n  }, {\n    key: \"loadProject\",\n    value: function loadProject(query, opts) {\n      return this.load('project', query, opts);\n    }\n  }, {\n    key: \"saveProject\",\n    value: function saveProject(data, opts) {\n      return this.save('project', data, opts);\n    }\n  }, {\n    key: \"deleteProject\",\n    value: function deleteProject(opts) {\n      return this.delete('project', opts);\n    }\n  }, {\n    key: \"loadRole\",\n    value: function loadRole(opts) {\n      return this.load('role', null, opts);\n    }\n  }, {\n    key: \"saveRole\",\n    value: function saveRole(data, opts) {\n      return this.save('role', data, opts);\n    }\n  }, {\n    key: \"deleteRole\",\n    value: function deleteRole(opts) {\n      return this.delete('role', opts);\n    }\n  }, {\n    key: \"loadRoles\",\n    value: function loadRoles(opts) {\n      return this.index('roles', null, opts);\n    }\n  }, {\n    key: \"loadForm\",\n    value: function loadForm(query, opts) {\n      var _this2 = this;\n\n      return this.load('form', query, opts).then(function (currentForm) {\n        // Check to see if there isn't a number in vId.\n        if (!currentForm.revisions || isNaN(parseInt(_this2.vId))) {\n          return currentForm;\n        } // If a submission already exists but form is marked to load current version of form.\n\n\n        if (currentForm.revisions === 'current' && _this2.submissionId) {\n          return currentForm;\n        } // eslint-disable-next-line eqeqeq\n\n\n        if (currentForm._vid == _this2.vId || currentForm.revisionId === _this2.vId) {\n          return currentForm;\n        } // If they specified a revision form, load the revised form components.\n\n\n        if (query && isObject(query)) {\n          query = Formio.serialize(query.params);\n        }\n\n        if (query) {\n          query = _this2.query ? \"\".concat(_this2.query, \"&\").concat(query) : \"?\".concat(query);\n        } else {\n          query = _this2.query;\n        }\n\n        return _this2.makeRequest('form', _this2.vUrl + query, 'get', null, opts).then(function (revisionForm) {\n          currentForm._vid = revisionForm._vid;\n          currentForm.components = revisionForm.components;\n          currentForm.settings = revisionForm.settings;\n          currentForm.revisionId = revisionForm.revisionId; // Using object.assign so we don't cross polinate multiple form loads.\n\n          return Object.assign({}, currentForm);\n        }) // If we couldn't load the revision, just return the original form.\n        .catch(function () {\n          return Object.assign({}, currentForm);\n        });\n      });\n    }\n  }, {\n    key: \"saveForm\",\n    value: function saveForm(data, opts) {\n      return this.save('form', data, opts);\n    }\n  }, {\n    key: \"deleteForm\",\n    value: function deleteForm(opts) {\n      return this.delete('form', opts);\n    }\n  }, {\n    key: \"loadForms\",\n    value: function loadForms(query, opts) {\n      return this.index('forms', query, opts);\n    }\n  }, {\n    key: \"loadSubmission\",\n    value: function loadSubmission(query, opts) {\n      var _this3 = this;\n\n      return this.load('submission', query, opts).then(function (submission) {\n        _this3.vId = submission._frid || submission._fvid;\n        _this3.vUrl = \"\".concat(_this3.formUrl, \"/v/\").concat(_this3.vId);\n        return submission;\n      });\n    }\n  }, {\n    key: \"saveSubmission\",\n    value: function saveSubmission(data, opts) {\n      if (!isNaN(parseInt(this.vId))) {\n        data._fvid = this.vId;\n      }\n\n      return this.save('submission', data, opts);\n    }\n  }, {\n    key: \"deleteSubmission\",\n    value: function deleteSubmission(opts) {\n      return this.delete('submission', opts);\n    }\n  }, {\n    key: \"loadSubmissions\",\n    value: function loadSubmissions(query, opts) {\n      return this.index('submissions', query, opts);\n    }\n  }, {\n    key: \"loadAction\",\n    value: function loadAction(query, opts) {\n      return this.load('action', query, opts);\n    }\n  }, {\n    key: \"saveAction\",\n    value: function saveAction(data, opts) {\n      return this.save('action', data, opts);\n    }\n  }, {\n    key: \"deleteAction\",\n    value: function deleteAction(opts) {\n      return this.delete('action', opts);\n    }\n  }, {\n    key: \"loadActions\",\n    value: function loadActions(query, opts) {\n      return this.index('actions', query, opts);\n    }\n  }, {\n    key: \"availableActions\",\n    value: function availableActions() {\n      return this.makeRequest('availableActions', \"\".concat(this.formUrl, \"/actions\"));\n    }\n  }, {\n    key: \"actionInfo\",\n    value: function actionInfo(name) {\n      return this.makeRequest('actionInfo', \"\".concat(this.formUrl, \"/actions/\").concat(name));\n    }\n  }, {\n    key: \"isObjectId\",\n    value: function isObjectId(id) {\n      var checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\n      return checkForHexRegExp.test(id);\n    }\n  }, {\n    key: \"getProjectId\",\n    value: function getProjectId() {\n      if (!this.projectId) {\n        return _nativePromiseOnly.default.resolve('');\n      }\n\n      if (this.isObjectId(this.projectId)) {\n        return _nativePromiseOnly.default.resolve(this.projectId);\n      } else {\n        return this.loadProject().then(function (project) {\n          return project._id;\n        });\n      }\n    }\n  }, {\n    key: \"getFormId\",\n    value: function getFormId() {\n      if (!this.formId) {\n        return _nativePromiseOnly.default.resolve('');\n      }\n\n      if (this.isObjectId(this.formId)) {\n        return _nativePromiseOnly.default.resolve(this.formId);\n      } else {\n        return this.loadForm().then(function (form) {\n          return form._id;\n        });\n      }\n    }\n  }, {\n    key: \"currentUser\",\n    value: function currentUser(options) {\n      return Formio.currentUser(this, options);\n    }\n  }, {\n    key: \"accessInfo\",\n    value: function accessInfo() {\n      return Formio.accessInfo(this);\n    }\n    /**\n     * Returns the JWT token for this instance.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"getToken\",\n    value: function getToken(options) {\n      return Formio.getToken(Object.assign({\n        formio: this\n      }, this.options, options));\n    }\n    /**\n     * Sets the JWT token for this instance.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"setToken\",\n    value: function setToken(token, options) {\n      return Formio.setToken(token, Object.assign({\n        formio: this\n      }, this.options, options));\n    }\n    /**\n     * Returns a temporary authentication token for single purpose token generation.\n     */\n\n  }, {\n    key: \"getTempToken\",\n    value: function getTempToken(expire, allowed, options) {\n      var token = Formio.getToken(options);\n\n      if (!token) {\n        return _nativePromiseOnly.default.reject('You must be authenticated to generate a temporary auth token.');\n      }\n\n      var authUrl = Formio.authUrl || this.projectUrl;\n      return this.makeRequest('tempToken', \"\".concat(authUrl, \"/token\"), 'GET', null, {\n        ignoreCache: true,\n        header: new Headers({\n          'x-expire': expire,\n          'x-allow': allowed\n        })\n      });\n    }\n    /**\n     * Get a download url for a submission PDF of this submission.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"getDownloadUrl\",\n    value: function getDownloadUrl(form) {\n      var _this4 = this;\n\n      if (!this.submissionId) {\n        return _nativePromiseOnly.default.resolve('');\n      }\n\n      if (!form) {\n        // Make sure to load the form first.\n        return this.loadForm().then(function (_form) {\n          if (!_form) {\n            return '';\n          }\n\n          return _this4.getDownloadUrl(_form);\n        });\n      }\n\n      var apiUrl = \"/project/\".concat(form.project);\n      apiUrl += \"/form/\".concat(form._id);\n      apiUrl += \"/submission/\".concat(this.submissionId);\n      var postfix = form.submissionRevisions && form.settings.changeLog ? '/download/changelog' : '/download';\n      apiUrl += postfix;\n      var download = this.base + apiUrl;\n      return new _nativePromiseOnly.default(function (resolve, reject) {\n        _this4.getTempToken(3600, \"GET:\".concat(apiUrl)).then(function (tempToken) {\n          download += \"?token=\".concat(tempToken.key);\n          resolve(download);\n        }, function () {\n          resolve(download);\n        }).catch(reject);\n      });\n    }\n  }, {\n    key: \"uploadFile\",\n    value: function uploadFile(storage, file, fileName, dir, progressCallback, url, options, fileKey, groupPermissions, groupId, uploadStartCallback, abortCallback) {\n      var _this5 = this;\n\n      var requestArgs = {\n        provider: storage,\n        method: 'upload',\n        file: file,\n        fileName: fileName,\n        dir: dir\n      };\n      fileKey = fileKey || 'file';\n      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {\n        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {\n          if (storage && isNil(result)) {\n            var Provider = _providers.default.getProvider('storage', storage);\n\n            if (Provider) {\n              var provider = new Provider(_this5);\n\n              if (uploadStartCallback) {\n                uploadStartCallback();\n              }\n\n              return provider.uploadFile(file, fileName, dir, progressCallback, url, options, fileKey, groupPermissions, groupId, abortCallback);\n            } else {\n              throw 'Storage provider not found';\n            }\n          }\n\n          return result || {\n            url: ''\n          };\n        });\n      });\n      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);\n    }\n  }, {\n    key: \"downloadFile\",\n    value: function downloadFile(file, options) {\n      var _this6 = this;\n\n      var requestArgs = {\n        method: 'download',\n        file: file\n      };\n      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {\n        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {\n          if (file.storage && isNil(result)) {\n            var Provider = _providers.default.getProvider('storage', file.storage);\n\n            if (Provider) {\n              var provider = new Provider(_this6);\n              return provider.downloadFile(file, options);\n            } else {\n              throw 'Storage provider not found';\n            }\n          }\n\n          return result || {\n            url: ''\n          };\n        });\n      });\n      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);\n    }\n  }, {\n    key: \"deleteFile\",\n    value: function deleteFile(file, options) {\n      var _this7 = this;\n\n      var requestArgs = {\n        method: 'delete',\n        file: file\n      };\n      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {\n        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {\n          if (file.storage && isNil(result)) {\n            var Provider = _providers.default.getProvider('storage', file.storage);\n\n            if (Provider) {\n              var provider = new Provider(_this7);\n              return provider.deleteFile(file, options);\n            } else {\n              throw 'Storage provider not found';\n            }\n          }\n\n          return result || {\n            url: ''\n          };\n        });\n      });\n      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);\n    }\n    /**\n     * Returns the user permissions to a form and submission.\n     *\n     * @param user - The user or current user if undefined. For anonymous, use \"null\"\n     * @param form - The form or current form if undefined. For no form check, use \"null\"\n     * @param submission - The submisison or \"index\" if undefined.\n     *\n     * @return {create: boolean, read: boolean, edit: boolean, delete: boolean}\n     */\n\n  }, {\n    key: \"userPermissions\",\n    value: function userPermissions(user, form, submission) {\n      return _nativePromiseOnly.default.all([form !== undefined ? _nativePromiseOnly.default.resolve(form) : this.loadForm(), user !== undefined ? _nativePromiseOnly.default.resolve(user) : this.currentUser(), submission !== undefined || !this.submissionId ? _nativePromiseOnly.default.resolve(submission) : this.loadSubmission(), this.accessInfo()]).then(function (results) {\n        var form = results.shift();\n        var user = results.shift() || {\n          _id: false,\n          roles: []\n        };\n        var submission = results.shift();\n        var access = results.shift();\n        var permMap = {\n          create: 'create',\n          read: 'read',\n          update: 'edit',\n          delete: 'delete'\n        };\n        var perms = {\n          user: user,\n          form: form,\n          access: access,\n          create: false,\n          read: false,\n          edit: false,\n          delete: false\n        };\n\n        for (var roleName in access.roles) {\n          if (access.roles.hasOwnProperty(roleName)) {\n            var role = access.roles[roleName];\n\n            if (role.default && user._id === false) {\n              // User is anonymous. Add the anonymous role.\n              user.roles.push(role._id);\n            } else if (role.admin && user.roles.indexOf(role._id) !== -1) {\n              perms.create = true;\n              perms.read = true;\n              perms.delete = true;\n              perms.edit = true;\n              return perms;\n            }\n          }\n        }\n\n        if (form && form.submissionAccess) {\n          for (var i = 0; i < form.submissionAccess.length; i++) {\n            var permission = form.submissionAccess[i];\n\n            var _permission$type$spli = permission.type.split('_'),\n                _permission$type$spli2 = _slicedToArray(_permission$type$spli, 2),\n                perm = _permission$type$spli2[0],\n                scope = _permission$type$spli2[1];\n\n            if (['create', 'read', 'update', 'delete'].includes(perm)) {\n              if ((0, _intersection2.default)(permission.roles, user.roles).length) {\n                perms[permMap[perm]] = scope === 'all' || !submission || user._id === submission.owner;\n              }\n            }\n          }\n        } // check for Group Permissions\n\n\n        if (submission) {\n          // we would anyway need to loop through components for create permission, so we'll do that for all of them\n          (0, _utils.eachComponent)(form.components, function (component, path) {\n            if (component && component.defaultPermission) {\n              var value = (0, _get2.default)(submission.data, path); // make it work for single-select Group and multi-select Group\n\n              var groups = Array.isArray(value) ? value : [value];\n              groups.forEach(function (group) {\n                if (group && group._id && // group id is present\n                user.roles.indexOf(group._id) > -1 // user has group id in his roles\n                ) {\n                  if (component.defaultPermission === 'read') {\n                    perms[permMap.read] = true;\n                  }\n\n                  if (component.defaultPermission === 'create') {\n                    perms[permMap.create] = true;\n                    perms[permMap.read] = true;\n                  }\n\n                  if (component.defaultPermission === 'write') {\n                    perms[permMap.create] = true;\n                    perms[permMap.read] = true;\n                    perms[permMap.update] = true;\n                  }\n\n                  if (component.defaultPermission === 'admin') {\n                    perms[permMap.create] = true;\n                    perms[permMap.read] = true;\n                    perms[permMap.update] = true;\n                    perms[permMap.delete] = true;\n                  }\n                }\n              });\n            }\n          });\n        }\n\n        return perms;\n      });\n    }\n    /**\n     * Determine if the current user can submit a form.\n     * @return {*}\n     */\n\n  }, {\n    key: \"canSubmit\",\n    value: function canSubmit() {\n      var _this8 = this;\n\n      return this.userPermissions().then(function (perms) {\n        // If there is user and they cannot create, then check anonymous user permissions.\n        if (!perms.create && Formio.getUser()) {\n          return _this8.userPermissions(null).then(function (anonPerms) {\n            if (anonPerms.create) {\n              Formio.setUser(null);\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        return perms.create;\n      });\n    }\n  }, {\n    key: \"getUrlParts\",\n    value: function getUrlParts(url) {\n      return Formio.getUrlParts(url, this);\n    }\n  }], [{\n    key: \"loadProjects\",\n    value: function loadProjects(query, opts) {\n      query = query || '';\n\n      if (isObject(query)) {\n        query = \"?\".concat(Formio.serialize(query.params));\n      }\n\n      return Formio.makeStaticRequest(\"\".concat(Formio.baseUrl, \"/project\").concat(query), 'GET', null, opts);\n    }\n  }, {\n    key: \"getUrlParts\",\n    value: function getUrlParts(url, formio) {\n      var base = formio && formio.base ? formio.base : Formio.baseUrl;\n      var regex = '^(http[s]?:\\\\/\\\\/)';\n\n      if (base && url.indexOf(base) === 0) {\n        regex += \"(\".concat(base.replace(/^http[s]?:\\/\\//, ''), \")\");\n      } else {\n        regex += '([^/]+)';\n      }\n\n      regex += '($|\\\\/.*)';\n      return url.match(new RegExp(regex));\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(obj, _interpolate) {\n      var str = [];\n\n      var interpolate = function interpolate(item) {\n        return _interpolate ? _interpolate(item) : item;\n      };\n\n      for (var p in obj) {\n        if (obj.hasOwnProperty(p)) {\n          str.push(\"\".concat(encodeURIComponent(p), \"=\").concat(encodeURIComponent(interpolate(obj[p]))));\n        }\n      }\n\n      return str.join('&');\n    }\n  }, {\n    key: \"getRequestArgs\",\n    value: function getRequestArgs(formio, type, url, method, data, opts) {\n      method = (method || 'GET').toUpperCase();\n\n      if (!opts || !isObject(opts)) {\n        opts = {};\n      }\n\n      var requestArgs = {\n        url: url,\n        method: method,\n        data: data || null,\n        opts: opts\n      };\n\n      if (type) {\n        requestArgs.type = type;\n      }\n\n      if (formio) {\n        requestArgs.formio = formio;\n      }\n\n      return requestArgs;\n    }\n  }, {\n    key: \"makeStaticRequest\",\n    value: function makeStaticRequest(url, method, data, opts) {\n      var requestArgs = Formio.getRequestArgs(null, '', url, method, data, opts);\n      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {\n        return Formio.pluginGet('staticRequest', requestArgs).then(function (result) {\n          if (isNil(result)) {\n            return Formio.request(requestArgs.url, requestArgs.method, requestArgs.data, requestArgs.opts.header, requestArgs.opts);\n          }\n\n          return result;\n        });\n      });\n      return Formio.pluginAlter('wrapStaticRequestPromise', request, requestArgs);\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(formio, type, url, method, data, opts) {\n      if (!formio) {\n        return Formio.makeStaticRequest(url, method, data, opts);\n      }\n\n      var requestArgs = Formio.getRequestArgs(formio, type, url, method, data, opts);\n      requestArgs.opts = requestArgs.opts || {};\n      requestArgs.opts.formio = formio; //for Formio requests default Accept and Content-type headers\n\n      if (!requestArgs.opts.headers) {\n        requestArgs.opts.headers = {};\n      }\n\n      requestArgs.opts.headers = (0, _defaults2.default)(requestArgs.opts.headers, {\n        'Accept': 'application/json',\n        'Content-type': 'application/json'\n      });\n      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {\n        return Formio.pluginGet('request', requestArgs).then(function (result) {\n          if (isNil(result)) {\n            return Formio.request(requestArgs.url, requestArgs.method, requestArgs.data, requestArgs.opts.header, requestArgs.opts);\n          }\n\n          return result;\n        });\n      });\n      return Formio.pluginAlter('wrapRequestPromise', request, requestArgs);\n    }\n  }, {\n    key: \"request\",\n    value: function request(url, method, data, header, opts) {\n      if (!url) {\n        return _nativePromiseOnly.default.reject('No url provided');\n      }\n\n      var _Formio = Formio;\n      method = (method || 'GET').toUpperCase(); // For reverse compatibility, if they provided the ignoreCache parameter,\n      // then change it back to the options format where that is a parameter.\n\n      if (isBoolean(opts)) {\n        opts = {\n          ignoreCache: opts\n        };\n      }\n\n      if (!opts || !isObject(opts)) {\n        opts = {};\n      } // Generate a cachekey.\n\n\n      var cacheKey = btoa(encodeURI(url)); // Get the cached promise to save multiple loads.\n\n      if (!opts.ignoreCache && method === 'GET' && _Formio.cache.hasOwnProperty(cacheKey)) {\n        return _nativePromiseOnly.default.resolve(cloneResponse(_Formio.cache[cacheKey]));\n      } // Set up and fetch request\n\n\n      var headers = header || new Headers(opts.headers || {\n        'Accept': 'application/json',\n        'Content-type': 'application/json'\n      });\n\n      var token = _Formio.getToken(opts);\n\n      if (token && !opts.noToken) {\n        headers.append('x-jwt-token', token);\n      } // The fetch-ponyfill can't handle a proper Headers class anymore. Change it back to an object.\n\n\n      var headerObj = {};\n      headers.forEach(function (value, name) {\n        headerObj[name] = value;\n      });\n      var options = {\n        method: method,\n        headers: headerObj,\n        mode: 'cors'\n      };\n\n      if (data) {\n        options.body = JSON.stringify(data);\n      } // Allow plugins to alter the options.\n\n\n      options = _Formio.pluginAlter('requestOptions', options, url);\n\n      if (options.namespace || _Formio.namespace) {\n        opts.namespace = options.namespace || _Formio.namespace;\n      }\n\n      var requestToken = options.headers['x-jwt-token'];\n\n      var result = _Formio.pluginAlter('wrapFetchRequestPromise', _Formio.fetch(url, options), {\n        url: url,\n        method: method,\n        data: data,\n        opts: opts\n      }).then(function (response) {\n        // Allow plugins to respond.\n        response = _Formio.pluginAlter('requestResponse', response, _Formio, data);\n\n        if (!response.ok) {\n          if (response.status === 440) {\n            _Formio.setToken(null, opts);\n\n            _Formio.events.emit('formio.sessionExpired', response.body);\n          } else if (response.status === 401) {\n            _Formio.events.emit('formio.unauthorized', response.body);\n          } else if (response.status === 416) {\n            _Formio.events.emit('formio.rangeIsNotSatisfiable', response.body);\n          } else if (response.status === 504) {\n            return _nativePromiseOnly.default.reject(new Error('Network request failed'));\n          } // Parse and return the error as a rejected promise to reject this promise\n\n\n          return (response.headers.get('content-type').includes('application/json') ? response.json() : response.text()).then(function (error) {\n            return _nativePromiseOnly.default.reject(error);\n          });\n        } // Handle fetch results\n\n\n        var token = response.headers.get('x-jwt-token'); // In some strange cases, the fetch library will return an x-jwt-token without sending\n        // one to the server. This has even been debugged on the server to verify that no token\n        // was introduced with the request, but the response contains a token. This is an Invalid\n        // case where we do not send an x-jwt-token and get one in return for any GET request.\n\n        var tokenIntroduced = false;\n\n        if (method === 'GET' && !requestToken && token && !opts.external && !url.includes('token=') && !url.includes('x-jwt-token=')) {\n          console.warn('Token was introduced in request.');\n          tokenIntroduced = true;\n        }\n\n        if (response.status >= 200 && response.status < 300 && token && token !== '' && !tokenIntroduced) {\n          _Formio.setToken(token, opts);\n        } // 204 is no content. Don't try to .json() it.\n\n\n        if (response.status === 204) {\n          return {};\n        }\n\n        var getResult = response.headers.get('content-type').includes('application/json') ? response.json() : response.text();\n        return getResult.then(function (result) {\n          // Add some content-range metadata to the result here\n          var range = response.headers.get('content-range');\n\n          if (range && isObject(result)) {\n            range = range.split('/');\n\n            if (range[0] !== '*') {\n              var skipLimit = range[0].split('-');\n              result.skip = Number(skipLimit[0]);\n              result.limit = skipLimit[1] - skipLimit[0] + 1;\n            }\n\n            result.serverCount = range[1] === '*' ? range[1] : Number(range[1]);\n          }\n\n          if (!opts.getHeaders) {\n            return result;\n          }\n\n          var headers = {};\n          response.headers.forEach(function (item, key) {\n            headers[key] = item;\n          }); // Return the result with the headers.\n\n          return {\n            result: result,\n            headers: headers\n          };\n        });\n      }).then(function (result) {\n        if (opts.getHeaders) {\n          return result;\n        } // Cache the response.\n\n\n        if (method === 'GET') {\n          _Formio.cache[cacheKey] = result;\n        }\n\n        return cloneResponse(result);\n      }).catch(function (err) {\n        if (err === 'Bad Token') {\n          _Formio.setToken(null, opts);\n\n          _Formio.events.emit('formio.badToken', err);\n        }\n\n        if (err.message) {\n          err = new Error(\"Could not connect to API server (\".concat(err.message, \"): \").concat(url));\n          err.networkError = true;\n        }\n\n        if (method === 'GET') {\n          delete _Formio.cache[cacheKey];\n        }\n\n        return _nativePromiseOnly.default.reject(err);\n      });\n\n      return result;\n    } // Needed to maintain reverse compatability...\n\n  }, {\n    key: \"token\",\n    get: function get() {\n      if (!Formio.tokens) {\n        Formio.tokens = {};\n      }\n\n      return Formio.tokens.formioToken || '';\n    } // Needed to maintain reverse compatability...\n    ,\n    set: function set(token) {\n      if (!Formio.tokens) {\n        Formio.tokens = {};\n      }\n\n      Formio.tokens.formioToken = token || '';\n    }\n  }, {\n    key: \"setToken\",\n    value: function setToken() {\n      var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var opts = arguments.length > 1 ? arguments[1] : undefined;\n      token = token || '';\n      opts = typeof opts === 'string' ? {\n        namespace: opts\n      } : opts || {};\n      var tokenName = \"\".concat(opts.namespace || Formio.namespace || 'formio', \"Token\");\n\n      if (!Formio.tokens) {\n        Formio.tokens = {};\n      }\n\n      if (!token) {\n        if (!opts.fromUser) {\n          opts.fromToken = true;\n          Formio.setUser(null, opts);\n        } // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.\n\n\n        try {\n          localStorage.removeItem(tokenName);\n        } catch (err) {\n          _browserCookies.default.erase(tokenName, {\n            path: '/'\n          });\n        }\n\n        Formio.tokens[tokenName] = token;\n        return _nativePromiseOnly.default.resolve(null);\n      }\n\n      if (Formio.tokens[tokenName] !== token) {\n        Formio.tokens[tokenName] = token; // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.\n\n        try {\n          localStorage.setItem(tokenName, token);\n        } catch (err) {\n          _browserCookies.default.set(tokenName, token, {\n            path: '/'\n          });\n        }\n      } // Return or updates the current user\n\n\n      return this.currentUserResolved ? Formio.currentUser(opts.formio, opts) : _nativePromiseOnly.default.resolve(null);\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken(options) {\n      options = typeof options === 'string' ? {\n        namespace: options\n      } : options || {};\n      var tokenName = \"\".concat(options.namespace || Formio.namespace || 'formio', \"Token\");\n      var decodedTokenName = options.decode ? \"\".concat(tokenName, \"Decoded\") : tokenName;\n\n      if (!Formio.tokens) {\n        Formio.tokens = {};\n      }\n\n      if (Formio.tokens[decodedTokenName]) {\n        return Formio.tokens[decodedTokenName];\n      }\n\n      try {\n        Formio.tokens[tokenName] = localStorage.getItem(tokenName) || '';\n\n        if (options.decode) {\n          Formio.tokens[decodedTokenName] = Formio.tokens[tokenName] ? (0, _jwtDecode.default)(Formio.tokens[tokenName]) : {};\n          return Formio.tokens[decodedTokenName];\n        }\n\n        return Formio.tokens[tokenName];\n      } catch (e) {\n        Formio.tokens[tokenName] = _browserCookies.default.get(tokenName);\n        return Formio.tokens[tokenName];\n      }\n    }\n  }, {\n    key: \"setUser\",\n    value: function setUser(user) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var userName = \"\".concat(opts.namespace || Formio.namespace || 'formio', \"User\");\n\n      if (!user) {\n        if (!opts.fromToken) {\n          opts.fromUser = true;\n          Formio.setToken(null, opts);\n        } // Emit an event on the cleared user.\n\n\n        Formio.events.emit('formio.user', null); // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.\n\n        try {\n          return localStorage.removeItem(userName);\n        } catch (err) {\n          return _browserCookies.default.erase(userName, {\n            path: '/'\n          });\n        }\n      } // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.\n\n\n      try {\n        localStorage.setItem(userName, JSON.stringify(user));\n      } catch (err) {\n        _browserCookies.default.set(userName, JSON.stringify(user), {\n          path: '/'\n        });\n      } // Emit an event on the authenticated user.\n\n\n      Formio.events.emit('formio.user', user);\n    }\n  }, {\n    key: \"getUser\",\n    value: function getUser(options) {\n      options = options || {};\n      var userName = \"\".concat(options.namespace || Formio.namespace || 'formio', \"User\");\n\n      try {\n        return JSON.parse(localStorage.getItem(userName) || null);\n      } catch (e) {\n        return JSON.parse(_browserCookies.default.get(userName));\n      }\n    }\n  }, {\n    key: \"setBaseUrl\",\n    value: function setBaseUrl(url) {\n      Formio.baseUrl = url;\n\n      if (!Formio.projectUrlSet) {\n        Formio.projectUrl = url;\n      }\n    }\n  }, {\n    key: \"getBaseUrl\",\n    value: function getBaseUrl() {\n      return Formio.baseUrl;\n    }\n  }, {\n    key: \"setApiUrl\",\n    value: function setApiUrl(url) {\n      return Formio.setBaseUrl(url);\n    }\n  }, {\n    key: \"getApiUrl\",\n    value: function getApiUrl() {\n      return Formio.getBaseUrl();\n    }\n  }, {\n    key: \"setAppUrl\",\n    value: function setAppUrl(url) {\n      console.warn('Formio.setAppUrl() is deprecated. Use Formio.setProjectUrl instead.');\n      Formio.projectUrl = url;\n      Formio.projectUrlSet = true;\n    }\n  }, {\n    key: \"setProjectUrl\",\n    value: function setProjectUrl(url) {\n      Formio.projectUrl = url;\n      Formio.projectUrlSet = true;\n    }\n  }, {\n    key: \"setAuthUrl\",\n    value: function setAuthUrl(url) {\n      Formio.authUrl = url;\n    }\n  }, {\n    key: \"getAppUrl\",\n    value: function getAppUrl() {\n      console.warn('Formio.getAppUrl() is deprecated. Use Formio.getProjectUrl instead.');\n      return Formio.projectUrl;\n    }\n  }, {\n    key: \"getProjectUrl\",\n    value: function getProjectUrl() {\n      return Formio.projectUrl;\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      Formio.cache = {};\n    }\n  }, {\n    key: \"noop\",\n    value: function noop() {}\n  }, {\n    key: \"identity\",\n    value: function identity(value) {\n      return value;\n    }\n  }, {\n    key: \"deregisterPlugin\",\n    value: function deregisterPlugin(plugin) {\n      var beforeLength = Formio.plugins.length;\n      Formio.plugins = Formio.plugins.filter(function (p) {\n        if (p !== plugin && p.__name !== plugin) {\n          return true;\n        }\n\n        (p.deregister || Formio.noop).call(plugin, Formio);\n        return false;\n      });\n      return beforeLength !== Formio.plugins.length;\n    }\n  }, {\n    key: \"registerPlugin\",\n    value: function registerPlugin(plugin, name) {\n      var __Formio = Formio;\n\n      __Formio.plugins.push(plugin);\n\n      __Formio.plugins.sort(function (a, b) {\n        return (b.priority || 0) - (a.priority || 0);\n      });\n\n      plugin.__name = name;\n\n      (plugin.init || __Formio.noop).call(plugin, __Formio);\n    }\n  }, {\n    key: \"getPlugin\",\n    value: function getPlugin(name) {\n      var _iterator = _createForOfIteratorHelper(Formio.plugins),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var plugin = _step.value;\n\n          if (plugin.__name === name) {\n            return plugin;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"pluginWait\",\n    value: function pluginWait(pluginFn) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return _nativePromiseOnly.default.all(Formio.plugins.map(function (plugin) {\n        var _ref;\n\n        return (_ref = plugin[pluginFn] || Formio.noop).call.apply(_ref, [plugin].concat(args));\n      }));\n    }\n  }, {\n    key: \"pluginGet\",\n    value: function pluginGet(pluginFn) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var callPlugin = function callPlugin(index) {\n        var _ref2;\n\n        var plugin = Formio.plugins[index];\n\n        if (!plugin) {\n          return _nativePromiseOnly.default.resolve(null);\n        }\n\n        return _nativePromiseOnly.default.resolve((_ref2 = plugin[pluginFn] || Formio.noop).call.apply(_ref2, [plugin].concat(args))).then(function (result) {\n          if (!isNil(result)) {\n            return result;\n          }\n\n          return callPlugin(index + 1);\n        });\n      };\n\n      return callPlugin(0);\n    }\n  }, {\n    key: \"pluginAlter\",\n    value: function pluginAlter(pluginFn, value) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n\n      return Formio.plugins.reduce(function (value, plugin) {\n        return (plugin[pluginFn] || Formio.identity).apply(void 0, [value].concat(args));\n      }, value);\n    }\n  }, {\n    key: \"accessInfo\",\n    value: function accessInfo(formio) {\n      var projectUrl = formio ? formio.projectUrl : Formio.projectUrl;\n      return Formio.makeRequest(formio, 'accessInfo', \"\".concat(projectUrl, \"/access\"));\n    }\n  }, {\n    key: \"projectRoles\",\n    value: function projectRoles(formio) {\n      var projectUrl = formio ? formio.projectUrl : Formio.projectUrl;\n      return Formio.makeRequest(formio, 'projectRoles', \"\".concat(projectUrl, \"/role\"));\n    }\n  }, {\n    key: \"currentUser\",\n    value: function currentUser(formio, options) {\n      var _this9 = this;\n\n      var authUrl = Formio.authUrl;\n\n      if (!authUrl) {\n        authUrl = formio ? formio.projectUrl : Formio.projectUrl || Formio.baseUrl;\n      }\n\n      authUrl += '/current';\n      var user = Formio.getUser(options);\n\n      if (user) {\n        return Formio.pluginAlter('wrapStaticRequestPromise', _nativePromiseOnly.default.resolve(user), {\n          url: authUrl,\n          method: 'GET',\n          options: options\n        });\n      }\n\n      var token = Formio.getToken(options);\n\n      if ((!options || !options.external) && !token) {\n        return Formio.pluginAlter('wrapStaticRequestPromise', _nativePromiseOnly.default.resolve(null), {\n          url: authUrl,\n          method: 'GET',\n          options: options\n        });\n      }\n\n      this.currentUserResolved = false;\n      return Formio.makeRequest(formio, 'currentUser', authUrl, 'GET', null, options).then(function (response) {\n        _this9.currentUserResolved = true;\n        Formio.setUser(response, options);\n        return response;\n      });\n    }\n  }, {\n    key: \"logout\",\n    value: function logout(formio, options) {\n      options = options || {};\n      options.formio = formio;\n      var projectUrl = Formio.authUrl ? Formio.authUrl : formio ? formio.projectUrl : Formio.baseUrl;\n      return Formio.makeRequest(formio, 'logout', \"\".concat(projectUrl, \"/logout\")).then(function (result) {\n        Formio.setToken(null, options);\n        Formio.setUser(null, options);\n        Formio.clearCache();\n        return result;\n      }).catch(function (err) {\n        Formio.setToken(null, options);\n        Formio.setUser(null, options);\n        Formio.clearCache();\n        throw err;\n      });\n    }\n  }, {\n    key: \"pageQuery\",\n    value: function pageQuery() {\n      var pageQuery = {};\n      pageQuery.paths = [];\n      var hashes = location.hash.substr(1).replace(/\\?/g, '&').split('&');\n      var parts = [];\n      location.search.substr(1).split('&').forEach(function (item) {\n        parts = item.split('=');\n\n        if (parts.length > 1) {\n          pageQuery[parts[0]] = parts[1] && decodeURIComponent(parts[1]);\n        }\n      });\n      hashes.forEach(function (item) {\n        parts = item.split('=');\n\n        if (parts.length > 1) {\n          pageQuery[parts[0]] = parts[1] && decodeURIComponent(parts[1]);\n        } else if (item.indexOf('/') === 0) {\n          pageQuery.paths = item.substr(1).split('/');\n        }\n      });\n      return pageQuery;\n    }\n  }, {\n    key: \"oAuthCurrentUser\",\n    value: function oAuthCurrentUser(formio, token) {\n      return Formio.currentUser(formio, {\n        external: true,\n        headers: {\n          Authorization: \"Bearer \".concat(token)\n        }\n      });\n    }\n  }, {\n    key: \"samlInit\",\n    value: function samlInit(options) {\n      options = options || {};\n      var query = Formio.pageQuery();\n\n      if (query.saml) {\n        Formio.setUser(null);\n        var retVal = Formio.setToken(query.saml);\n        var uri = window.location.toString();\n        uri = uri.substring(0, uri.indexOf('?'));\n\n        if (window.location.hash) {\n          uri += window.location.hash;\n        }\n\n        window.history.replaceState({}, document.title, uri);\n        return retVal;\n      } // Set the relay if not provided.\n\n\n      if (!options.relay) {\n        options.relay = window.location.href;\n      } // go to the saml sso endpoint for this project.\n\n\n      var authUrl = Formio.authUrl || Formio.projectUrl;\n      window.location.href = \"\".concat(authUrl, \"/saml/sso?relay=\").concat(encodeURI(options.relay));\n      return false;\n    }\n  }, {\n    key: \"oktaInit\",\n    value: function oktaInit(options) {\n      options = options || {};\n\n      if ((typeof OktaAuth === \"undefined\" ? \"undefined\" : _typeof(OktaAuth)) !== undefined) {\n        options.OktaAuth = OktaAuth;\n      }\n\n      if (_typeof(options.OktaAuth) === undefined) {\n        var errorMessage = 'Cannot find OktaAuth. Please include the Okta JavaScript SDK within your application. See https://developer.okta.com/code/javascript/okta_auth_sdk for an example.';\n        console.warn(errorMessage);\n        return _nativePromiseOnly.default.reject(errorMessage);\n      }\n\n      return new _nativePromiseOnly.default(function (resolve, reject) {\n        var Okta = options.OktaAuth;\n        delete options.OktaAuth;\n        var authClient = new Okta(options);\n        authClient.tokenManager.get('accessToken').then(function (accessToken) {\n          if (accessToken) {\n            resolve(Formio.oAuthCurrentUser(options.formio, accessToken.accessToken));\n          } else if (location.hash) {\n            authClient.token.parseFromUrl().then(function (token) {\n              authClient.tokenManager.add('accessToken', token);\n              resolve(Formio.oAuthCurrentUser(options.formio, token.accessToken));\n            }).catch(function (err) {\n              console.warn(err);\n              reject(err);\n            });\n          } else {\n            authClient.token.getWithRedirect({\n              responseType: 'token',\n              scopes: options.scopes\n            });\n            resolve(false);\n          }\n        }).catch(function (error) {\n          reject(error);\n        });\n      });\n    }\n  }, {\n    key: \"ssoInit\",\n    value: function ssoInit(type, options) {\n      switch (type) {\n        case 'saml':\n          return Formio.samlInit(options);\n\n        case 'okta':\n          return Formio.oktaInit(options);\n\n        default:\n          console.warn('Unknown SSO type');\n          return _nativePromiseOnly.default.reject('Unknown SSO type');\n      }\n    }\n  }, {\n    key: \"requireLibrary\",\n    value: function requireLibrary(name, property, src, polling, onload) {\n      if (!Formio.libraries.hasOwnProperty(name)) {\n        Formio.libraries[name] = {};\n        Formio.libraries[name].ready = new _nativePromiseOnly.default(function (resolve, reject) {\n          Formio.libraries[name].resolve = resolve;\n          Formio.libraries[name].reject = reject;\n        });\n        var callbackName = \"\".concat(name, \"Callback\");\n\n        if (!polling && !window[callbackName]) {\n          window[callbackName] = function () {\n            return Formio.libraries[name].resolve();\n          };\n        } // See if the plugin already exists.\n\n\n        var plugin = (0, _get2.default)(window, property);\n\n        if (plugin) {\n          Formio.libraries[name].resolve(plugin);\n        } else {\n          src = Array.isArray(src) ? src : [src];\n          src.forEach(function (lib) {\n            var attrs = {};\n            var elementType = '';\n\n            if (typeof lib === 'string') {\n              lib = {\n                type: 'script',\n                src: lib\n              };\n            }\n\n            switch (lib.type) {\n              case 'script':\n                elementType = 'script';\n                attrs = {\n                  src: lib.src,\n                  type: 'text/javascript',\n                  defer: true,\n                  async: true,\n                  referrerpolicy: 'origin'\n                };\n                break;\n\n              case 'styles':\n                elementType = 'link';\n                attrs = {\n                  href: lib.src,\n                  rel: 'stylesheet'\n                };\n                break;\n            } // Add the script to the top of the page.\n\n\n            var element = document.createElement(elementType);\n\n            if (element.setAttribute) {\n              for (var attr in attrs) {\n                element.setAttribute(attr, attrs[attr]);\n              }\n            }\n\n            if (onload) {\n              element.addEventListener('load', function () {\n                return onload(Formio.libraries[name].ready);\n              });\n            }\n\n            var _document = document,\n                head = _document.head;\n\n            if (head) {\n              head.appendChild(element);\n            }\n          }); // if no callback is provided, then check periodically for the script.\n\n          if (polling) {\n            var interval = setInterval(function () {\n              var plugin = (0, _get2.default)(window, property);\n\n              if (plugin) {\n                clearInterval(interval);\n                Formio.libraries[name].resolve(plugin);\n              }\n            }, 200);\n          }\n        }\n      }\n\n      var lib = Formio.libraries[name].ready;\n      return onload ? onload(lib) : lib;\n    }\n  }, {\n    key: \"libraryReady\",\n    value: function libraryReady(name) {\n      if (Formio.libraries.hasOwnProperty(name) && Formio.libraries[name].ready) {\n        return Formio.libraries[name].ready;\n      }\n\n      return _nativePromiseOnly.default.reject(\"\".concat(name, \" library was not required.\"));\n    }\n  }, {\n    key: \"addToGlobal\",\n    value: function addToGlobal(global) {\n      if (_typeof(global) === 'object' && !global.Formio) {\n        global.Formio = Formio;\n      }\n    }\n  }, {\n    key: \"setPathType\",\n    value: function setPathType(type) {\n      if (typeof type === 'string') {\n        Formio.pathType = type;\n      }\n    }\n  }, {\n    key: \"getPathType\",\n    value: function getPathType() {\n      return Formio.pathType;\n    }\n  }, {\n    key: \"rulesEntities\",\n    get: function get() {\n      return {\n        ValueSources: Formio.ValueSources,\n        Conjunctions: Formio.Conjunctions,\n        Operators: Formio.Operators,\n        Transformers: Formio.Transformers,\n        QuickRules: Formio.QuickRules,\n        Rules: Formio.Rules\n      };\n    }\n  }, {\n    key: \"GlobalFormio\",\n    get: function get() {\n      if (typeof global !== 'undefined' && global.Formio) {\n        return global.Formio;\n      } else if (typeof window !== 'undefined' && window.Formio) {\n        return window.Formio;\n      }\n\n      return Formio;\n    }\n  }]);\n\n  return Formio;\n}(); // Define all the static properties.\n\n\n_defineProperty(Formio, \"currentUserResolved\", true);\n\nFormio.libraries = {};\nFormio.Promise = _nativePromiseOnly.default;\nFormio.fetch = fetch;\nFormio.Headers = Headers;\nFormio.baseUrl = 'https://api.form.io';\nFormio.projectUrl = Formio.baseUrl;\nFormio.authUrl = '';\nFormio.projectUrlSet = false;\nFormio.plugins = [];\nFormio.cache = {};\nFormio.Providers = _providers.default;\nFormio.version = '4.14.8';\nFormio.pathType = '';\nFormio.events = new _EventEmitter.default();\n\nif (typeof global !== 'undefined') {\n  Formio.addToGlobal(global);\n}\n\nif (typeof window !== 'undefined') {\n  Formio.addToGlobal(window);\n}\n\nvar GlobalFormio = Formio.GlobalFormio;\nexports.GlobalFormio = GlobalFormio;\nvar _default = Formio;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}