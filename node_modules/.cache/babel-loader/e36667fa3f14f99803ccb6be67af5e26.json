{"ast":null,"code":"var _classCallCheck = require(\"D:\\\\banbufuto\\\\symbioo\\\\_LocalResearch\\\\react-form-builder\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\banbufuto\\\\symbioo\\\\_LocalResearch\\\\react-form-builder\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.browserMD5File = factory();\n})(this, function () {\n  'use strict';\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var sparkMd5 = createCommonjsModule(function (module, exports) {\n    (function (factory) {\n      {\n        // Node/CommonJS\n        module.exports = factory();\n      }\n    })(function (undefined) {\n      /*\n       * Fastest md5 implementation around (JKM md5).\n       * Credits: Joseph Myers\n       *\n       * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n       * @see http://jsperf.com/md5-shootout/7\n       */\n\n      /* this function is much faster,\n        so if possible we use it. Some IEs\n        are the only ones I know of that\n        need the idiotic second function,\n        generated by an if clause.  */\n      var add32 = function add32(a, b) {\n        return a + b & 0xFFFFFFFF;\n      },\n          hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n      function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32(a << s | a >>> 32 - s, b);\n      }\n\n      function ff(a, b, c, d, x, s, t) {\n        return cmn(b & c | ~b & d, a, b, x, s, t);\n      }\n\n      function gg(a, b, c, d, x, s, t) {\n        return cmn(b & d | c & ~d, a, b, x, s, t);\n      }\n\n      function hh(a, b, c, d, x, s, t) {\n        return cmn(b ^ c ^ d, a, b, x, s, t);\n      }\n\n      function ii(a, b, c, d, x, s, t) {\n        return cmn(c ^ (b | ~d), a, b, x, s, t);\n      }\n\n      function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n        a = ff(a, b, c, d, k[0], 7, -680876936);\n        d = ff(d, a, b, c, k[1], 12, -389564586);\n        c = ff(c, d, a, b, k[2], 17, 606105819);\n        b = ff(b, c, d, a, k[3], 22, -1044525330);\n        a = ff(a, b, c, d, k[4], 7, -176418897);\n        d = ff(d, a, b, c, k[5], 12, 1200080426);\n        c = ff(c, d, a, b, k[6], 17, -1473231341);\n        b = ff(b, c, d, a, k[7], 22, -45705983);\n        a = ff(a, b, c, d, k[8], 7, 1770035416);\n        d = ff(d, a, b, c, k[9], 12, -1958414417);\n        c = ff(c, d, a, b, k[10], 17, -42063);\n        b = ff(b, c, d, a, k[11], 22, -1990404162);\n        a = ff(a, b, c, d, k[12], 7, 1804603682);\n        d = ff(d, a, b, c, k[13], 12, -40341101);\n        c = ff(c, d, a, b, k[14], 17, -1502002290);\n        b = ff(b, c, d, a, k[15], 22, 1236535329);\n        a = gg(a, b, c, d, k[1], 5, -165796510);\n        d = gg(d, a, b, c, k[6], 9, -1069501632);\n        c = gg(c, d, a, b, k[11], 14, 643717713);\n        b = gg(b, c, d, a, k[0], 20, -373897302);\n        a = gg(a, b, c, d, k[5], 5, -701558691);\n        d = gg(d, a, b, c, k[10], 9, 38016083);\n        c = gg(c, d, a, b, k[15], 14, -660478335);\n        b = gg(b, c, d, a, k[4], 20, -405537848);\n        a = gg(a, b, c, d, k[9], 5, 568446438);\n        d = gg(d, a, b, c, k[14], 9, -1019803690);\n        c = gg(c, d, a, b, k[3], 14, -187363961);\n        b = gg(b, c, d, a, k[8], 20, 1163531501);\n        a = gg(a, b, c, d, k[13], 5, -1444681467);\n        d = gg(d, a, b, c, k[2], 9, -51403784);\n        c = gg(c, d, a, b, k[7], 14, 1735328473);\n        b = gg(b, c, d, a, k[12], 20, -1926607734);\n        a = hh(a, b, c, d, k[5], 4, -378558);\n        d = hh(d, a, b, c, k[8], 11, -2022574463);\n        c = hh(c, d, a, b, k[11], 16, 1839030562);\n        b = hh(b, c, d, a, k[14], 23, -35309556);\n        a = hh(a, b, c, d, k[1], 4, -1530992060);\n        d = hh(d, a, b, c, k[4], 11, 1272893353);\n        c = hh(c, d, a, b, k[7], 16, -155497632);\n        b = hh(b, c, d, a, k[10], 23, -1094730640);\n        a = hh(a, b, c, d, k[13], 4, 681279174);\n        d = hh(d, a, b, c, k[0], 11, -358537222);\n        c = hh(c, d, a, b, k[3], 16, -722521979);\n        b = hh(b, c, d, a, k[6], 23, 76029189);\n        a = hh(a, b, c, d, k[9], 4, -640364487);\n        d = hh(d, a, b, c, k[12], 11, -421815835);\n        c = hh(c, d, a, b, k[15], 16, 530742520);\n        b = hh(b, c, d, a, k[2], 23, -995338651);\n        a = ii(a, b, c, d, k[0], 6, -198630844);\n        d = ii(d, a, b, c, k[7], 10, 1126891415);\n        c = ii(c, d, a, b, k[14], 15, -1416354905);\n        b = ii(b, c, d, a, k[5], 21, -57434055);\n        a = ii(a, b, c, d, k[12], 6, 1700485571);\n        d = ii(d, a, b, c, k[3], 10, -1894986606);\n        c = ii(c, d, a, b, k[10], 15, -1051523);\n        b = ii(b, c, d, a, k[1], 21, -2054922799);\n        a = ii(a, b, c, d, k[8], 6, 1873313359);\n        d = ii(d, a, b, c, k[15], 10, -30611744);\n        c = ii(c, d, a, b, k[6], 15, -1560198380);\n        b = ii(b, c, d, a, k[13], 21, 1309151649);\n        a = ii(a, b, c, d, k[4], 6, -145523070);\n        d = ii(d, a, b, c, k[11], 10, -1120210379);\n        c = ii(c, d, a, b, k[2], 15, 718787259);\n        b = ii(b, c, d, a, k[9], 21, -343485551);\n        x[0] = add32(a, x[0]);\n        x[1] = add32(b, x[1]);\n        x[2] = add32(c, x[2]);\n        x[3] = add32(d, x[3]);\n      }\n\n      function md5blk(s) {\n        var md5blks = [],\n            i;\n        /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n          md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n\n        return md5blks;\n      }\n\n      function md5blk_array(a) {\n        var md5blks = [],\n            i;\n        /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n          md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n\n        return md5blks;\n      }\n\n      function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n          md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n        for (i = 0; i < length; i += 1) {\n          tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n\n        if (i > 55) {\n          md5cycle(state, tail);\n\n          for (i = 0; i < 16; i += 1) {\n            tail[i] = 0;\n          }\n        } // Beware that the final length might not fit in 32 bits so we take care of that\n\n\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(state, tail);\n        return state;\n      }\n\n      function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n          md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        } // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\n\n        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n        for (i = 0; i < length; i += 1) {\n          tail[i >> 2] |= a[i] << (i % 4 << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n\n        if (i > 55) {\n          md5cycle(state, tail);\n\n          for (i = 0; i < 16; i += 1) {\n            tail[i] = 0;\n          }\n        } // Beware that the final length might not fit in 32 bits so we take care of that\n\n\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(state, tail);\n        return state;\n      }\n\n      function rhex(n) {\n        var s = '',\n            j;\n\n        for (j = 0; j < 4; j += 1) {\n          s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];\n        }\n\n        return s;\n      }\n\n      function hex(x) {\n        var i;\n\n        for (i = 0; i < x.length; i += 1) {\n          x[i] = rhex(x[i]);\n        }\n\n        return x.join('');\n      } // In some cases the fast add32 function cannot be used..\n\n\n      if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function add32(x, y) {\n          var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n              msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n          return msw << 16 | lsw & 0xFFFF;\n        };\n      } // ---------------------------------------------------\n\n      /**\n       * ArrayBuffer slice polyfill.\n       *\n       * @see https://github.com/ttaubert/node-arraybuffer-slice\n       */\n\n\n      if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n          function clamp(val, length) {\n            val = val | 0 || 0;\n\n            if (val < 0) {\n              return Math.max(val + length, 0);\n            }\n\n            return Math.min(val, length);\n          }\n\n          ArrayBuffer.prototype.slice = function (from, to) {\n            var length = this.byteLength,\n                begin = clamp(from, length),\n                end = length,\n                num,\n                target,\n                targetArray,\n                sourceArray;\n\n            if (to !== undefined) {\n              end = clamp(to, length);\n            }\n\n            if (begin > end) {\n              return new ArrayBuffer(0);\n            }\n\n            num = end - begin;\n            target = new ArrayBuffer(num);\n            targetArray = new Uint8Array(target);\n            sourceArray = new Uint8Array(this, begin, num);\n            targetArray.set(sourceArray);\n            return target;\n          };\n        })();\n      } // ---------------------------------------------------\n\n      /**\n       * Helpers.\n       */\n\n\n      function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n          str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n      }\n\n      function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n            buff = new ArrayBuffer(length),\n            arr = new Uint8Array(buff),\n            i;\n\n        for (i = 0; i < length; i += 1) {\n          arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n      }\n\n      function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n      }\n\n      function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n        return returnUInt8Array ? result : result.buffer;\n      }\n\n      function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n          bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n      } // ---------------------------------------------------\n\n      /**\n       * SparkMD5 OOP implementation.\n       *\n       * Use this class to perform an incremental md5, otherwise use the\n       * static methods instead.\n       */\n\n\n      function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n      }\n      /**\n       * Appends a string.\n       * A conversion will be applied if an utf8 string is detected.\n       *\n       * @param {String} str The string to be appended\n       *\n       * @return {SparkMD5} The instance itself\n       */\n\n\n      SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n        return this;\n      };\n      /**\n       * Appends a binary string.\n       *\n       * @param {String} contents The binary string to be appended\n       *\n       * @return {SparkMD5} The instance itself\n       */\n\n\n      SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n          md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n        return this;\n      };\n      /**\n       * Finishes the incremental computation, reseting the internal state and\n       * returning the result.\n       *\n       * @param {Boolean} raw True to get the raw string, false to get the hex string\n       *\n       * @return {String} The result\n       */\n\n\n      SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n          tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);\n        }\n\n        this._finish(tail, length);\n\n        ret = hex(this._hash);\n\n        if (raw) {\n          ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n        return ret;\n      };\n      /**\n       * Resets the internal state of the computation.\n       *\n       * @return {SparkMD5} The instance itself\n       */\n\n\n      SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n        return this;\n      };\n      /**\n       * Gets the internal state of the computation.\n       *\n       * @return {Object} The state\n       */\n\n\n      SparkMD5.prototype.getState = function () {\n        return {\n          buff: this._buff,\n          length: this._length,\n          hash: this._hash\n        };\n      };\n      /**\n       * Gets the internal state of the computation.\n       *\n       * @param {Object} state The state\n       *\n       * @return {SparkMD5} The instance itself\n       */\n\n\n      SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n        return this;\n      };\n      /**\n       * Releases memory used by the incremental buffer and other additional\n       * resources. If you plan to use the instance again, use reset instead.\n       */\n\n\n      SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n      };\n      /**\n       * Finish the final calculation based on the tail.\n       *\n       * @param {Array}  tail   The tail (will be modified)\n       * @param {Number} length The length of the remaining buffer\n       */\n\n\n      SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n\n        if (i > 55) {\n          md5cycle(this._hash, tail);\n\n          for (i = 0; i < 16; i += 1) {\n            tail[i] = 0;\n          }\n        } // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n\n\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n      };\n      /**\n       * Performs the md5 hash on a string.\n       * A conversion will be applied if utf8 string is detected.\n       *\n       * @param {String}  str The string\n       * @param {Boolean} raw True to get the raw string, false to get the hex string\n       *\n       * @return {String} The result\n       */\n\n\n      SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n      };\n      /**\n       * Performs the md5 hash on a binary string.\n       *\n       * @param {String}  content The binary string\n       * @param {Boolean} raw     True to get the raw string, false to get the hex string\n       *\n       * @return {String} The result\n       */\n\n\n      SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n        return raw ? hexToBinaryString(ret) : ret;\n      }; // ---------------------------------------------------\n\n      /**\n       * SparkMD5 OOP implementation for array buffers.\n       *\n       * Use this class to perform an incremental md5 ONLY for array buffers.\n       */\n\n\n      SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n      };\n      /**\n       * Appends an array buffer.\n       *\n       * @param {ArrayBuffer} arr The array to be appended\n       *\n       * @return {SparkMD5.ArrayBuffer} The instance itself\n       */\n\n\n      SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n          md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n        return this;\n      };\n      /**\n       * Finishes the incremental computation, reseting the internal state and\n       * returning the result.\n       *\n       * @param {Boolean} raw True to get the raw string, false to get the hex string\n       *\n       * @return {String} The result\n       */\n\n\n      SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n          tail[i >> 2] |= buff[i] << (i % 4 << 3);\n        }\n\n        this._finish(tail, length);\n\n        ret = hex(this._hash);\n\n        if (raw) {\n          ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n        return ret;\n      };\n      /**\n       * Resets the internal state of the computation.\n       *\n       * @return {SparkMD5.ArrayBuffer} The instance itself\n       */\n\n\n      SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n        return this;\n      };\n      /**\n       * Gets the internal state of the computation.\n       *\n       * @return {Object} The state\n       */\n\n\n      SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this); // Convert buffer to a string\n\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n        return state;\n      };\n      /**\n       * Gets the internal state of the computation.\n       *\n       * @param {Object} state The state\n       *\n       * @return {SparkMD5.ArrayBuffer} The instance itself\n       */\n\n\n      SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n        return SparkMD5.prototype.setState.call(this, state);\n      };\n\n      SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n      SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n      /**\n       * Performs the md5 hash on an array buffer.\n       *\n       * @param {ArrayBuffer} arr The array buffer\n       * @param {Boolean}     raw True to get the raw string, false to get the hex one\n       *\n       * @return {String} The result\n       */\n\n      SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n        return raw ? hexToBinaryString(ret) : ret;\n      };\n\n      return SparkMD5;\n    });\n  });\n\n  var BMF = /*#__PURE__*/function () {\n    function BMF() {\n      _classCallCheck(this, BMF);\n    }\n\n    _createClass(BMF, [{\n      key: \"md5\",\n      value: function md5(file, md5Fn, progressFn) {\n        var _this = this;\n\n        this.aborted = false;\n        this.progress = 0;\n        var currentChunk = 0;\n        var blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;\n        var chunkSize = 2097152;\n        var chunks = Math.ceil(file.size / chunkSize);\n        var spark = new sparkMd5.ArrayBuffer();\n        var reader = new FileReader();\n        loadNext();\n\n        reader.onloadend = function (e) {\n          spark.append(e.target.result); // Append array buffer\n\n          currentChunk++;\n          _this.progress = currentChunk / chunks;\n\n          if (progressFn && typeof progressFn === 'function') {\n            progressFn(_this.progress);\n          }\n\n          if (_this.aborted) {\n            md5Fn('aborted');\n            return;\n          }\n\n          if (currentChunk < chunks) {\n            loadNext();\n          } else {\n            md5Fn(null, spark.end());\n          }\n        }; /////////////////////////\n\n\n        function loadNext() {\n          var start = currentChunk * chunkSize;\n          var end = start + chunkSize >= file.size ? file.size : start + chunkSize;\n          reader.readAsArrayBuffer(blobSlice.call(file, start, end));\n        }\n      }\n    }, {\n      key: \"abort\",\n      value: function abort() {\n        this.aborted = true;\n      }\n    }]);\n\n    return BMF;\n  }();\n\n  return BMF;\n});","map":null,"metadata":{},"sourceType":"script"}