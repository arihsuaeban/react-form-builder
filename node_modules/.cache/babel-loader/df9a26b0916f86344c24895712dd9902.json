{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.filter\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.number.constructor\");\n\nrequire(\"core-js/modules/es.object.keys\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.object.values\");\n\nrequire(\"core-js/modules/es.regexp.constructor\");\n\nrequire(\"core-js/modules/es.regexp.exec\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.includes\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.match\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.string.split\");\n\nrequire(\"core-js/modules/es.string.trim\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ValidationChecker = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _utils = require(\"../utils/utils\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nvar _fetchPonyfill2 = _interopRequireDefault(require(\"fetch-ponyfill\"));\n\nvar _calendarUtils = require(\"../utils/calendarUtils\");\n\nvar _Rules = _interopRequireDefault(require(\"./Rules\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar _fetchPonyfill = (0, _fetchPonyfill2.default)({\n  Promise: _nativePromiseOnly.default\n}),\n    fetch = _fetchPonyfill.fetch,\n    Headers = _fetchPonyfill.Headers,\n    Request = _fetchPonyfill.Request;\n\nvar ValidationChecker = /*#__PURE__*/function () {\n  function ValidationChecker() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ValidationChecker);\n\n    this.config = _lodash.default.defaults(config, ValidationChecker.config);\n    this.validators = {\n      required: {\n        key: 'validate.required',\n        method: 'validateRequired',\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('required'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          if (!(0, _utils.boolValue)(setting) || component.isValueHidden()) {\n            return true;\n          }\n\n          var isCalendar = component.validators.some(function (validator) {\n            return validator === 'calendar';\n          });\n\n          if (!value && isCalendar && component.widget.enteredDate) {\n            return !this.validators.calendar.check.call(this, component, setting, value);\n          }\n\n          return !component.isEmpty(value);\n        }\n      },\n      onlyAvailableItems: {\n        key: 'validate.onlyAvailableItems',\n        method: 'validateValueAvailability',\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('valueIsNotAvailable'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting) {\n          return !(0, _utils.boolValue)(setting);\n        }\n      },\n      unique: {\n        key: 'validate.unique',\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('unique'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var _this = this; // Skip if setting is falsy\n\n\n          if (!(0, _utils.boolValue)(setting)) {\n            return true;\n          } // Skip if value is empty object or falsy\n\n\n          if (!value || _lodash.default.isObjectLike(value) && _lodash.default.isEmpty(value)) {\n            return true;\n          } // Skip if we don't have a database connection\n\n\n          if (!this.config.db) {\n            return true;\n          }\n\n          return new _nativePromiseOnly.default(function (resolve) {\n            var form = _this.config.form;\n            var submission = _this.config.submission;\n            var path = \"data.\".concat(component.path);\n\n            var addPathQueryParams = function addPathQueryParams(pathQueryParams, query, path) {\n              var pathArray = path.split(/\\[\\d+\\]?./);\n              var needValuesInArray = pathArray.length > 1;\n              var pathToValue = path;\n\n              if (needValuesInArray) {\n                pathToValue = pathArray.shift();\n                var pathQueryObj = {};\n\n                _lodash.default.reduce(pathArray, function (pathQueryPath, pathPart, index) {\n                  var isLastPathPart = index === pathArray.length - 1;\n\n                  var obj = _lodash.default.get(pathQueryObj, pathQueryPath, pathQueryObj);\n\n                  var addedPath = \"$elemMatch['\".concat(pathPart, \"']\");\n\n                  _lodash.default.set(obj, addedPath, isLastPathPart ? pathQueryParams : {});\n\n                  return pathQueryPath ? \"\".concat(pathQueryPath, \".\").concat(addedPath) : addedPath;\n                }, '');\n\n                query[pathToValue] = pathQueryObj;\n              } else {\n                query[pathToValue] = pathQueryParams;\n              }\n            }; // Build the query\n\n\n            var query = {\n              form: form._id\n            };\n\n            if (_lodash.default.isString(value)) {\n              if (component.component.dbIndex) {\n                addPathQueryParams(value, query, path);\n              } else {\n                addPathQueryParams({\n                  $regex: new RegExp(\"^\".concat((0, _utils.escapeRegExCharacters)(value), \"$\")),\n                  $options: 'i'\n                }, query, path);\n              }\n            } // FOR-213 - Pluck the unique location id\n            else if (_lodash.default.isPlainObject(value) && value.address && value.address['address_components'] && value.address['place_id']) {\n              addPathQueryParams({\n                $regex: new RegExp(\"^\".concat((0, _utils.escapeRegExCharacters)(value.address['place_id']), \"$\")),\n                $options: 'i'\n              }, query, \"\".concat(path, \".address.place_id\"));\n            } // Compare the contents of arrays vs the order.\n            else if (_lodash.default.isArray(value)) {\n              addPathQueryParams({\n                $all: value\n              }, query, path);\n            } else if (_lodash.default.isObject(value) || _lodash.default.isNumber(value)) {\n              addPathQueryParams({\n                $eq: value\n              }, query, path);\n            } // Only search for non-deleted items\n\n\n            query.deleted = {\n              $eq: null\n            }; // Try to find an existing value within the form\n\n            _this.config.db.findOne(query, function (err, result) {\n              if (err) {\n                return resolve(false);\n              } else if (result) {\n                // Only OK if it matches the current submission\n                if (submission._id && result._id.toString() === submission._id) {\n                  resolve(true);\n                } else {\n                  component.conflictId = result._id.toString();\n                  return resolve(false);\n                }\n              } else {\n                return resolve(true);\n              }\n            });\n          }).catch(function () {\n            return false;\n          });\n        }\n      },\n      multiple: {\n        key: 'validate.multiple',\n        hasLabel: true,\n        message: function message(component) {\n          var shouldBeArray = (0, _utils.boolValue)(component.component.multiple) || Array.isArray(component.emptyValue);\n          var isRequired = component.component.validate.required;\n          var messageKey = shouldBeArray ? isRequired ? 'array_nonempty' : 'array' : 'nonarray';\n          return component.t(component.errorMessage(messageKey), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          // Skip multiple validation if the component tells us to\n          if (!component.validateMultiple()) {\n            return true;\n          }\n\n          var shouldBeArray = (0, _utils.boolValue)(setting);\n          var canBeArray = Array.isArray(component.emptyValue);\n          var isArray = Array.isArray(value);\n          var isRequired = component.component.validate.required;\n\n          if (shouldBeArray) {\n            if (isArray) {\n              return isRequired ? !!value.length : true;\n            } else {\n              // Null/undefined is ok if this value isn't required; anything else should fail\n              return _lodash.default.isNil(value) ? !isRequired : false;\n            }\n          } else {\n            return canBeArray || !isArray;\n          }\n        }\n      },\n      select: {\n        key: 'validate.select',\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('select'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value, data, index, row, async) {\n          // Skip if setting is falsy\n          if (!(0, _utils.boolValue)(setting)) {\n            return true;\n          } // Skip if value is empty\n\n\n          if (!value || _lodash.default.isEmpty(value)) {\n            return true;\n          } // Skip if we're not async-capable\n\n\n          if (!async) {\n            return true;\n          }\n\n          var schema = component.component; // Initialize the request options\n\n          var requestOptions = {\n            url: setting,\n            method: 'GET',\n            qs: {},\n            json: true,\n            headers: {}\n          }; // If the url is a boolean value\n\n          if (_lodash.default.isBoolean(requestOptions.url)) {\n            requestOptions.url = !!requestOptions.url;\n\n            if (!requestOptions.url || schema.dataSrc !== 'url' || !schema.data.url || !schema.searchField) {\n              return true;\n            } // Get the validation url\n\n\n            requestOptions.url = schema.data.url; // Add the search field\n\n            requestOptions.qs[schema.searchField] = value; // Add the filters\n\n            if (schema.filter) {\n              requestOptions.url += (!requestOptions.url.includes('?') ? '?' : '&') + schema.filter;\n            } // If they only wish to return certain fields.\n\n\n            if (schema.selectFields) {\n              requestOptions.qs.select = schema.selectFields;\n            }\n          }\n\n          if (!requestOptions.url) {\n            return true;\n          } // Make sure to interpolate.\n\n\n          requestOptions.url = (0, _utils.interpolate)(requestOptions.url, {\n            data: component.data\n          }); // Add query string to URL\n\n          requestOptions.url += (requestOptions.url.includes('?') ? '&' : '?') + _lodash.default.chain(requestOptions.qs).map(function (val, key) {\n            return \"\".concat(encodeURIComponent(key), \"=\").concat(encodeURIComponent(val));\n          }).join('&').value(); // Set custom headers.\n\n          if (schema.data && schema.data.headers) {\n            _lodash.default.each(schema.data.headers, function (header) {\n              if (header.key) {\n                requestOptions.headers[header.key] = header.value;\n              }\n            });\n          } // Set form.io authentication.\n\n\n          if (schema.authenticate && this.config.token) {\n            requestOptions.headers['x-jwt-token'] = this.config.token;\n          }\n\n          return fetch(new Request(requestOptions.url, {\n            headers: new Headers(requestOptions.headers)\n          })).then(function (response) {\n            if (!response.ok) {\n              return false;\n            }\n\n            return response.json();\n          }).then(function (results) {\n            return results && results.length;\n          }).catch(function () {\n            return false;\n          });\n        }\n      },\n      min: {\n        key: 'validate.min',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(component.errorMessage('min'), {\n            field: component.errorLabel,\n            min: parseFloat(setting),\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var min = parseFloat(setting);\n          var parsedValue = parseFloat(value);\n\n          if (Number.isNaN(min) || Number.isNaN(parsedValue)) {\n            return true;\n          }\n\n          return parsedValue >= min;\n        }\n      },\n      max: {\n        key: 'validate.max',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(component.errorMessage('max'), {\n            field: component.errorLabel,\n            max: parseFloat(setting),\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var max = parseFloat(setting);\n          var parsedValue = parseFloat(value);\n\n          if (Number.isNaN(max) || Number.isNaN(parsedValue)) {\n            return true;\n          }\n\n          return parsedValue <= max;\n        }\n      },\n      minSelectedCount: {\n        key: 'validate.minSelectedCount',\n        message: function message(component, setting) {\n          return component.component.minSelectedCountMessage ? component.component.minSelectedCountMessage : component.t(component.errorMessage('minSelectedCount'), {\n            minCount: parseFloat(setting),\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var min = parseFloat(setting);\n\n          if (!min) {\n            return true;\n          }\n\n          var count = Object.keys(value).reduce(function (total, key) {\n            if (value[key]) {\n              total++;\n            }\n\n            return total;\n          }, 0); // Should not be triggered if there is no options selected at all\n\n          return !count || count >= min;\n        }\n      },\n      maxSelectedCount: {\n        key: 'validate.maxSelectedCount',\n        message: function message(component, setting) {\n          return component.component.maxSelectedCountMessage ? component.component.maxSelectedCountMessage : component.t(component.errorMessage('maxSelectedCount'), {\n            minCount: parseFloat(setting),\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var max = parseFloat(setting);\n\n          if (!max) {\n            return true;\n          }\n\n          var count = Object.keys(value).reduce(function (total, key) {\n            if (value[key]) {\n              total++;\n            }\n\n            return total;\n          }, 0);\n          return count <= max;\n        }\n      },\n      minLength: {\n        key: 'validate.minLength',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(component.errorMessage('minLength'), {\n            field: component.errorLabel,\n            length: setting,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var minLength = parseInt(setting, 10);\n\n          if (!value || !minLength || typeof value !== 'string' || component.isEmpty(value)) {\n            return true;\n          }\n\n          return value.length >= minLength;\n        }\n      },\n      maxLength: {\n        key: 'validate.maxLength',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(component.errorMessage('maxLength'), {\n            field: component.errorLabel,\n            length: setting,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var maxLength = parseInt(setting, 10);\n\n          if (!maxLength || typeof value !== 'string') {\n            return true;\n          }\n\n          return value.length <= maxLength;\n        }\n      },\n      maxWords: {\n        key: 'validate.maxWords',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(component.errorMessage('maxWords'), {\n            field: component.errorLabel,\n            length: setting,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var maxWords = parseInt(setting, 10);\n\n          if (!maxWords || typeof value !== 'string') {\n            return true;\n          }\n\n          return value.trim().split(/\\s+/).length <= maxWords;\n        }\n      },\n      minWords: {\n        key: 'validate.minWords',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(component.errorMessage('minWords'), {\n            field: component.errorLabel,\n            length: setting,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var minWords = parseInt(setting, 10);\n\n          if (!minWords || !value || typeof value !== 'string') {\n            return true;\n          }\n\n          return value.trim().split(/\\s+/).length >= minWords;\n        }\n      },\n      email: {\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('invalid_email'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          /* eslint-disable max-len */\n          // From http://stackoverflow.com/questions/46155/validate-email-address-in-javascript\n          var re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n          /* eslint-enable max-len */\n          // Allow emails to be valid if the component is pristine and no value is provided.\n\n          return !value || re.test(value);\n        }\n      },\n      url: {\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('invalid_url'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          /* eslint-disable max-len */\n          // From https://stackoverflow.com/questions/8667070/javascript-regular-expression-to-validate-url\n          var re = /^(?:(?:(?:https?|ftp):)?\\/\\/)?(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i; // From http://stackoverflow.com/questions/46155/validate-email-address-in-javascript\n\n          var emailRe = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n          /* eslint-enable max-len */\n          // Allow urls to be valid if the component is pristine and no value is provided.\n\n          return !value || re.test(value) && !emailRe.test(value);\n        }\n      },\n      date: {\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('invalid_date'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          return value !== 'Invalid date';\n        }\n      },\n      day: {\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('invalid_day'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          if (!value) {\n            return true;\n          }\n\n          var _ref = component.dayFirst ? [0, 1, 2] : [1, 0, 2],\n              _ref2 = _slicedToArray(_ref, 3),\n              DAY = _ref2[0],\n              MONTH = _ref2[1],\n              YEAR = _ref2[2];\n\n          var values = value.split('/').map(function (x) {\n            return parseInt(x, 10);\n          }),\n              day = values[DAY],\n              month = values[MONTH],\n              year = values[YEAR],\n              maxDay = getDaysInMonthCount(month, year);\n\n          if (day < 0 || day > maxDay) {\n            return false;\n          }\n\n          if (month < 0 || month > 12) {\n            return false;\n          }\n\n          if (year < 0 || year > 9999) {\n            return false;\n          }\n\n          return true;\n\n          function isLeapYear(year) {\n            // Year is leap if it is evenly divisible by 400 or evenly divisible by 4 and not evenly divisible by 100.\n            return !(year % 400) || !!(year % 100) && !(year % 4);\n          }\n\n          function getDaysInMonthCount(month, year) {\n            switch (month) {\n              case 1: // January\n\n              case 3: // March\n\n              case 5: // May\n\n              case 7: // July\n\n              case 8: // August\n\n              case 10: // October\n\n              case 12:\n                // December\n                return 31;\n\n              case 4: // April\n\n              case 6: // June\n\n              case 9: // September\n\n              case 11:\n                // November\n                return 30;\n\n              case 2:\n                // February\n                return isLeapYear(year) ? 29 : 28;\n\n              default:\n                return 31;\n            }\n          }\n        }\n      },\n      pattern: {\n        key: 'validate.pattern',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(_lodash.default.get(component, 'component.validate.patternMessage', component.errorMessage('pattern')), {\n            field: component.errorLabel,\n            pattern: setting,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          if (component.isEmpty(value)) return true;\n          var pattern = setting;\n\n          if (!pattern) {\n            return true;\n          }\n\n          var regex = new RegExp(\"^\".concat(pattern, \"$\"));\n          return regex.test(value);\n        }\n      },\n      json: {\n        key: 'validate.json',\n        check: function check(component, setting, value, data, index, row) {\n          if (!setting) {\n            return true;\n          }\n\n          var valid = component.evaluate(setting, {\n            data: data,\n            row: row,\n            rowIndex: index,\n            input: value\n          });\n\n          if (valid === null) {\n            return true;\n          }\n\n          return valid;\n        }\n      },\n      mask: {\n        key: 'inputMask',\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage('mask'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value) {\n          var inputMask;\n\n          if (component.isMultipleMasksField) {\n            var maskName = value ? value.maskName : undefined;\n            var formioInputMask = component.getMaskByName(maskName);\n\n            if (formioInputMask) {\n              inputMask = formioInputMask;\n            }\n\n            value = value ? value.value : value;\n          } else {\n            inputMask = setting;\n          }\n\n          inputMask = inputMask ? (0, _utils.getInputMask)(inputMask) : null;\n\n          if (value && inputMask && !component.skipMaskValidation) {\n            // If char which is used inside mask placeholder was used in the mask, replace it with space to prevent errors\n            inputMask = inputMask.map(function (char) {\n              return char === component.placeholderChar ? ' ' : char;\n            });\n            return (0, _utils.matchInputMask)(value, inputMask);\n          }\n\n          return true;\n        }\n      },\n      custom: {\n        key: 'validate.custom',\n        message: function message(component) {\n          return component.t(component.errorMessage('custom'), {\n            field: component.errorLabel,\n            data: component.data\n          });\n        },\n        check: function check(component, setting, value, data, index, row) {\n          if (!setting) {\n            return true;\n          }\n\n          var valid = component.evaluate(setting, {\n            valid: true,\n            data: data,\n            rowIndex: index,\n            row: row,\n            input: value\n          }, 'valid', true);\n\n          if (valid === null) {\n            return true;\n          }\n\n          return valid;\n        }\n      },\n      maxDate: {\n        key: 'maxDate',\n        hasLabel: true,\n        message: function message(component, setting) {\n          var date = (0, _utils.getDateSetting)(setting);\n          return component.t(component.errorMessage('maxDate'), {\n            field: component.errorLabel,\n            maxDate: (0, _moment.default)(date).format(component.format)\n          });\n        },\n        check: function check(component, setting, value) {\n          //if any parts of day are missing, skip maxDate validation\n          if (component.isPartialDay && component.isPartialDay(value)) {\n            return true;\n          }\n\n          var date = component.getValidationFormat ? (0, _moment.default)(value, component.getValidationFormat()) : (0, _moment.default)(value);\n          var maxDate = (0, _utils.getDateSetting)(setting);\n\n          if (_lodash.default.isNull(maxDate)) {\n            return true;\n          } else {\n            maxDate.setHours(0, 0, 0, 0);\n          }\n\n          return date.isBefore(maxDate) || date.isSame(maxDate);\n        }\n      },\n      minDate: {\n        key: 'minDate',\n        hasLabel: true,\n        message: function message(component, setting) {\n          var date = (0, _utils.getDateSetting)(setting);\n          return component.t(component.errorMessage('minDate'), {\n            field: component.errorLabel,\n            minDate: (0, _moment.default)(date).format(component.format)\n          });\n        },\n        check: function check(component, setting, value) {\n          //if any parts of day are missing, skip minDate validation\n          if (component.isPartialDay && component.isPartialDay(value)) {\n            return true;\n          }\n\n          var date = component.getValidationFormat ? (0, _moment.default)(value, component.getValidationFormat()) : (0, _moment.default)(value);\n          var minDate = (0, _utils.getDateSetting)(setting);\n\n          if (_lodash.default.isNull(minDate)) {\n            return true;\n          } else {\n            minDate.setHours(0, 0, 0, 0);\n          }\n\n          return date.isAfter(minDate) || date.isSame(minDate);\n        }\n      },\n      minYear: {\n        key: 'minYear',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(component.errorMessage('minYear'), {\n            field: component.errorLabel,\n            minYear: setting\n          });\n        },\n        check: function check(component, setting, value) {\n          var minYear = setting;\n          var year = /\\d{4}$/.exec(value);\n          year = year ? year[0] : null;\n\n          if (!+minYear || !+year) {\n            return true;\n          }\n\n          return +year >= +minYear;\n        }\n      },\n      maxYear: {\n        key: 'maxYear',\n        hasLabel: true,\n        message: function message(component, setting) {\n          return component.t(component.errorMessage('maxYear'), {\n            field: component.errorLabel,\n            maxYear: setting\n          });\n        },\n        check: function check(component, setting, value) {\n          var maxYear = setting;\n          var year = /\\d{4}$/.exec(value);\n          year = year ? year[0] : null;\n\n          if (!+maxYear || !+year) {\n            return true;\n          }\n\n          return +year <= +maxYear;\n        }\n      },\n      calendar: {\n        key: 'validate.calendar',\n        messageText: '',\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage(this.validators.calendar.messageText), {\n            field: component.errorLabel,\n            maxDate: (0, _moment.default)(component.dataValue).format(component.format)\n          });\n        },\n        check: function check(component, setting, value, data, index) {\n          this.validators.calendar.messageText = '';\n          var widget = component.getWidget(index);\n\n          if (!widget) {\n            return true;\n          }\n\n          var settings = widget.settings,\n              enteredDate = widget.enteredDate;\n          var minDate = settings.minDate,\n              maxDate = settings.maxDate,\n              format = settings.format;\n          var momentFormat = [(0, _utils.convertFormatToMoment)(format)];\n\n          if (momentFormat[0].match(/M{3,}/g)) {\n            momentFormat.push(momentFormat[0].replace(/M{3,}/g, 'MM'));\n          }\n\n          if (!value && enteredDate) {\n            var _checkInvalidDate = (0, _calendarUtils.checkInvalidDate)(enteredDate, momentFormat, minDate, maxDate),\n                message = _checkInvalidDate.message,\n                result = _checkInvalidDate.result;\n\n            if (!result) {\n              this.validators.calendar.messageText = message;\n              return result;\n            }\n          }\n\n          if (value && enteredDate) {\n            if ((0, _moment.default)(value).format() !== (0, _moment.default)(enteredDate, momentFormat, true).format() && enteredDate.match(/_/gi)) {\n              this.validators.calendar.messageText = _calendarUtils.CALENDAR_ERROR_MESSAGES.INCOMPLETE;\n              return false;\n            } else {\n              widget.enteredDate = '';\n              return true;\n            }\n          }\n        }\n      },\n      time: {\n        key: 'validate.time',\n        messageText: 'Invalid time',\n        hasLabel: true,\n        message: function message(component) {\n          return component.t(component.errorMessage(this.validators.time.messageText), {\n            field: component.errorLabel\n          });\n        },\n        check: function check(component, setting, value) {\n          if (component.isEmpty(value)) return true;\n          return (0, _moment.default)(value, component.component.format).isValid();\n        }\n      }\n    };\n  }\n\n  _createClass(ValidationChecker, [{\n    key: \"checkValidator\",\n    value: function checkValidator(component, validator, setting, value, data, index, row, async) {\n      var _this2 = this;\n\n      var resultOrPromise = null; // Allow each component to override their own validators by implementing the validator.method\n\n      if (validator.method && typeof component[validator.method] === 'function') {\n        resultOrPromise = component[validator.method](setting, value, data, index, row, async);\n      } else {\n        resultOrPromise = validator.check.call(this, component, setting, value, data, index, row, async);\n      }\n\n      var processResult = function processResult(result) {\n        if (typeof result === 'string') {\n          return result;\n        }\n\n        if (!result && validator.message) {\n          return validator.message.call(_this2, component, setting, index, row);\n        }\n\n        return '';\n      };\n\n      if (async) {\n        return _nativePromiseOnly.default.resolve(resultOrPromise).then(processResult);\n      } else {\n        return processResult(resultOrPromise);\n      }\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(component, validatorName, value, data, index, row, async, conditionallyVisible, validationObj) {\n      // Skip validation for conditionally hidden components\n      if (!conditionallyVisible) {\n        return false;\n      }\n\n      var validator = this.validators[validatorName];\n\n      var setting = _lodash.default.get(validationObj || component.component, validator.key, null);\n\n      var resultOrPromise = this.checkValidator(component, validator, setting, value, data, index, row, async);\n\n      var processResult = function processResult(result) {\n        if (result) {\n          var _component$refs$input;\n\n          var resultData = {\n            message: (0, _utils.unescapeHTML)(_lodash.default.get(result, 'message', result)),\n            level: _lodash.default.get(result, 'level') === 'warning' ? 'warning' : 'error',\n            path: (0, _utils.getArrayFromComponentPath)(component.path || ''),\n            context: {\n              validator: validatorName,\n              hasLabel: validator.hasLabel,\n              setting: setting,\n              key: component.key,\n              label: component.label,\n              value: value,\n              index: index,\n              input: (_component$refs$input = component.refs.input) === null || _component$refs$input === void 0 ? void 0 : _component$refs$input[index]\n            }\n          };\n\n          if (validatorName === 'unique' && component.conflictId) {\n            resultData.conflictId = component.conflictId;\n          }\n\n          return resultData;\n        } else {\n          return false;\n        }\n      };\n\n      if (async) {\n        return _nativePromiseOnly.default.resolve(resultOrPromise).then(processResult);\n      } else {\n        return processResult(resultOrPromise);\n      }\n    }\n  }, {\n    key: \"checkComponent\",\n    value: function checkComponent(component, data, row) {\n      var _component$addons,\n          _this3 = this;\n\n      var includeWarnings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var isServerSidePersistent = typeof process !== 'undefined' && _lodash.default.get(process, 'release.name') === 'node' && !_lodash.default.defaultTo(component.component.persistent, true); // If we're server-side and it's not a persistent component, don't run validation at all\n\n      if (isServerSidePersistent || component.component.validate === false) {\n        return async ? _nativePromiseOnly.default.resolve([]) : [];\n      }\n\n      data = data || component.rootValue;\n      row = row || component.data;\n      var values = component.component.multiple && Array.isArray(component.validationValue) ? component.validationValue : [component.validationValue];\n      var conditionallyVisible = component.conditionallyVisible();\n      var addonsValidations = [];\n\n      if (component !== null && component !== void 0 && (_component$addons = component.addons) !== null && _component$addons !== void 0 && _component$addons.length) {\n        values.forEach(function (value) {\n          component.addons.forEach(function (addon) {\n            if (!addon.checkValidity(value)) {\n              addonsValidations.push.apply(addonsValidations, _toConsumableArray(addon.errors || []));\n            }\n          });\n        });\n      } // If this component has the new validation system enabled, use it instead.\n\n\n      var validations = _lodash.default.get(component, 'component.validations');\n\n      var nextGenResultsOrPromises = [];\n\n      if (validations && Array.isArray(validations) && validations.length) {\n        var validationsGroupedByMode = _lodash.default.chain(validations).groupBy(function (validation) {\n          return validation.mode;\n        }).value();\n\n        if (component.calculateCondition) {\n          includeWarnings = true;\n\n          var uiGroupedValidation = _lodash.default.chain(validationsGroupedByMode.ui).filter('active').groupBy(function (validation) {\n            return validation.group || null;\n          }).value();\n\n          var commonValidations = uiGroupedValidation.null || [];\n          delete uiGroupedValidation.null;\n          commonValidations.forEach(function (_ref3) {\n            var condition = _ref3.condition,\n                message = _ref3.message,\n                severity = _ref3.severity;\n\n            if (!component.calculateCondition(condition)) {\n              nextGenResultsOrPromises.push({\n                level: severity || 'error',\n                message: component.t(message),\n                componentInstance: component\n              });\n            }\n          });\n\n          _lodash.default.forEach(uiGroupedValidation, function (validationGroup) {\n            _lodash.default.forEach(validationGroup, function (_ref4) {\n              var condition = _ref4.condition,\n                  message = _ref4.message,\n                  severity = _ref4.severity;\n\n              if (!component.calculateCondition(condition)) {\n                nextGenResultsOrPromises.push({\n                  level: severity || 'error',\n                  message: component.t(message),\n                  componentInstance: component\n                });\n                return false;\n              }\n            });\n          });\n        } else {\n          nextGenResultsOrPromises = this.checkValidations(component, validations, data, row, values, async);\n        }\n\n        if (component.validators.includes('custom') && validationsGroupedByMode.js) {\n          _lodash.default.each(validationsGroupedByMode.js, function (validation) {\n            nextGenResultsOrPromises.push(_lodash.default.map(values, function (value, index) {\n              return _this3.validate(component, 'custom', value, data, index, row, async, conditionallyVisible, validation);\n            }));\n          });\n        }\n\n        if (component.validators.includes('json') && validationsGroupedByMode.json) {\n          _lodash.default.each(validationsGroupedByMode.json, function (validation) {\n            nextGenResultsOrPromises.push(_lodash.default.map(values, function (value, index) {\n              return _this3.validate(component, 'json', value, data, index, row, async, conditionallyVisible, validation);\n            }));\n          });\n        }\n      }\n\n      var validateCustom = _lodash.default.get(component, 'component.validate.custom');\n\n      var customErrorMessage = _lodash.default.get(component, 'component.validate.customMessage'); // Run primary validators\n\n\n      var resultsOrPromises = (0, _lodash.default)(component.validators).chain().map(function (validatorName) {\n        if (!_this3.validators.hasOwnProperty(validatorName)) {\n          return {\n            message: \"Validator for \\\"\".concat(validatorName, \"\\\" is not defined\"),\n            level: 'warning',\n            context: {\n              validator: validatorName,\n              key: component.key,\n              label: component.label\n            }\n          };\n        } // Handle the case when there is no values defined and it is required.\n\n\n        if (validatorName === 'required' && !values.length) {\n          return [_this3.validate(component, validatorName, null, data, 0, row, async, conditionallyVisible)];\n        }\n\n        return _lodash.default.map(values, function (value, index) {\n          return _this3.validate(component, validatorName, value, data, index, row, async, conditionallyVisible);\n        });\n      }).flatten().value(); // Run the \"unique\" pseudo-validator\n\n      component.component.validate = component.component.validate || {};\n      component.component.validate.unique = component.component.unique;\n      resultsOrPromises.push(this.validate(component, 'unique', component.validationValue, data, 0, data, async, conditionallyVisible)); // Run the \"multiple\" pseudo-validator\n\n      component.component.validate.multiple = component.component.multiple;\n      resultsOrPromises.push(this.validate(component, 'multiple', component.validationValue, data, 0, data, async, conditionallyVisible));\n      resultsOrPromises.push.apply(resultsOrPromises, addonsValidations);\n      resultsOrPromises.push.apply(resultsOrPromises, _toConsumableArray(nextGenResultsOrPromises)); // Define how results should be formatted\n\n      var formatResults = function formatResults(results) {\n        // Condense to a single flat array\n        results = (0, _lodash.default)(results).chain().flatten().compact().value();\n\n        if (customErrorMessage || validateCustom) {\n          _lodash.default.each(results, function (result) {\n            result.message = component.t(customErrorMessage || result.message, {\n              field: component.errorLabel,\n              data: data,\n              row: row,\n              error: result\n            });\n            result.context.hasLabel = false;\n          });\n        }\n\n        return includeWarnings ? results : _lodash.default.reject(results, function (result) {\n          return result.level === 'warning';\n        });\n      }; // Wait for results if using async mode, otherwise process and return immediately\n\n\n      if (async) {\n        return _nativePromiseOnly.default.all(resultsOrPromises).then(formatResults);\n      } else {\n        return formatResults(resultsOrPromises);\n      }\n    }\n    /**\n     * Use the new validations engine to evaluate any errors.\n     *\n     * @param component\n     * @param validations\n     * @param data\n     * @param row\n     * @param values\n     * @returns {any[]}\n     */\n\n  }, {\n    key: \"checkValidations\",\n    value: function checkValidations(component, validations, data, row, values, async) {\n      var _this4 = this; // Get results.\n\n\n      var results = validations.map(function (validation) {\n        return _this4.checkRule(component, validation, data, row, values, async);\n      }); // Flatten array and filter out empty results.\n\n      var messages = results.reduce(function (prev, result) {\n        if (result) {\n          return [].concat(_toConsumableArray(prev), _toConsumableArray(result));\n        }\n\n        return prev;\n      }, []).filter(function (result) {\n        return result;\n      }); // Keep only the last error for each rule.\n\n      var rules = messages.reduce(function (prev, message) {\n        prev[message.context.validator] = message;\n        return prev;\n      }, {});\n      return Object.values(rules);\n    }\n  }, {\n    key: \"checkRule\",\n    value: function checkRule(component, validation, data, row, values, async) {\n      var Rule = _Rules.default.getRule(validation.rule);\n\n      var results = [];\n\n      if (Rule) {\n        var rule = new Rule(component, validation.settings, this.config);\n        values.map(function (value, index) {\n          var result = rule.check(value, data, row, async);\n\n          if (result !== true) {\n            results.push({\n              level: validation.level || 'error',\n              message: component.t(validation.message || rule.defaultMessage, {\n                settings: validation.settings,\n                field: component.errorLabel,\n                data: data,\n                row: row,\n                error: result\n              }),\n              context: {\n                key: component.key,\n                index: index,\n                label: component.label,\n                validator: validation.rule\n              }\n            });\n          }\n        });\n      } // If there are no results, return false so it is removed by filter.\n\n\n      return results.length === 0 ? false : results;\n    }\n  }, {\n    key: \"check\",\n    get: function get() {\n      return this.checkComponent;\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      _lodash.default.get.call(this, arguments);\n    }\n  }, {\n    key: \"each\",\n    value: function each() {\n      _lodash.default.each.call(this, arguments);\n    }\n  }, {\n    key: \"has\",\n    value: function has() {\n      _lodash.default.has.call(this, arguments);\n    }\n  }]);\n\n  return ValidationChecker;\n}();\n\nexports.ValidationChecker = ValidationChecker;\nValidationChecker.config = {\n  db: null,\n  token: null,\n  form: null,\n  submission: null\n};\nvar instance = new ValidationChecker();\nexports.default = instance;","map":null,"metadata":{},"sourceType":"script"}