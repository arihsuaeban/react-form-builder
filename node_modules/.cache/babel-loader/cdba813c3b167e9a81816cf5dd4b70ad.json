{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.autocomplete = factory());\n})(this, function () {\n  'use strict';\n  /*\r\n   * https://github.com/kraaden/autocomplete\r\n   * Copyright (c) 2016 Denys Krasnoshchok\r\n   * MIT License\r\n   */\n\n  function autocomplete(settings) {\n    // just an alias to minimize JS file size\n    var doc = document;\n    var container = settings.container || doc.createElement(\"div\");\n    var containerStyle = container.style;\n    var userAgent = navigator.userAgent;\n    var mobileFirefox = ~userAgent.indexOf(\"Firefox\") && ~userAgent.indexOf(\"Mobile\");\n    var debounceWaitMs = settings.debounceWaitMs || 0;\n    var preventSubmit = settings.preventSubmit || false;\n    var disableAutoSelect = settings.disableAutoSelect || false; // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\n\n    var keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\n    var items = [];\n    var inputValue = \"\";\n    var minLen = 2;\n    var showOnFocus = settings.showOnFocus;\n    var selected;\n    var keypressCounter = 0;\n    var debounceTimer;\n\n    if (settings.minLength !== undefined) {\n      minLen = settings.minLength;\n    }\n\n    if (!settings.input) {\n      throw new Error(\"input undefined\");\n    }\n\n    var input = settings.input;\n    container.className = \"autocomplete \" + (settings.className || \"\"); // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n\n    containerStyle.position = \"absolute\";\n    /**\r\n     * Detach the container from DOM\r\n     */\n\n    function detach() {\n      var parent = container.parentNode;\n\n      if (parent) {\n        parent.removeChild(container);\n      }\n    }\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\n\n\n    function clearDebounceTimer() {\n      if (debounceTimer) {\n        window.clearTimeout(debounceTimer);\n      }\n    }\n    /**\r\n     * Attach the container to DOM\r\n     */\n\n\n    function attach() {\n      if (!container.parentNode) {\n        doc.body.appendChild(container);\n      }\n    }\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\n\n\n    function containerDisplayed() {\n      return !!container.parentNode;\n    }\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\n\n\n    function clear() {\n      // prevent the update call if there are pending AJAX requests\n      keypressCounter++;\n      items = [];\n      inputValue = \"\";\n      selected = undefined;\n      detach();\n    }\n    /**\r\n     * Update autocomplete position\r\n     */\n\n\n    function updatePosition() {\n      if (!containerDisplayed()) {\n        return;\n      }\n\n      containerStyle.height = \"auto\";\n      containerStyle.width = input.offsetWidth + \"px\";\n      var maxHeight = 0;\n      var inputRect;\n\n      function calc() {\n        var docEl = doc.documentElement;\n        var clientTop = docEl.clientTop || doc.body.clientTop || 0;\n        var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\n        var scrollTop = window.pageYOffset || docEl.scrollTop;\n        var scrollLeft = window.pageXOffset || docEl.scrollLeft;\n        inputRect = input.getBoundingClientRect();\n        var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\n        var left = inputRect.left + scrollLeft - clientLeft;\n        containerStyle.top = top + \"px\";\n        containerStyle.left = left + \"px\";\n        maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\n\n        if (maxHeight < 0) {\n          maxHeight = 0;\n        }\n\n        containerStyle.top = top + \"px\";\n        containerStyle.bottom = \"\";\n        containerStyle.left = left + \"px\";\n        containerStyle.maxHeight = maxHeight + \"px\";\n      } // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\n\n\n      calc();\n      calc();\n\n      if (settings.customize && inputRect) {\n        settings.customize(input, inputRect, container, maxHeight);\n      }\n    }\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\n\n\n    function update() {\n      // delete all children from autocomplete DOM container\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      } // function for rendering autocomplete suggestions\n\n\n      var render = function render(item, currentValue) {\n        var itemElement = doc.createElement(\"div\");\n        itemElement.textContent = item.label || \"\";\n        return itemElement;\n      };\n\n      if (settings.render) {\n        render = settings.render;\n      } // function to render autocomplete groups\n\n\n      var renderGroup = function renderGroup(groupName, currentValue) {\n        var groupDiv = doc.createElement(\"div\");\n        groupDiv.textContent = groupName;\n        return groupDiv;\n      };\n\n      if (settings.renderGroup) {\n        renderGroup = settings.renderGroup;\n      }\n\n      var fragment = doc.createDocumentFragment();\n      var prevGroup = \"#9?$\";\n      items.forEach(function (item) {\n        if (item.group && item.group !== prevGroup) {\n          prevGroup = item.group;\n          var groupDiv = renderGroup(item.group, inputValue);\n\n          if (groupDiv) {\n            groupDiv.className += \" group\";\n            fragment.appendChild(groupDiv);\n          }\n        }\n\n        var div = render(item, inputValue);\n\n        if (div) {\n          div.addEventListener(\"click\", function (ev) {\n            settings.onSelect(item, input);\n            clear();\n            ev.preventDefault();\n            ev.stopPropagation();\n          });\n\n          if (item === selected) {\n            div.className += \" selected\";\n          }\n\n          fragment.appendChild(div);\n        }\n      });\n      container.appendChild(fragment);\n\n      if (items.length < 1) {\n        if (settings.emptyMsg) {\n          var empty = doc.createElement(\"div\");\n          empty.className = \"empty\";\n          empty.textContent = settings.emptyMsg;\n          container.appendChild(empty);\n        } else {\n          clear();\n          return;\n        }\n      }\n\n      attach();\n      updatePosition();\n      updateScroll();\n    }\n\n    function updateIfDisplayed() {\n      if (containerDisplayed()) {\n        update();\n      }\n    }\n\n    function resizeEventHandler() {\n      updateIfDisplayed();\n    }\n\n    function scrollEventHandler(e) {\n      if (e.target !== container) {\n        updateIfDisplayed();\n      } else {\n        e.preventDefault();\n      }\n    }\n\n    function keyupEventHandler(ev) {\n      var keyCode = ev.which || ev.keyCode || 0;\n      var ignore = settings.keysToIgnore || [38\n      /* Up */\n      , 13\n      /* Enter */\n      , 27\n      /* Esc */\n      , 39\n      /* Right */\n      , 37\n      /* Left */\n      , 16\n      /* Shift */\n      , 17\n      /* Ctrl */\n      , 18\n      /* Alt */\n      , 20\n      /* CapsLock */\n      , 91\n      /* WindowsKey */\n      , 9\n      /* Tab */\n      ];\n\n      for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\n        var key = ignore_1[_i];\n\n        if (keyCode === key) {\n          return;\n        }\n      }\n\n      if (keyCode >= 112\n      /* F1 */\n      && keyCode <= 123\n      /* F12 */\n      && !settings.keysToIgnore) {\n        return;\n      } // the down key is used to open autocomplete\n\n\n      if (keyCode === 40\n      /* Down */\n      && containerDisplayed()) {\n        return;\n      }\n\n      startFetch(0\n      /* Keyboard */\n      );\n    }\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\n\n\n    function updateScroll() {\n      var elements = container.getElementsByClassName(\"selected\");\n\n      if (elements.length > 0) {\n        var element = elements[0]; // make group visible\n\n        var previous = element.previousElementSibling;\n\n        if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n          element = previous;\n        }\n\n        if (element.offsetTop < container.scrollTop) {\n          container.scrollTop = element.offsetTop;\n        } else {\n          var selectBottom = element.offsetTop + element.offsetHeight;\n          var containerBottom = container.scrollTop + container.offsetHeight;\n\n          if (selectBottom > containerBottom) {\n            container.scrollTop += selectBottom - containerBottom;\n          }\n        }\n      }\n    }\n    /**\r\n     * Select the previous item in suggestions\r\n     */\n\n\n    function selectPrev() {\n      if (items.length < 1) {\n        selected = undefined;\n      } else {\n        if (selected === items[0]) {\n          selected = items[items.length - 1];\n        } else {\n          for (var i = items.length - 1; i > 0; i--) {\n            if (selected === items[i] || i === 1) {\n              selected = items[i - 1];\n              break;\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * Select the next item in suggestions\r\n     */\n\n\n    function selectNext() {\n      if (items.length < 1) {\n        selected = undefined;\n      }\n\n      if (!selected || selected === items[items.length - 1]) {\n        selected = items[0];\n        return;\n      }\n\n      for (var i = 0; i < items.length - 1; i++) {\n        if (selected === items[i]) {\n          selected = items[i + 1];\n          break;\n        }\n      }\n    }\n\n    function keydownEventHandler(ev) {\n      var keyCode = ev.which || ev.keyCode || 0;\n\n      if (keyCode === 38\n      /* Up */\n      || keyCode === 40\n      /* Down */\n      || keyCode === 27\n      /* Esc */\n      ) {\n        var containerIsDisplayed = containerDisplayed();\n\n        if (keyCode === 27\n        /* Esc */\n        ) {\n          clear();\n        } else {\n          if (!containerIsDisplayed || items.length < 1) {\n            return;\n          }\n\n          keyCode === 38\n          /* Up */\n          ? selectPrev() : selectNext();\n          update();\n        }\n\n        ev.preventDefault();\n\n        if (containerIsDisplayed) {\n          ev.stopPropagation();\n        }\n\n        return;\n      }\n\n      if (keyCode === 13\n      /* Enter */\n      ) {\n        if (selected) {\n          settings.onSelect(selected, input);\n          clear();\n        }\n\n        if (preventSubmit) {\n          ev.preventDefault();\n        }\n      }\n    }\n\n    function focusEventHandler() {\n      if (showOnFocus) {\n        startFetch(1\n        /* Focus */\n        );\n      }\n    }\n\n    function startFetch(trigger) {\n      // If multiple keys were pressed, before we get an update from server,\n      // this may cause redrawing autocomplete multiple times after the last key was pressed.\n      // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.\n      var savedKeypressCounter = ++keypressCounter;\n      var inputText = input.value;\n      var cursorPos = input.selectionStart || 0;\n\n      if (inputText.length >= minLen || trigger === 1\n      /* Focus */\n      ) {\n        clearDebounceTimer();\n        debounceTimer = window.setTimeout(function () {\n          settings.fetch(inputText, function (elements) {\n            if (keypressCounter === savedKeypressCounter && elements) {\n              items = elements;\n              inputValue = inputText;\n              selected = items.length < 1 || disableAutoSelect ? undefined : items[0];\n              update();\n            }\n          }, trigger, cursorPos);\n        }, trigger === 0\n        /* Keyboard */\n        ? debounceWaitMs : 0);\n      } else {\n        clear();\n      }\n    }\n\n    function blurEventHandler() {\n      // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n      setTimeout(function () {\n        if (doc.activeElement !== input) {\n          clear();\n        }\n      }, 200);\n    }\n    /**\r\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\r\n     */\n\n\n    container.addEventListener(\"mousedown\", function (evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n    });\n    /**\r\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\r\n     * See: https://stackoverflow.com/a/9210267/13172349\r\n     */\n\n    container.addEventListener(\"focus\", function () {\n      return input.focus();\n    });\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\n\n    function destroy() {\n      input.removeEventListener(\"focus\", focusEventHandler);\n      input.removeEventListener(\"keydown\", keydownEventHandler);\n      input.removeEventListener(keyUpEventName, keyupEventHandler);\n      input.removeEventListener(\"blur\", blurEventHandler);\n      window.removeEventListener(\"resize\", resizeEventHandler);\n      doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n      clearDebounceTimer();\n      clear();\n    } // setup event handlers\n\n\n    input.addEventListener(\"keydown\", keydownEventHandler);\n    input.addEventListener(keyUpEventName, keyupEventHandler);\n    input.addEventListener(\"blur\", blurEventHandler);\n    input.addEventListener(\"focus\", focusEventHandler);\n    window.addEventListener(\"resize\", resizeEventHandler);\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\n    return {\n      destroy: destroy\n    };\n  }\n\n  return autocomplete;\n});","map":null,"metadata":{},"sourceType":"script"}