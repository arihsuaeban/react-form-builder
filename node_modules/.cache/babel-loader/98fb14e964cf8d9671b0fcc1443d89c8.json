{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _Field2 = require('formiojs/components/_classes/field/Field');\n\nvar _Field3 = _interopRequireDefault(_Field2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar ReactComponent = function (_Field) {\n  _inherits(ReactComponent, _Field);\n  /**\n   * This is the first phase of component building where the component is instantiated.\n   *\n   * @param component - The component definition created from the settings form.\n   * @param options - Any options passed into the renderer.\n   * @param data - The submission data where this component's data exists.\n   */\n\n\n  function ReactComponent(component, options, data) {\n    _classCallCheck(this, ReactComponent);\n\n    var _this = _possibleConstructorReturn(this, (ReactComponent.__proto__ || Object.getPrototypeOf(ReactComponent)).call(this, component, options, data));\n\n    _this.updateValue = function (value, flags) {\n      flags = flags || {};\n      var newValue = value === undefined || value === null ? _this.getValue() : value;\n      var changed = newValue !== undefined ? _this.hasChanged(newValue, _this.dataValue) : false;\n      _this.dataValue = Array.isArray(newValue) ? [].concat(_toConsumableArray(newValue)) : newValue;\n\n      _this.updateOnChange(flags, changed);\n\n      return changed;\n    };\n\n    return _this;\n  }\n  /**\n   * This method is called any time the component needs to be rebuilt. It is most frequently used to listen to other\n   * components using the this.on() function.\n   */\n\n\n  _createClass(ReactComponent, [{\n    key: 'init',\n    value: function init() {\n      return _get(ReactComponent.prototype.__proto__ || Object.getPrototypeOf(ReactComponent.prototype), 'init', this).call(this);\n    }\n    /**\n     * This method is called before the component is going to be destroyed, which is when the component instance is\n     * destroyed. This is different from detach which is when the component instance still exists but the dom instance is\n     * removed.\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      return _get(ReactComponent.prototype.__proto__ || Object.getPrototypeOf(ReactComponent.prototype), 'destroy', this).call(this);\n    }\n    /**\n     * The second phase of component building where the component is rendered as an HTML string.\n     *\n     * @returns {string} - The return is the full string of the component\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      // For react components, we simply render as a div which will become the react instance.\n      // By calling super.render(string) it will wrap the component with the needed wrappers to make it a full component.\n      return _get(ReactComponent.prototype.__proto__ || Object.getPrototypeOf(ReactComponent.prototype), 'render', this).call(this, '<div ref=\"react-' + this.id + '\"></div>');\n    }\n    /**\n     * The third phase of component building where the component has been attached to the DOM as 'element' and is ready\n     * to have its javascript events attached.\n     *\n     * @param element\n     * @returns {Promise<void>} - Return a promise that resolves when the attach is complete.\n     */\n\n  }, {\n    key: 'attach',\n    value: function attach(element) {\n      _get(ReactComponent.prototype.__proto__ || Object.getPrototypeOf(ReactComponent.prototype), 'attach', this).call(this, element); // The loadRefs function will find all dom elements that have the \"ref\" setting that match the object property.\n      // It can load a single element or multiple elements with the same ref.\n\n\n      this.loadRefs(element, _defineProperty({}, 'react-' + this.id, 'single'));\n\n      if (this.refs['react-' + this.id]) {\n        this.reactInstance = this.attachReact(this.refs['react-' + this.id]);\n\n        if (this.shouldSetValue) {\n          this.setValue(this.dataForSetting);\n          this.updateValue(this.dataForSetting);\n        }\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * The fourth phase of component building where the component is being removed from the page. This could be a redraw\n     * or it is being removed from the form.\n     */\n\n  }, {\n    key: 'detach',\n    value: function detach() {\n      if (this.refs['react-' + this.id]) {\n        this.detachReact(this.refs['react-' + this.id]);\n      }\n\n      _get(ReactComponent.prototype.__proto__ || Object.getPrototypeOf(ReactComponent.prototype), 'detach', this).call(this);\n    }\n    /**\n     * Override this function to insert your custom component.\n     *\n     * @param element\n     */\n\n  }, {\n    key: 'attachReact',\n    value: function attachReact(element) {\n      return;\n    }\n    /**\n     * Override this function.\n     */\n\n  }, {\n    key: 'detachReact',\n    value: function detachReact(element) {\n      return;\n    }\n    /**\n     * Something external has set a value and our component needs to be updated to reflect that. For example, loading a submission.\n     *\n     * @param value\n     */\n\n  }, {\n    key: 'setValue',\n    value: function setValue(value) {\n      if (this.reactInstance) {\n        this.reactInstance.setState({\n          value: value\n        });\n        this.shouldSetValue = false;\n      } else {\n        this.shouldSetValue = true;\n        this.dataForSetting = value;\n      }\n    }\n    /**\n     * The user has changed the value in the component and the value needs to be updated on the main submission object and other components notified of a change event.\n     *\n     * @param value\n     */\n\n  }, {\n    key: 'getValue',\n\n    /**\n     * Get the current value of the component. Should return the value set in the react component.\n     *\n     * @returns {*}\n     */\n    value: function getValue() {\n      if (this.reactInstance) {\n        return this.reactInstance.state.value;\n      }\n\n      return this.defaultValue;\n    }\n    /**\n     * Override normal validation check to insert custom validation in react component.\n     *\n     * @param data\n     * @param dirty\n     * @param rowData\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'checkValidity',\n    value: function checkValidity(data, dirty, rowData) {\n      var valid = _get(ReactComponent.prototype.__proto__ || Object.getPrototypeOf(ReactComponent.prototype), 'checkValidity', this).call(this, data, dirty, rowData);\n\n      if (!valid) {\n        return false;\n      }\n\n      return this.validate(data, dirty, rowData);\n    }\n    /**\n     * Do custom validation.\n     *\n     * @param data\n     * @param dirty\n     * @param rowData\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(data, dirty, rowData) {\n      return true;\n    }\n  }]);\n\n  return ReactComponent;\n}(_Field3.default);\n\nexports.default = ReactComponent;","map":null,"metadata":{},"sourceType":"script"}