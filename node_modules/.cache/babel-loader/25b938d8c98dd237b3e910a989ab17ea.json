{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.find\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.reflect.construct\");\n\nrequire(\"core-js/modules/es.reflect.get\");\n\nrequire(\"core-js/modules/es.reflect.set\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Field2 = _interopRequireDefault(require(\"../field/Field\"));\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction set(target, property, value, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.set) {\n    set = Reflect.set;\n  } else {\n    set = function set(target, property, value, receiver) {\n      var base = _superPropBase(target, property);\n\n      var desc;\n\n      if (base) {\n        desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.set) {\n          desc.set.call(receiver, value);\n          return true;\n        } else if (!desc.writable) {\n          return false;\n        }\n      }\n\n      desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n      if (desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        desc.value = value;\n        Object.defineProperty(receiver, property, desc);\n      } else {\n        _defineProperty(receiver, property, value);\n      }\n\n      return true;\n    };\n  }\n\n  return set(target, property, value, receiver);\n}\n\nfunction _set(target, property, value, receiver, isStrict) {\n  var s = set(target, property, value, receiver || target);\n\n  if (!s && isStrict) {\n    throw new Error('failed to set property');\n  }\n\n  return value;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar Multivalue = /*#__PURE__*/function (_Field) {\n  _inherits(Multivalue, _Field);\n\n  var _super = _createSuper(Multivalue);\n\n  function Multivalue() {\n    _classCallCheck(this, Multivalue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Multivalue, [{\n    key: \"dataValue\",\n    get: function get() {\n      var parent = _get(_getPrototypeOf(Multivalue.prototype), \"dataValue\", this);\n\n      if (!parent && this.component.multiple) {\n        return [];\n      }\n\n      return parent;\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(Multivalue.prototype), \"dataValue\", value, this, true);\n    }\n  }, {\n    key: \"defaultValue\",\n    get: function get() {\n      var value = _get(_getPrototypeOf(Multivalue.prototype), \"defaultValue\", this);\n\n      if (this.component.multiple) {\n        if (_lodash.default.isArray(value)) {\n          value = !value.length ? [_get(_getPrototypeOf(Multivalue.prototype), \"emptyValue\", this)] : value;\n        } else {\n          value = [value];\n        }\n      }\n\n      return value;\n    }\n  }, {\n    key: \"addAnother\",\n    get: function get() {\n      return this.t(this.component.addAnother || 'Add Another');\n    }\n  }, {\n    key: \"useWrapper\",\n    value: function useWrapper() {\n      return this.component.hasOwnProperty('multiple') && this.component.multiple;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      // If single value field.\n      if (!this.useWrapper()) {\n        return _get(_getPrototypeOf(Multivalue.prototype), \"render\", this).call(this, \"<div ref=\\\"element\\\">\\n          \".concat(this.renderElement(this.component.type !== 'hidden' ? this.dataValue : ''), \"\\n        </div>\"));\n      } // Make sure dataValue is in the correct array format.\n\n\n      var dataValue = this.dataValue;\n\n      if (!Array.isArray(dataValue)) {\n        dataValue = dataValue ? [dataValue] : [];\n      } // If multiple value field.\n\n\n      return _get(_getPrototypeOf(Multivalue.prototype), \"render\", this).call(this, this.renderTemplate('multiValueTable', {\n        rows: dataValue.map(this.renderRow.bind(this)).join(''),\n        disabled: this.disabled,\n        addAnother: this.addAnother\n      }));\n    }\n  }, {\n    key: \"renderElement\",\n    value: function renderElement() {\n      return '';\n    }\n  }, {\n    key: \"renderRow\",\n    value: function renderRow(value, index) {\n      return this.renderTemplate('multiValueRow', {\n        index: index,\n        disabled: this.disabled,\n        element: \"\".concat(this.renderElement(value, index))\n      });\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(dom) {\n      var _this = this;\n\n      var superAttach = _get(_getPrototypeOf(Multivalue.prototype), \"attach\", this).call(this, dom);\n\n      this.loadRefs(dom, {\n        addButton: 'multiple',\n        input: 'multiple',\n        removeRow: 'multiple',\n        mask: 'multiple',\n        select: 'multiple'\n      });\n      var promises = [];\n      this.refs.input.forEach(function (element, index) {\n        promises.push(_this.attachElement.call(_this, element, index));\n      });\n\n      if (!this.component.multiple) {\n        return _nativePromiseOnly.default.all(promises);\n      }\n\n      this.refs.removeRow.forEach(function (removeButton, index) {\n        _this.addEventListener(removeButton, 'click', function (event) {\n          event.preventDefault();\n\n          _this.removeValue(index);\n        });\n      }); // If single value field.\n\n      this.refs.addButton.forEach(function (addButton) {\n        _this.addEventListener(addButton, 'click', function (event) {\n          event.preventDefault();\n\n          _this.addValue();\n        });\n      });\n      return superAttach.then(function () {\n        return _nativePromiseOnly.default.all(promises);\n      });\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this.refs.input && this.refs.input.length) {\n        this.refs.input.forEach(function (input) {\n          if (input.mask) {\n            input.mask.destroy();\n          }\n\n          if (input.widget) {\n            input.widget.destroy();\n          }\n        });\n      }\n\n      if (this.refs.mask && this.refs.mask.length) {\n        this.refs.mask.forEach(function (input) {\n          if (input.mask) {\n            input.mask.destroy();\n          }\n        });\n      }\n\n      _get(_getPrototypeOf(Multivalue.prototype), \"detach\", this).call(this);\n    }\n    /**\n     * Attach inputs to the element.\n     *\n     * @param element\n     * @param index\n     */\n\n  }, {\n    key: \"attachElement\",\n    value: function attachElement(element, index) {\n      var _this2 = this;\n\n      this.addEventListener(element, this.inputInfo.changeEvent, function () {\n        // Delay update slightly to give input mask a chance to run.\n        var textCase = _lodash.default.get(_this2.component, 'case', 'mixed');\n\n        if (textCase !== 'mixed') {\n          var selectionStart = element.selectionStart,\n              selectionEnd = element.selectionEnd;\n\n          if (textCase === 'uppercase' && element.value) {\n            element.value = element.value.toUpperCase();\n          }\n\n          if (textCase === 'lowercase' && element.value) {\n            element.value = element.value.toLowerCase();\n          }\n\n          if (element.selectionStart && element.selectionEnd) {\n            element.selectionStart = selectionStart;\n            element.selectionEnd = selectionEnd;\n          }\n        }\n\n        try {\n          _this2.saveCaretPosition(element, index);\n        } catch (err) {\n          console.warn('An error occurred while trying to save caret position', err);\n        } // If a mask is present, delay the update to allow mask to update first.\n\n\n        if (element.mask) {\n          setTimeout(function () {\n            return _this2.updateValue(null, {\n              modified: _this2.component.type !== 'hidden'\n            }, index);\n          }, 1);\n        } else {\n          return _this2.updateValue(null, {\n            modified: _this2.component.type !== 'hidden'\n          }, index);\n        }\n      });\n\n      if (!this.attachMultiMask(index)) {\n        this.setInputMask(element);\n        var valueMask = this.component.inputMask;\n        var displayMask = this.component.displayMask;\n\n        if (valueMask && displayMask && displayMask !== valueMask && this.refs.valueMaskInput) {\n          this.setInputMask(this.refs.valueMaskInput, valueMask);\n        }\n      }\n    } // Saves current caret position to restore it after the component is redrawn\n\n  }, {\n    key: \"saveCaretPosition\",\n    value: function saveCaretPosition(element, index) {\n      var _this$root, _this$root$focusedCom;\n\n      if (((_this$root = this.root) === null || _this$root === void 0 ? void 0 : (_this$root$focusedCom = _this$root.focusedComponent) === null || _this$root$focusedCom === void 0 ? void 0 : _this$root$focusedCom.path) === this.path) {\n        this.root.currentSelection = {\n          selection: [element.selectionStart, element.selectionEnd],\n          index: index\n        };\n      }\n    }\n  }, {\n    key: \"onSelectMaskHandler\",\n    value: function onSelectMaskHandler(event) {\n      this.updateMask(event.target.maskInput, this.getMaskPattern(event.target.value));\n    }\n  }, {\n    key: \"getMaskPattern\",\n    value: function getMaskPattern(maskName) {\n      if (!this.multiMasks) {\n        this.multiMasks = {};\n      }\n\n      if (this.multiMasks[maskName]) {\n        return this.multiMasks[maskName];\n      }\n\n      var mask = this.component.inputMasks.find(function (inputMask) {\n        return inputMask.label === maskName;\n      });\n      this.multiMasks[maskName] = mask ? mask.mask : this.component.inputMasks[0].mask;\n      return this.multiMasks[maskName];\n    }\n  }, {\n    key: \"attachMultiMask\",\n    value: function attachMultiMask(index) {\n      if (!(this.isMultipleMasksField && this.component.inputMasks.length && this.refs.input.length)) {\n        return false;\n      }\n\n      var maskSelect = this.refs.select[index];\n      maskSelect.onchange = this.onSelectMaskHandler.bind(this);\n      maskSelect.maskInput = this.refs.mask[index];\n      this.setInputMask(maskSelect.maskInput, this.component.inputMasks[0].mask);\n      return true;\n    }\n  }, {\n    key: \"updateMask\",\n    value: function updateMask(input, mask) {\n      if (!mask) {\n        return;\n      }\n\n      this.setInputMask(input, mask, !this.component.placeholder);\n      this.updateValue();\n    }\n    /**\n     * Adds a new empty value to the data array.\n     */\n\n  }, {\n    key: \"addNewValue\",\n    value: function addNewValue(value) {\n      if (value === undefined) {\n        value = this.component.defaultValue ? this.component.defaultValue : this.emptyValue; // If default is an empty aray, default back to empty value.\n\n        if (Array.isArray(value) && value.length === 0) {\n          value = this.emptyValue;\n        }\n      }\n\n      var dataValue = this.dataValue || [];\n\n      if (!Array.isArray(dataValue)) {\n        dataValue = [dataValue];\n      }\n\n      if (Array.isArray(value)) {\n        dataValue = dataValue.concat(value);\n      } else {\n        dataValue.push(value);\n      }\n\n      this.dataValue = dataValue;\n    }\n    /**\n     * Adds a new empty value to the data array, and add a new row to contain it.\n     */\n\n  }, {\n    key: \"addValue\",\n    value: function addValue() {\n      this.addNewValue();\n      this.redraw();\n      this.checkConditions();\n\n      if (!this.isEmpty(this.dataValue)) {\n        this.restoreValue();\n      }\n\n      if (this.root) {\n        this.root.onChange();\n      }\n    }\n  }]);\n\n  return Multivalue;\n}(_Field2.default);\n\nexports.default = Multivalue;","map":null,"metadata":{},"sourceType":"script"}