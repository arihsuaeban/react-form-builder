{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.filter\");\n\nrequire(\"core-js/modules/es.array.find-index\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.array.splice\");\n\nrequire(\"core-js/modules/es.number.constructor\");\n\nrequire(\"core-js/modules/es.number.parse-int\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.reflect.construct\");\n\nrequire(\"core-js/modules/es.reflect.get\");\n\nrequire(\"core-js/modules/es.reflect.set\");\n\nrequire(\"core-js/modules/es.string.includes\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _Field2 = _interopRequireDefault(require(\"../field/Field\"));\n\nvar _Components = _interopRequireDefault(require(\"../../Components\"));\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nvar _utils = require(\"../../../utils/utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction set(target, property, value, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.set) {\n    set = Reflect.set;\n  } else {\n    set = function set(target, property, value, receiver) {\n      var base = _superPropBase(target, property);\n\n      var desc;\n\n      if (base) {\n        desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.set) {\n          desc.set.call(receiver, value);\n          return true;\n        } else if (!desc.writable) {\n          return false;\n        }\n      }\n\n      desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n      if (desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        desc.value = value;\n        Object.defineProperty(receiver, property, desc);\n      } else {\n        _defineProperty(receiver, property, value);\n      }\n\n      return true;\n    };\n  }\n\n  return set(target, property, value, receiver);\n}\n\nfunction _set(target, property, value, receiver, isStrict) {\n  var s = set(target, property, value, receiver || target);\n\n  if (!s && isStrict) {\n    throw new Error('failed to set property');\n  }\n\n  return value;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar NestedComponent = /*#__PURE__*/function (_Field) {\n  _inherits(NestedComponent, _Field);\n\n  var _super = _createSuper(NestedComponent);\n\n  function NestedComponent(component, options, data) {\n    var _this;\n\n    _classCallCheck(this, NestedComponent);\n\n    _this = _super.call(this, component, options, data);\n    _this.type = 'components';\n    _this._collapsed = !!_this.component.collapsed;\n    return _this;\n  }\n\n  _createClass(NestedComponent, [{\n    key: \"defaultSchema\",\n    get: function get() {\n      return NestedComponent.schema();\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      var schema = _get(_getPrototypeOf(NestedComponent.prototype), \"schema\", this);\n\n      var components = _lodash.default.uniqBy(this.getComponents(), 'component.key');\n\n      schema.components = _lodash.default.map(components, 'schema');\n      return schema;\n    }\n  }, {\n    key: \"collapsed\",\n    get: function get() {\n      return this._collapsed;\n    },\n    set: function set(value) {\n      this._collapsed = value;\n      this.collapse(value);\n    }\n  }, {\n    key: \"collapse\",\n    value: function collapse(value) {\n      var promise = this.redraw();\n\n      if (!value && !this.pristine) {\n        this.checkValidity(this.data, true);\n      }\n\n      return promise;\n    }\n  }, {\n    key: \"visible\",\n    get: function get() {\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"visible\", this);\n    },\n    set: function set(value) {\n      // DO NOT CALL super here.  There is an issue where clearOnHide was getting triggered with\n      // subcomponents because the \"parentVisible\" flag was set to false when it should really be\n      // set to true.\n      var visibilityChanged = this._visible !== value;\n      this._visible = value;\n      var isVisible = this.visible;\n      var forceShow = this.options.show && this.options.show[this.component.key];\n      var forceHide = this.options.hide && this.options.hide[this.component.key];\n      this.components.forEach(function (component) {\n        // Set the parent visibility first since we may have nested components within nested components\n        // and they need to be able to determine their visibility based on the parent visibility.\n        component.parentVisible = isVisible;\n        var conditionallyVisible = component.conditionallyVisible();\n\n        if (forceShow || conditionallyVisible) {\n          component.visible = true;\n        } else if (forceHide || !isVisible || !conditionallyVisible) {\n          component.visible = false;\n        } // If hiding a nested component, clear all errors below.\n\n\n        if (!component.visible) {\n          component.error = '';\n        }\n      });\n\n      if (visibilityChanged) {\n        this.clearOnHide();\n        this.redraw();\n      }\n    }\n  }, {\n    key: \"parentVisible\",\n    get: function get() {\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"parentVisible\", this);\n    },\n    set: function set(value) {\n      var _this2 = this;\n\n      _set(_getPrototypeOf(NestedComponent.prototype), \"parentVisible\", value, this, true);\n\n      this.components.forEach(function (component) {\n        return component.parentVisible = _this2.visible;\n      });\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"disabled\", this);\n    },\n    set: function set(disabled) {\n      _set(_getPrototypeOf(NestedComponent.prototype), \"disabled\", disabled, this, true);\n\n      this.components.forEach(function (component) {\n        return component.parentDisabled = disabled;\n      });\n    }\n  }, {\n    key: \"parentDisabled\",\n    get: function get() {\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"parentDisabled\", this);\n    },\n    set: function set(value) {\n      var _this3 = this;\n\n      _set(_getPrototypeOf(NestedComponent.prototype), \"parentDisabled\", value, this, true);\n\n      this.components.forEach(function (component) {\n        component.parentDisabled = _this3.disabled;\n      });\n    }\n  }, {\n    key: \"ready\",\n    get: function get() {\n      return _nativePromiseOnly.default.all(this.getComponents().map(function (component) {\n        return component.ready;\n      }));\n    }\n  }, {\n    key: \"currentForm\",\n    get: function get() {\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"currentForm\", this);\n    },\n    set: function set(instance) {\n      _set(_getPrototypeOf(NestedComponent.prototype), \"currentForm\", instance, this, true);\n\n      this.getComponents().forEach(function (component) {\n        component.currentForm = instance;\n      });\n    }\n  }, {\n    key: \"rowIndex\",\n    get: function get() {\n      return this._rowIndex;\n    },\n    set: function set(value) {\n      this._rowIndex = value;\n      this.eachComponent(function (component) {\n        component.rowIndex = value;\n      });\n    }\n  }, {\n    key: \"componentContext\",\n    value: function componentContext() {\n      return this._data;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    },\n    set: function set(value) {\n      var _this4 = this;\n\n      this._data = value;\n      this.eachComponent(function (component) {\n        component.data = _this4.componentContext(component);\n      });\n    }\n  }, {\n    key: \"getComponents\",\n    value: function getComponents() {\n      return this.components || [];\n    }\n    /**\n     * Perform a deep iteration over every component, including those\n     * within other container based components.\n     *\n     * @param {function} fn - Called for every component.\n     */\n\n  }, {\n    key: \"everyComponent\",\n    value: function everyComponent(fn, options) {\n      var components = this.getComponents();\n\n      _lodash.default.each(components, function (component, index) {\n        if (fn(component, components, index) === false) {\n          return false;\n        }\n\n        if (typeof component.everyComponent === 'function') {\n          if (component.everyComponent(fn, options) === false) {\n            return false;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"hasComponent\",\n    value: function hasComponent(component) {\n      var result = false;\n      this.everyComponent(function (comp) {\n        if (comp === component) {\n          result = true;\n          return false;\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"flattenComponents\",\n    value: function flattenComponents() {\n      var result = {};\n      this.everyComponent(function (component) {\n        result[component.component.flattenAs || component.key] = component;\n      });\n      return result;\n    }\n    /**\n     * Perform an iteration over each component within this container component.\n     *\n     * @param {function} fn - Called for each component\n     */\n\n  }, {\n    key: \"eachComponent\",\n    value: function eachComponent(fn) {\n      _lodash.default.each(this.getComponents(), function (component, index) {\n        if (fn(component, index) === false) {\n          return false;\n        }\n      });\n    }\n    /**\n     * Returns a component provided a key. This performs a deep search within the\n     * component tree.\n     *\n     * @param {string} key - The key of the component to retrieve.\n     * @param {function} fn - Called with the component once found.\n     * @return {Object} - The component that is located.\n     */\n\n  }, {\n    key: \"getComponent\",\n    value: function getComponent(path, fn, originalPath) {\n      originalPath = originalPath || (0, _utils.getStringFromComponentPath)(path);\n      path = (0, _utils.getArrayFromComponentPath)(path);\n      var pathStr = originalPath;\n\n      var newPath = _lodash.default.clone(path);\n\n      var key = newPath.shift();\n      var remainingPath = newPath;\n      var comp = null;\n      var possibleComp = null;\n\n      if (_lodash.default.isNumber(key)) {\n        key = remainingPath.shift();\n      }\n\n      if (!_lodash.default.isString(key)) {\n        return comp;\n      }\n\n      this.everyComponent(function (component, components) {\n        var matchPath = component.hasInput && component.path ? pathStr.includes(component.path) : true;\n\n        if (component.component.key === key) {\n          possibleComp = component;\n\n          if (matchPath) {\n            comp = component;\n\n            if (remainingPath.length > 0 && 'getComponent' in component) {\n              comp = component.getComponent(remainingPath, fn, originalPath);\n            } else if (fn) {\n              fn(component, components);\n            }\n\n            return false;\n          }\n        }\n      });\n\n      if (!comp) {\n        comp = possibleComp;\n      }\n\n      return comp;\n    }\n    /**\n     * Return a component provided the Id of the component.\n     *\n     * @param {string} id - The Id of the component.\n     * @param {function} fn - Called with the component once it is retrieved.\n     * @return {Object} - The component retrieved.\n     */\n\n  }, {\n    key: \"getComponentById\",\n    value: function getComponentById(id, fn) {\n      var comp = null;\n      this.everyComponent(function (component, components) {\n        if (component.id === id) {\n          comp = component;\n\n          if (fn) {\n            fn(component, components);\n          }\n\n          return false;\n        }\n      });\n      return comp;\n    }\n    /**\n     * Return a path of component's value.\n     *\n     * @param {Object} component - The component instance.\n     * @return {string} - The component's value path.\n     */\n\n  }, {\n    key: \"calculateComponentPath\",\n    value: function calculateComponentPath(component) {\n      var path = '';\n\n      if (component.component.key) {\n        var thisPath = this;\n\n        while (thisPath && !thisPath.allowData && thisPath.parent) {\n          thisPath = thisPath.parent;\n        }\n\n        var rowIndex = component.row ? \"[\".concat(Number.parseInt(component.row), \"]\") : '';\n        path = thisPath.path ? \"\".concat(thisPath.path).concat(rowIndex, \".\") : '';\n        path += component._parentPath && component.component.shouldIncludeSubFormPath ? component._parentPath : '';\n        path += component.component.key;\n        return path;\n      }\n    }\n    /**\n     * Create a new component and add it to the components array.\n     *\n     * @param component\n     * @param data\n     */\n\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(component, options, data, before) {\n      var _options;\n\n      if (!component) {\n        return;\n      }\n\n      options = options || this.options;\n      data = data || this.data;\n      options.parent = this;\n      options.parentVisible = this.visible;\n      options.root = ((_options = options) === null || _options === void 0 ? void 0 : _options.root) || this.root || this;\n      options.localRoot = this.localRoot;\n      options.skipInit = true;\n\n      if (!this.isInputComponent && this.component.shouldIncludeSubFormPath) {\n        component.shouldIncludeSubFormPath = true;\n      }\n\n      var comp = _Components.default.create(component, options, data, true);\n\n      var path = this.calculateComponentPath(comp);\n\n      if (path) {\n        comp.path = path;\n      }\n\n      comp.init();\n\n      if (component.internal) {\n        return comp;\n      }\n\n      if (before) {\n        var index = _lodash.default.findIndex(this.components, {\n          id: before.id\n        });\n\n        if (index !== -1) {\n          this.components.splice(index, 0, comp);\n        } else {\n          this.components.push(comp);\n        }\n      } else {\n        this.components.push(comp);\n      }\n\n      return comp;\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.element;\n    }\n  }, {\n    key: \"componentComponents\",\n    get: function get() {\n      return this.component.components || [];\n    }\n  }, {\n    key: \"nestedKey\",\n    get: function get() {\n      return \"nested-\".concat(this.key);\n    }\n  }, {\n    key: \"templateName\",\n    get: function get() {\n      return 'container';\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.components = this.components || [];\n      this.addComponents();\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"init\", this).call(this);\n    }\n    /**\n     *\n     * @param element\n     * @param data\n     */\n\n  }, {\n    key: \"addComponents\",\n    value: function addComponents(data, options) {\n      var _this5 = this;\n\n      data = data || this.data;\n      options = options || this.options;\n\n      if (options.components) {\n        this.components = options.components;\n      } else {\n        var components = this.hook('addComponents', this.componentComponents, this) || [];\n        components.forEach(function (component) {\n          return _this5.addComponent(component, data);\n        });\n      }\n    }\n    /**\n     * Add a new component to the components array.\n     *\n     * @param {Object} component - The component JSON schema to add.\n     * @param {Object} data - The submission data object to house the data for this component.\n     * @param {HTMLElement} before - A DOM element to insert this element before.\n     * @return {Component} - The created component instance.\n     */\n\n  }, {\n    key: \"addComponent\",\n    value: function addComponent(component, data, before, noAdd) {\n      data = data || this.data;\n\n      if (this.options.parentPath) {\n        component.shouldIncludeSubFormPath = true;\n      }\n\n      component = this.hook('addComponent', component, data, before, noAdd);\n      var comp = this.createComponent(component, this.options, data, before ? before : null);\n\n      if (noAdd) {\n        return comp;\n      }\n\n      return comp;\n    }\n  }, {\n    key: \"beforeFocus\",\n    value: function beforeFocus() {\n      if (this.parent && 'beforeFocus' in this.parent) {\n        this.parent.beforeFocus(this);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(children) {\n      // If already rendering, don't re-render.\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"render\", this).call(this, children || this.renderTemplate(this.templateName, {\n        children: !this.visible ? '' : this.renderComponents(),\n        nestedKey: this.nestedKey,\n        collapsed: this.options.pdf ? false : this.collapsed\n      }));\n    }\n  }, {\n    key: \"renderComponents\",\n    value: function renderComponents(components) {\n      components = components || this.getComponents();\n      var children = components.map(function (component) {\n        return component.render();\n      });\n      return this.renderTemplate('components', {\n        children: children,\n        components: components\n      });\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(element) {\n      var _this6 = this;\n\n      var superPromise = _get(_getPrototypeOf(NestedComponent.prototype), \"attach\", this).call(this, element);\n\n      this.loadRefs(element, _defineProperty({\n        header: 'single',\n        collapsed: this.collapsed\n      }, this.nestedKey, 'single'));\n\n      var childPromise = _nativePromiseOnly.default.resolve();\n\n      if (this.refs[this.nestedKey]) {\n        childPromise = this.attachComponents(this.refs[this.nestedKey]);\n      }\n\n      if (this.component.collapsible && this.refs.header) {\n        this.addEventListener(this.refs.header, 'click', function () {\n          _this6.collapsed = !_this6.collapsed;\n        });\n        this.addEventListener(this.refs.header, 'keydown', function (e) {\n          if (e.keyCode === 13 || e.keyCode === 32) {\n            e.preventDefault();\n            _this6.collapsed = !_this6.collapsed;\n          }\n        });\n      }\n\n      return _nativePromiseOnly.default.all([superPromise, childPromise]);\n    }\n  }, {\n    key: \"attachComponents\",\n    value: function attachComponents(element, components, container) {\n      components = components || this.components;\n      container = container || this.component.components;\n      element = this.hook('attachComponents', element, components, container, this);\n\n      if (!element) {\n        // Return a non-resolving promise.\n        return new _nativePromiseOnly.default(function () {});\n      }\n\n      var index = 0;\n      var promises = [];\n      Array.prototype.slice.call(element.children).forEach(function (child) {\n        if (!child.getAttribute('data-noattach') && components[index]) {\n          promises.push(components[index].attach(child));\n          index++;\n        }\n      });\n      return _nativePromiseOnly.default.all(promises);\n    }\n    /**\n     * Remove a component from the components array.\n     *\n     * @param {Component} component - The component to remove from the components.\n     * @param {Array<Component>} components - An array of components to remove this component from.\n     */\n\n  }, {\n    key: \"removeComponent\",\n    value: function removeComponent(component, components) {\n      components = components || this.components;\n      component.destroy();\n\n      _lodash.default.remove(components, {\n        id: component.id\n      });\n    }\n    /**\n     * Removes a component provided the API key of that component.\n     *\n     * @param {string} key - The API key of the component to remove.\n     * @param {function} fn - Called once the component is removed.\n     * @return {null}\n     */\n\n  }, {\n    key: \"removeComponentByKey\",\n    value: function removeComponentByKey(key, fn) {\n      var _this7 = this;\n\n      var comp = this.getComponent(key, function (component, components) {\n        _this7.removeComponent(component, components);\n\n        if (fn) {\n          fn(component, components);\n        }\n      });\n\n      if (!comp) {\n        if (fn) {\n          fn(null);\n        }\n\n        return null;\n      }\n    }\n    /**\n     * Removes a component provided the Id of the component.\n     *\n     * @param {string} id - The Id of the component to remove.\n     * @param {function} fn - Called when the component is removed.\n     * @return {null}\n     */\n\n  }, {\n    key: \"removeComponentById\",\n    value: function removeComponentById(id, fn) {\n      var _this8 = this;\n\n      var comp = this.getComponentById(id, function (component, components) {\n        _this8.removeComponent(component, components);\n\n        if (fn) {\n          fn(component, components);\n        }\n      });\n\n      if (!comp) {\n        if (fn) {\n          fn(null);\n        }\n\n        return null;\n      }\n    }\n  }, {\n    key: \"updateValue\",\n    value: function updateValue(value) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.components.reduce(function (changed, comp) {\n        return comp.updateValue(null, flags) || changed;\n      }, _get(_getPrototypeOf(NestedComponent.prototype), \"updateValue\", this).call(this, value, flags));\n    }\n  }, {\n    key: \"shouldSkipValidation\",\n    value: function shouldSkipValidation(data, dirty, row) {\n      // Nested components with no input should not be validated.\n      if (!this.component.input) {\n        return true;\n      } else {\n        return _get(_getPrototypeOf(NestedComponent.prototype), \"shouldSkipValidation\", this).call(this, data, dirty, row);\n      }\n    }\n  }, {\n    key: \"checkData\",\n    value: function checkData(data, flags, row, components) {\n      if (this.builderMode) {\n        return true;\n      }\n\n      data = data || this.rootValue;\n      flags = flags || {};\n      row = row || this.data;\n      components = components && _lodash.default.isArray(components) ? components : this.getComponents();\n      var isValid = components.reduce(function (valid, comp) {\n        return comp.checkData(data, flags, row) && valid;\n      }, _get(_getPrototypeOf(NestedComponent.prototype), \"checkData\", this).call(this, data, flags, row));\n      this.checkModal(isValid, this.isDirty);\n      return isValid;\n    }\n  }, {\n    key: \"checkConditions\",\n    value: function checkConditions(data, flags, row) {\n      // check conditions of parent component first, because it may influence on visibility of it's children\n      var check = _get(_getPrototypeOf(NestedComponent.prototype), \"checkConditions\", this).call(this, data, flags, row); //row data of parent component not always corresponds to row of nested components, use comp.data as row data for children instead\n\n\n      this.getComponents().forEach(function (comp) {\n        return comp.checkConditions(data, flags, comp.data);\n      });\n      return check;\n    }\n  }, {\n    key: \"clearOnHide\",\n    value: function clearOnHide(show) {\n      _get(_getPrototypeOf(NestedComponent.prototype), \"clearOnHide\", this).call(this, show);\n\n      if (this.component.clearOnHide) {\n        if (this.allowData && !this.hasValue()) {\n          this.dataValue = this.defaultValue;\n        }\n\n        if (this.hasValue()) {\n          this.restoreComponentsContext();\n        }\n      }\n\n      this.getComponents().forEach(function (component) {\n        return component.clearOnHide(show);\n      });\n    }\n  }, {\n    key: \"restoreComponentsContext\",\n    value: function restoreComponentsContext() {\n      var _this9 = this;\n\n      this.getComponents().forEach(function (component) {\n        return component.data = _this9.dataValue;\n      });\n    }\n    /**\n     * Allow components to hook into the next page trigger to perform their own logic.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforePage\",\n    value: function beforePage(next) {\n      return _nativePromiseOnly.default.all(this.getComponents().map(function (comp) {\n        return comp.beforePage(next);\n      }));\n    }\n    /**\n     * Allow components to hook into the submission to provide their own async data.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforeSubmit\",\n    value: function beforeSubmit() {\n      return _nativePromiseOnly.default.all(this.getComponents().map(function (comp) {\n        return comp.beforeSubmit();\n      }));\n    }\n  }, {\n    key: \"calculateValue\",\n    value: function calculateValue(data, flags, row) {\n      // Do not iterate into children and calculateValues if this nested component is conditionally hidden.\n      if (!this.conditionallyVisible()) {\n        return false;\n      }\n\n      return this.getComponents().reduce(function (changed, comp) {\n        return comp.calculateValue(data, flags, row) || changed;\n      }, _get(_getPrototypeOf(NestedComponent.prototype), \"calculateValue\", this).call(this, data, flags, row));\n    }\n  }, {\n    key: \"isLastPage\",\n    value: function isLastPage() {\n      return this.pages.length - 1 === this.page;\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid(data, dirty) {\n      return this.getComponents().reduce(function (valid, comp) {\n        return comp.isValid(data, dirty) && valid;\n      }, _get(_getPrototypeOf(NestedComponent.prototype), \"isValid\", this).call(this, data, dirty));\n    }\n  }, {\n    key: \"checkValidity\",\n    value: function checkValidity(data, dirty, row, silentCheck) {\n      if (!this.checkCondition(row, data)) {\n        this.setCustomValidity('');\n        return true;\n      }\n\n      var isValid = this.getComponents().reduce(function (check, comp) {\n        return comp.checkValidity(data, dirty, row, silentCheck) && check;\n      }, _get(_getPrototypeOf(NestedComponent.prototype), \"checkValidity\", this).call(this, data, dirty, row, silentCheck));\n      this.checkModal(isValid, dirty);\n      return isValid;\n    }\n  }, {\n    key: \"checkAsyncValidity\",\n    value: function checkAsyncValidity(data, dirty, row, silentCheck) {\n      var _this10 = this;\n\n      return this.ready.then(function () {\n        var promises = [_get(_getPrototypeOf(NestedComponent.prototype), \"checkAsyncValidity\", _this10).call(_this10, data, dirty, row, silentCheck)];\n\n        _this10.eachComponent(function (component) {\n          return promises.push(component.checkAsyncValidity(data, dirty, row, silentCheck));\n        });\n\n        return _nativePromiseOnly.default.all(promises).then(function (results) {\n          return results.reduce(function (valid, result) {\n            return valid && result;\n          }, true);\n        });\n      });\n    }\n  }, {\n    key: \"setPristine\",\n    value: function setPristine(pristine) {\n      _get(_getPrototypeOf(NestedComponent.prototype), \"setPristine\", this).call(this, pristine);\n\n      this.getComponents().forEach(function (comp) {\n        return comp.setPristine(pristine);\n      });\n    }\n  }, {\n    key: \"isPristine\",\n    get: function get() {\n      return this.pristine && this.getComponents().every(function (c) {\n        return c.isPristine;\n      });\n    }\n  }, {\n    key: \"isDirty\",\n    get: function get() {\n      return this.dirty && this.getComponents().every(function (c) {\n        return c.isDirty;\n      });\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.components.forEach(function (component) {\n        component.detach();\n      });\n\n      _get(_getPrototypeOf(NestedComponent.prototype), \"detach\", this).call(this);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.components.forEach(function (component) {\n        component.clear();\n      });\n\n      _get(_getPrototypeOf(NestedComponent.prototype), \"clear\", this).call(this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.destroyComponents();\n\n      _get(_getPrototypeOf(NestedComponent.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"destroyComponents\",\n    value: function destroyComponents() {\n      var _this11 = this;\n\n      var components = this.getComponents().slice();\n      components.forEach(function (comp) {\n        return _this11.removeComponent(comp, _this11.components);\n      });\n      this.components = [];\n    }\n  }, {\n    key: \"errors\",\n    get: function get() {\n      var thisErrors = this.error ? [this.error] : [];\n      return this.getComponents().reduce(function (errors, comp) {\n        return errors.concat(comp.errors || []);\n      }, thisErrors).filter(function (err) {\n        return err.level !== 'hidden';\n      });\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.data;\n    }\n  }, {\n    key: \"resetValue\",\n    value: function resetValue() {\n      _get(_getPrototypeOf(NestedComponent.prototype), \"resetValue\", this).call(this);\n\n      this.getComponents().forEach(function (comp) {\n        return comp.resetValue();\n      });\n      this.setPristine(true);\n    }\n  }, {\n    key: \"dataReady\",\n    get: function get() {\n      return _nativePromiseOnly.default.all(this.getComponents().map(function (component) {\n        return component.dataReady;\n      }));\n    }\n  }, {\n    key: \"setNestedValue\",\n    value: function setNestedValue(component, value) {\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      component._data = this.componentContext(component);\n\n      if (component.type === 'button') {\n        return false;\n      }\n\n      if (component.type === 'components') {\n        return component.setValue(value, flags);\n      } else if (value && component.hasValue(value)) {\n        return component.setValue(_lodash.default.get(value, component.key), flags);\n      } else if ((!this.rootPristine || component.visible) && component.shouldAddDefaultValue) {\n        flags.noValidate = !flags.dirty;\n        flags.resetValue = true;\n        return component.setValue(component.defaultValue, flags);\n      }\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      var _this12 = this;\n\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!value) {\n        return false;\n      }\n\n      if (value.submitAsDraft && !value.submit) {\n        flags.noValidate = true;\n      }\n\n      return this.getComponents().reduce(function (changed, component) {\n        return _this12.setNestedValue(component, value, flags, changed) || changed;\n      }, false);\n    }\n  }, {\n    key: \"lazyLoad\",\n    get: function get() {\n      var _this$component$lazyL;\n\n      return (_this$component$lazyL = this.component.lazyLoad) !== null && _this$component$lazyL !== void 0 ? _this$component$lazyL : false;\n    }\n  }], [{\n    key: \"schema\",\n    value: function schema() {\n      for (var _len = arguments.length, extend = new Array(_len), _key = 0; _key < _len; _key++) {\n        extend[_key] = arguments[_key];\n      }\n\n      return _Field2.default.schema.apply(_Field2.default, [{\n        tree: false,\n        lazyLoad: false\n      }].concat(extend));\n    }\n  }]);\n\n  return NestedComponent;\n}(_Field2.default);\n\nexports.default = NestedComponent;","map":null,"metadata":{},"sourceType":"script"}