{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.array.sort\");\n\nrequire(\"core-js/modules/es.math.log2\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.reflect.construct\");\n\nrequire(\"core-js/modules/es.reflect.get\");\n\nrequire(\"core-js/modules/es.regexp.constructor\");\n\nrequire(\"core-js/modules/es.regexp.exec\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _FormioAddon2 = _interopRequireDefault(require(\"../FormioAddon\"));\n\nvar _PasswordStrengthAddon = _interopRequireDefault(require(\"./PasswordStrengthAddon.form\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar PasswordStrengthAddon = /*#__PURE__*/function (_FormioAddon) {\n  _inherits(PasswordStrengthAddon, _FormioAddon);\n\n  var _super = _createSuper(PasswordStrengthAddon);\n\n  function PasswordStrengthAddon(settings, componentInstance) {\n    var _this;\n\n    _classCallCheck(this, PasswordStrengthAddon);\n\n    _this = _super.call(this, settings, componentInstance);\n    _this._entropy = 0; // Set initial value of entropy\n\n    _this.levels = _toConsumableArray(_this.settings.levels || _this.defaultSettings.levels);\n\n    _this.levels.sort(function (a, b) {\n      return a.maxEntropy - b.maxEntropy;\n    }); // Sort levels from the lowest one to the highest\n\n\n    _this.level = _this.levels[0]; // Set currnt level to the lowest one\n\n    _this.maxEntropy = _this.levels[_this.levels.length - 1].maxEntropy; // Set maximal amount of security points based on the highest level\n\n    return _this;\n  }\n\n  _createClass(PasswordStrengthAddon, [{\n    key: \"defaultSettings\",\n    get: function get() {\n      return PasswordStrengthAddon.info.defaultSettings;\n    }\n  }, {\n    key: \"rules\",\n    get: function get() {\n      var _this2 = this;\n\n      return {\n        length: {\n          check: function check(value, options) {\n            var minLength = options.minLength || _this2.component.component.validate.minLength || 6;\n\n            if (value.length < minLength) {\n              return \"Value must be longer than \".concat(minLength, \" characters\");\n            }\n\n            return true;\n          }\n        },\n        upperCase: {\n          check: function check(value) {\n            if (/[A-Z]/g.test(value)) {\n              return true;\n            }\n\n            return 'Value must contain uppercased alphabetical characters';\n          },\n          increaseCharactersPoolSize: 26\n        },\n        numeric: {\n          check: function check(value) {\n            if (/[0-9]/g.test(value)) {\n              return true;\n            }\n\n            return 'Value must contain numeric characters';\n          },\n          increaseCharactersPoolSize: 10\n        },\n        lowerCase: {\n          check: function check(value) {\n            if (/[a-z]/g.test(value)) {\n              return true;\n            }\n\n            return 'Value must contain lowercased alphabetical characters';\n          },\n          increaseCharactersPoolSize: 26\n        },\n        symbols: {\n          check: function check(value) {\n            if (/[ `!@#$%^&*()_+\\-=[\\]{};':\"\\\\|,.<>/?~]/.test(value)) {\n              return true;\n            }\n\n            return 'Value must contain symbols';\n          },\n          increaseCharactersPoolSize: 32\n        }\n      };\n    }\n  }, {\n    key: \"charactersPoolLength\",\n    get: function get() {\n      return this._charactersPoolLength;\n    },\n    set: function set(value) {\n      this._charactersPoolLength = value;\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this._level || this.getLevel();\n    },\n    set: function set(level) {\n      this._level = level;\n    }\n  }, {\n    key: \"entropy\",\n    get: function get() {\n      return this._entropy;\n    },\n    set: function set(value) {\n      var oldLevel = this.getLevel();\n      var updateOnEntropyChange = this.settings.updateOn === 'entropyChange' && this._entropy !== value;\n      this._entropy = value;\n      this.level = this.getLevel();\n      var updateOnLevelChange = this.settings.updateOn === 'levelChange' && oldLevel.name !== this.level.name;\n\n      if (updateOnLevelChange || updateOnEntropyChange) {\n        this.updateView();\n      }\n    }\n  }, {\n    key: \"dictionarySize\",\n    get: function get() {\n      return this.settings.dictionarySize || 171476;\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return this.settings.template;\n    }\n  }, {\n    key: \"tooltip\",\n    get: function get() {\n      var _this$level, _this$level2;\n\n      return ((_this$level = this.level) === null || _this$level === void 0 ? void 0 : _this$level.tooltip) || \"\".concat((_this$level2 = this.level) === null || _this$level2 === void 0 ? void 0 : _this$level2.name, \" strongness\");\n    }\n  }, {\n    key: \"rulesSettings\",\n    get: function get() {\n      return this.settings.rulesSettings || [];\n    }\n  }, {\n    key: \"customRules\",\n    get: function get() {\n      return this.settings.customRules || [];\n    }\n  }, {\n    key: \"log2\",\n    value: function log2(value) {\n      if (typeof Math.log2 === 'function') {\n        return Math.log2(value);\n      }\n\n      return Math.log(value) * Math.LOG2E;\n    }\n  }, {\n    key: \"calculatePasswordEntropy\",\n    value: function calculatePasswordEntropy(passwordLength, charactersPoolSize) {\n      return !passwordLength || !charactersPoolSize ? 0 : this.log2(Math.pow(charactersPoolSize, passwordLength));\n    }\n  }, {\n    key: \"calculatePasswordEntropyWords\",\n    value: function calculatePasswordEntropyWords(wordsCount) {\n      return !this.dictionarySize ? 0 : this.log2(this.dictionarySize) * wordsCount;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var view = this.component.interpolate(this.template, {\n        entropy: this.entropy,\n        maxEntropy: this.maxEntropy,\n        level: this.level,\n        levelName: this.level.name.replace(' ', '-').toLowerCase(),\n        levels: this.levels,\n        readOnly: this.component.options.readOnly,\n        pristine: this.component.pristine,\n        t: this.t.bind(this),\n        tooltip: this.tooltip\n      });\n      return this.component.sanitize(view);\n    }\n  }, {\n    key: \"checkBlackList\",\n    value: function checkBlackList(value) {\n      var blackList = _toConsumableArray(this.settings.blackList);\n\n      var customBlacklistedWords = this.settings.customBlacklistedWords;\n\n      if (customBlacklistedWords && typeof customBlacklistedWords === 'string') {\n        customBlacklistedWords = this.evaluate(customBlacklistedWords, this.component.evalContext({\n          value: value\n        }), 'values');\n\n        if (customBlacklistedWords && customBlacklistedWords.length) {\n          blackList.push.apply(blackList, _toConsumableArray(customBlacklistedWords));\n        }\n      }\n\n      var restValue = value;\n      var blacklistedWords = [];\n\n      for (var i = 0; i < blackList.length; i++) {\n        var word = blackList[i];\n        var regExp = new RegExp(\"\".concat(word), 'gi');\n\n        if (regExp.test(value)) {\n          blacklistedWords.push(word);\n          restValue = restValue.replace(regExp, '');\n        } // If less the 3 symboles left, just stop iterating\n\n\n        if (restValue.length < 3) {\n          break;\n        }\n      }\n\n      if (blacklistedWords.length) {\n        // If there are some random characters except of blacklisted words in the password,\n        // calculate the entropy for them\n        var _ref = restValue.length ? this.performChecks(restValue) : 0,\n            charactersPoolSize = _ref.charactersPoolSize;\n\n        var entropyOfNonblacklistedValue = this.calculatePasswordEntropy(restValue.length, charactersPoolSize); // Calculate the entropy if the biggest part of the password could be picked up from dictionary words\n\n        var dictionaryCheckEntropy = this.calculatePasswordEntropyWords(blacklistedWords.length);\n        var entropy = dictionaryCheckEntropy + entropyOfNonblacklistedValue;\n        return {\n          entropy: entropy,\n          blacklistedWords: blacklistedWords\n        };\n      }\n\n      return true;\n    }\n    /**\n     * Determines is a password is secure enough to submit\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      var isValidCheck = this.settings.isValid;\n\n      if (isValidCheck && typeof isValidCheck === 'string') {\n        var valid = this.evaluate(isValidCheck, this.component.evalContext({\n          entropy: this.entropy,\n          level: this.level\n        }), 'valid');\n        return valid;\n      }\n\n      return this.entropy >= Math.round(this.maxEntropy / 2);\n    }\n    /**\n     * Handles the result of check and constructs a new error object or returns an amount of points to add to the current entropy\n     * @param {boolean|number} valid - Determines if the validation was failed or an amount of points if it was passed\n     * @param {*} validation - Validation configuration\n     * @param {string} value - Value which was validated\n     * @param {string} message - Message which should be shown if validation was not passed\n     */\n\n  }, {\n    key: \"handleRuleCheckResult\",\n    value: function handleRuleCheckResult(valid, validation, message, errors) {\n      if (valid !== true) {\n        errors.push({\n          validation: validation.name,\n          message: message,\n          level: validation.required ? 'error' : 'warning'\n        });\n      } else if (validation.increaseCharactersPoolSize) {\n        return validation.increaseCharactersPoolSize;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"performChecks\",\n    value: function performChecks(value) {\n      var _this3 = this;\n\n      var errors = [];\n      var charactersPoolSize = 0;\n      this.rulesSettings.forEach(function (settings) {\n        if (_this3.rules[settings.name]) {\n          var rule = _lodash.default.merge({}, _this3.rules[settings.name], settings);\n\n          var valid = rule.check(value, settings.options || {});\n          var message = settings.message || valid;\n          charactersPoolSize += _this3.handleRuleCheckResult(valid, rule, message, errors);\n        }\n      });\n      this.customRules.forEach(function (rule) {\n        if (rule.check && typeof rule.check === 'string') {\n          var valid = _this3.evaluate(rule.check, _this3.component.evalContext({\n            value: value\n          }), 'valid');\n\n          var message = typeof valid === 'string' ? valid : \"Password does not meet \".concat(rule.name, \" validation\");\n          charactersPoolSize += _this3.handleRuleCheckResult(valid, rule, message, errors);\n        }\n      });\n      return {\n        charactersPoolSize: charactersPoolSize,\n        errors: errors\n      };\n    }\n    /**\n     * Performs checks to validate password security\n     * @param {string} value - Suggested password\n     */\n\n  }, {\n    key: \"checkValidity\",\n    value: function checkValidity(value) {\n      var _this$settings$blackL;\n\n      var passwordLength = value.length;\n\n      var _this$performChecks = this.performChecks(value),\n          charactersPoolSize = _this$performChecks.charactersPoolSize,\n          errors = _this$performChecks.errors;\n\n      this.errors = errors;\n      var entropy = this.calculatePasswordEntropy(passwordLength, charactersPoolSize);\n      var blackListCheck = (_this$settings$blackL = this.settings.blackList) !== null && _this$settings$blackL !== void 0 && _this$settings$blackL.length || this.settings.customBlacklistedWords ? this.checkBlackList(value) : null; // If there were found some words from the black list\n\n      if (blackListCheck && blackListCheck !== true) {\n        this.handleBlackListCheckResult(blackListCheck); // Select the mininal entropy based on the dictionary check or symbolic check\n\n        this.entropy = Math.min(entropy, blackListCheck.entropy);\n      } else {\n        this.entropy = entropy;\n      }\n\n      var isValid = this.isValid();\n\n      if (!isValid) {\n        this.errors.push({\n          message: 'Password is not strong enough',\n          level: this.settings.required ? 'error' : 'warning'\n        });\n      }\n\n      return !this.errors.length;\n    }\n  }, {\n    key: \"handleBlackListCheckResult\",\n    value: function handleBlackListCheckResult(result) {\n      var blacklistedWords = result.blacklistedWords;\n      var isRequired = this.settings.disableBlacklistedWords;\n      var message = \"Password \".concat(isRequired ? 'must' : 'should', \" not include common words: \").concat(blacklistedWords.join(', '));\n      var validation = {\n        name: 'blacklist',\n        required: isRequired\n      };\n      this.handleRuleCheckResult(false, validation, message, this.errors);\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(element) {\n      var _this4 = this;\n\n      _get(_getPrototypeOf(PasswordStrengthAddon.prototype), \"attach\", this).call(this, element);\n\n      var container = this.component.ce('div', {\n        ref: 'passwordStrengthIndicator'\n      });\n      var inserted = this.insertContainer(element, container);\n\n      if (!inserted) {\n        this.component.append(container);\n      }\n\n      this._element = container;\n      this.component.on('redraw', function () {\n        return _this4.updateView();\n      });\n      this.component.on('componentError', function () {\n        return _this4.updateView();\n      });\n      this.updateView();\n    }\n  }, {\n    key: \"insertContainer\",\n    value: function insertContainer(element, container) {\n      var _this$settings$locati, _this$settings$locati2;\n\n      if (!element || !container) {\n        return false;\n      }\n\n      var insert = (_this$settings$locati = this.settings.location) === null || _this$settings$locati === void 0 ? void 0 : _this$settings$locati.insert;\n      var selector = (_this$settings$locati2 = this.settings.location) === null || _this$settings$locati2 === void 0 ? void 0 : _this$settings$locati2.selector;\n      var reference;\n\n      if (selector) {\n        reference = element.querySelector(selector);\n      }\n\n      if (reference) {\n        var parent = reference.parentNode;\n\n        switch (insert) {\n          case 'after':\n            if (parent) {\n              parent.insertBefore(container, reference.nextSibling || null);\n              return true;\n            }\n\n            return false;\n\n          case 'before':\n            if (parent) {\n              parent.insertBefore(container, reference);\n              return true;\n            }\n\n            return false;\n\n          default:\n            console.warn(\"Unknown insert option: \".concat(insert));\n            return false;\n        }\n      } else {\n        console.warn(\"No elements found using selector: \".concat(selector));\n        return false;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(PasswordStrengthAddon.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Finds the level which one the passed entropy suits\n     * @param {number} entropy - Points of password's security\n     */\n\n  }, {\n    key: \"getLevel\",\n    value: function getLevel() {\n      var entropy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.entropy;\n      var lowestLevel = this.levels[0];\n      var prevMaxEntropy = lowestLevel.maxEntropy;\n\n      if (entropy <= lowestLevel.maxEntropy) {\n        return lowestLevel;\n      }\n\n      if (entropy >= this.maxEntropy) {\n        return this.levels[this.levels.length - 1];\n      } // Iterate through levels and find the one which the passed entropy belongs to\n\n\n      for (var i = 1; i < this.levels.length; i++) {\n        var level = this.levels[i];\n\n        if (entropy > prevMaxEntropy && entropy <= level.maxEntropy) {\n          return level;\n        }\n\n        prevMaxEntropy = level.maxEntropy;\n      }\n\n      return lowestLevel;\n    }\n    /**\n     * Update the current view of the password's security indicator\n     */\n\n  }, {\n    key: \"updateView\",\n    value: function updateView() {\n      if (!this.element) {\n        return;\n      }\n\n      var view = this.render();\n      this.element.innerHTML = view;\n    }\n  }], [{\n    key: \"info\",\n    get: function get() {\n      return {\n        supportedComponents: ['password'],\n        name: 'passwordStrength',\n        components: _PasswordStrengthAddon.default,\n        label: 'Password Strength',\n        defaultSettings: {\n          rulesSettings: [{\n            name: 'length',\n            required: false,\n            message: 'Value should be longer'\n          }, {\n            name: 'upperCase',\n            required: false,\n            message: 'Value should have uppercase letters'\n          }, {\n            name: 'numeric',\n            required: false,\n            message: 'Value should have numeric symbols'\n          }, {\n            name: 'lowerCase',\n            required: false,\n            message: 'Value should be have lowercase letters'\n          }, {\n            name: 'symbols',\n            required: false,\n            message: 'Value should have symbols'\n          }],\n          updateOn: 'levelChange',\n          required: true,\n          levels: [{\n            name: 'Low',\n            maxEntropy: 28,\n            style: 'danger'\n          }, {\n            name: 'Medium',\n            maxEntropy: 45,\n            style: 'warning'\n          }, {\n            name: 'High',\n            maxEntropy: 59,\n            style: 'info'\n          }, {\n            name: 'Very High',\n            maxEntropy: 85,\n            style: 'success'\n          }],\n          blackList: [],\n          template: \"\\n          <div class=\\\"formio-security-indicator\\\">\\n            {% if (!ctx.readOnly && !ctx.pristine) { %}\\n              <div\\n                title=\\\"{{ctx.t(ctx.tooltip)}}\\\"\\n                class=\\\"security-{{ctx.levelName}} {{ ctx.level.style ? 'bg-' + ctx.level.style : ''}}\\\"\\n                style=\\\"{{ctx.level.color ? 'background-color: ' + ctx.level.color + ';' : ''}}\\\"\\n              ></div>\\n            {% } %}\\n          </div>\\n        \",\n          location: {\n            insert: 'after',\n            selector: '[ref=\"element\"]'\n          }\n        }\n      };\n    }\n  }]);\n\n  return PasswordStrengthAddon;\n}(_FormioAddon2.default);\n\nexports.default = PasswordStrengthAddon;","map":null,"metadata":{},"sourceType":"script"}