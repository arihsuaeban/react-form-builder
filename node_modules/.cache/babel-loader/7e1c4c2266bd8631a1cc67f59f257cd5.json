{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.filter\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of\");\n\nrequire(\"core-js/modules/es.object.keys\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.reflect.construct\");\n\nrequire(\"core-js/modules/es.reflect.get\");\n\nrequire(\"core-js/modules/es.regexp.exec\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.string.trim\");\n\nrequire(\"core-js/modules/es.weak-map\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Input2 = _interopRequireDefault(require(\"../_classes/input/Input\"));\n\nvar _vanillaTextMask = require(\"@formio/vanilla-text-mask\");\n\nvar FormioUtils = _interopRequireWildcard(require(\"../../utils/utils\"));\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar TextFieldComponent = /*#__PURE__*/function (_Input) {\n  _inherits(TextFieldComponent, _Input);\n\n  var _super = _createSuper(TextFieldComponent);\n\n  function TextFieldComponent(component, options, data) {\n    var _this$component$widge, _this$component$widge2, _this$component$widge3;\n\n    var _this;\n\n    _classCallCheck(this, TextFieldComponent);\n\n    _this = _super.call(this, component, options, data);\n    var timezone = ((_this$component$widge = _this.component.widget) === null || _this$component$widge === void 0 ? void 0 : _this$component$widge.timezone) || _this.options.timezone;\n    var displayInTimezone = ((_this$component$widge2 = _this.component.widget) === null || _this$component$widge2 === void 0 ? void 0 : _this$component$widge2.displayInTimezone) || 'viewer';\n\n    if (((_this$component$widge3 = _this.component.widget) === null || _this$component$widge3 === void 0 ? void 0 : _this$component$widge3.type) === 'calendar') {\n      _this.component.widget = _objectSpread(_objectSpread({}, _this.component.widget), {}, {\n        readOnly: _this.options.readOnly,\n        timezone: timezone,\n        displayInTimezone: displayInTimezone,\n        locale: _this.options.language,\n        saveAs: 'text'\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(TextFieldComponent, [{\n    key: \"defaultSchema\",\n    get: function get() {\n      return TextFieldComponent.schema();\n    }\n  }, {\n    key: \"inputInfo\",\n    get: function get() {\n      var info = _get(_getPrototypeOf(TextFieldComponent.prototype), \"inputInfo\", this);\n\n      info.type = 'input';\n\n      if (this.component.hasOwnProperty('spellcheck')) {\n        info.attr.spellcheck = this.component.spellcheck;\n      }\n\n      if (this.component.mask) {\n        info.attr.type = 'password';\n      } else {\n        info.attr.type = this.component.inputType === 'password' ? 'password' : 'text';\n      }\n\n      info.changeEvent = 'input';\n      return info;\n    }\n  }, {\n    key: \"emptyValue\",\n    get: function get() {\n      return '';\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(element) {\n      this.loadRefs(element, {\n        valueMaskInput: 'single'\n      });\n      return _get(_getPrototypeOf(TextFieldComponent.prototype), \"attach\", this).call(this, element);\n    }\n    /**\n     * Returns the mask value object.\n     *\n     * @param value\n     * @param flags\n     * @return {*}\n     */\n\n  }, {\n    key: \"maskValue\",\n    value: function maskValue(value) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Convert it into the correct format.\n\n      if (!value || _typeof(value) !== 'object') {\n        value = {\n          value: value,\n          maskName: this.component.inputMasks[0].label\n        };\n      } // If no value is provided, then set the defaultValue.\n\n\n      if (!value.value) {\n        var defaultValue = flags.noDefault ? this.emptyValue : this.defaultValue;\n        value.value = Array.isArray(defaultValue) ? defaultValue[0] : defaultValue;\n      }\n\n      return value;\n    }\n    /**\n     * Normalize the value set in the data object.\n     *\n     * @param value\n     * @param flags\n     * @return {*}\n     */\n\n  }, {\n    key: \"normalizeValue\",\n    value: function normalizeValue(value) {\n      var _this2 = this;\n\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.isMultipleMasksField) {\n        return _get(_getPrototypeOf(TextFieldComponent.prototype), \"normalizeValue\", this).call(this, value);\n      }\n\n      if (Array.isArray(value)) {\n        return _get(_getPrototypeOf(TextFieldComponent.prototype), \"normalizeValue\", this).call(this, value.map(function (val) {\n          return _this2.maskValue(val, flags);\n        }));\n      }\n\n      return _get(_getPrototypeOf(TextFieldComponent.prototype), \"normalizeValue\", this).call(this, this.maskValue(value, flags));\n    }\n    /**\n     * Sets the value at this index.\n     *\n     * @param index\n     * @param value\n     * @param flags\n     */\n\n  }, {\n    key: \"setValueAt\",\n    value: function setValueAt(index, value) {\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!this.isMultipleMasksField) {\n        return _get(_getPrototypeOf(TextFieldComponent.prototype), \"setValueAt\", this).call(this, index, value, flags);\n      }\n\n      value = this.maskValue(value, flags);\n      var textValue = value.value || '';\n      var textInput = this.refs.mask ? this.refs.mask[index] : null;\n      var maskInput = this.refs.select ? this.refs.select[index] : null;\n      var mask = this.getMaskPattern(value.maskName);\n\n      if (textInput && maskInput && mask) {\n        var placeholderChar = this.placeholderChar;\n        textInput.value = (0, _vanillaTextMask.conformToMask)(textValue, FormioUtils.getInputMask(mask), {\n          placeholderChar: placeholderChar\n        }).conformedValue;\n        maskInput.value = value.maskName;\n      } else {\n        return _get(_getPrototypeOf(TextFieldComponent.prototype), \"setValueAt\", this).call(this, index, textValue, flags);\n      }\n    }\n  }, {\n    key: \"unmaskValue\",\n    value: function unmaskValue(value) {\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.component.displayMask;\n      var mask = FormioUtils.getInputMask(format, this.placeholderChar);\n      return FormioUtils.unmaskValue(value, mask, this.placeholderChar);\n    }\n    /**\n     * Returns the value at this index.\n     *\n     * @param index\n     * @return {*}\n     */\n\n  }, {\n    key: \"getValueAt\",\n    value: function getValueAt(index) {\n      if (!this.isMultipleMasksField) {\n        var _this$refs$valueMaskI;\n\n        var value = _get(_getPrototypeOf(TextFieldComponent.prototype), \"getValueAt\", this).call(this, index);\n\n        var valueMask = this.component.inputMask;\n        var displayMask = this.component.displayMask; // If the input has only the valueMask or the displayMask is the same as the valueMask,\n        // just return the value which is already formatted\n\n        if (valueMask && !displayMask || displayMask === valueMask) {\n          return value;\n        } // If there is only the displayMask, return the raw (unmasked) value\n\n\n        if (displayMask && !valueMask) {\n          return this.unmaskValue(value, displayMask);\n        }\n\n        if ((_this$refs$valueMaskI = this.refs.valueMaskInput) !== null && _this$refs$valueMaskI !== void 0 && _this$refs$valueMaskI.mask) {\n          var _this$refs$valueMaskI2;\n\n          this.refs.valueMaskInput.mask.textMaskInputElement.update(value);\n          return (_this$refs$valueMaskI2 = this.refs.valueMaskInput) === null || _this$refs$valueMaskI2 === void 0 ? void 0 : _this$refs$valueMaskI2.value;\n        }\n\n        return value;\n      }\n\n      var textInput = this.refs.mask ? this.refs.mask[index] : null;\n      var maskInput = this.refs.select ? this.refs.select[index] : null;\n      return {\n        value: textInput ? textInput.value : undefined,\n        maskName: maskInput ? maskInput.value : undefined\n      };\n    }\n  }, {\n    key: \"isHtmlRenderMode\",\n    value: function isHtmlRenderMode() {\n      return _get(_getPrototypeOf(TextFieldComponent.prototype), \"isHtmlRenderMode\", this).call(this) || (this.options.readOnly || this.disabled) && this.component.inputFormat === 'html' && this.type === 'textfield';\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dataValue;\n\n      if (!this.isMultipleMasksField) {\n        return _get(_getPrototypeOf(TextFieldComponent.prototype), \"isEmpty\", this).call(this, (value || '').toString().trim());\n      }\n\n      return _get(_getPrototypeOf(TextFieldComponent.prototype), \"isEmpty\", this).call(this, value) || (this.component.multiple ? value.length === 0 : !value.maskName || !value.value);\n    }\n  }, {\n    key: \"truncateMultipleSpaces\",\n    value: function truncateMultipleSpaces(value) {\n      if (value) {\n        return value.trim().replace(/\\s{2,}/g, ' ');\n      }\n\n      return value;\n    }\n  }, {\n    key: \"validationValue\",\n    get: function get() {\n      var value = _get(_getPrototypeOf(TextFieldComponent.prototype), \"validationValue\", this);\n\n      if (value && this.component.truncateMultipleSpaces) {\n        return this.truncateMultipleSpaces(value);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"beforeSubmit\",\n    value: function beforeSubmit() {\n      var _this3 = this;\n\n      var value = this.dataValue;\n\n      if (!this.component.truncateMultipleSpaces || !value) {\n        return _nativePromiseOnly.default.resolve(value);\n      }\n\n      value = this.truncateMultipleSpaces(value);\n      this.dataValue = value;\n      return _nativePromiseOnly.default.resolve(value).then(function () {\n        return _get(_getPrototypeOf(TextFieldComponent.prototype), \"beforeSubmit\", _this3).call(_this3);\n      });\n    }\n  }], [{\n    key: \"schema\",\n    value: function schema() {\n      for (var _len = arguments.length, extend = new Array(_len), _key = 0; _key < _len; _key++) {\n        extend[_key] = arguments[_key];\n      }\n\n      return _Input2.default.schema.apply(_Input2.default, [{\n        label: 'Text Field',\n        key: 'textField',\n        type: 'textfield',\n        mask: false,\n        inputType: 'text',\n        inputFormat: 'plain',\n        inputMask: '',\n        displayMask: '',\n        tableView: true,\n        spellcheck: true,\n        truncateMultipleSpaces: false,\n        validate: {\n          minLength: '',\n          maxLength: '',\n          pattern: ''\n        }\n      }].concat(extend));\n    }\n  }, {\n    key: \"builderInfo\",\n    get: function get() {\n      return {\n        title: 'Text Field',\n        icon: 'terminal',\n        group: 'basic',\n        documentation: '/userguide/#textfield',\n        weight: 0,\n        schema: TextFieldComponent.schema()\n      };\n    }\n  }]);\n\n  return TextFieldComponent;\n}(_Input2.default);\n\nexports.default = TextFieldComponent;","map":null,"metadata":{},"sourceType":"script"}