{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.find\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.number.constructor\");\n\nrequire(\"core-js/modules/es.object.assign\");\n\nrequire(\"core-js/modules/es.object.keys\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.regexp.constructor\");\n\nrequire(\"core-js/modules/es.regexp.exec\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.includes\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.match\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.string.split\");\n\nrequire(\"core-js/modules/es.string.starts-with\");\n\nrequire(\"core-js/modules/es.string.trim\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  evaluate: true,\n  getRandomComponentId: true,\n  getPropertyValue: true,\n  getElementRect: true,\n  boolValue: true,\n  isMongoId: true,\n  checkCalculated: true,\n  checkSimpleConditional: true,\n  checkCustomConditional: true,\n  checkJsonConditional: true,\n  checkCondition: true,\n  checkTrigger: true,\n  setActionProperty: true,\n  unescapeHTML: true,\n  convertStringToHTMLElement: true,\n  uniqueName: true,\n  guid: true,\n  getDateSetting: true,\n  isValidDate: true,\n  currentTimezone: true,\n  offsetDate: true,\n  zonesLoaded: true,\n  shouldLoadZones: true,\n  loadZones: true,\n  momentDate: true,\n  formatDate: true,\n  formatOffset: true,\n  getLocaleDateFormatInfo: true,\n  convertFormatToFlatpickr: true,\n  convertFormatToMoment: true,\n  convertFormatToMask: true,\n  getInputMask: true,\n  unmaskValue: true,\n  matchInputMask: true,\n  getNumberSeparators: true,\n  getNumberDecimalLimit: true,\n  getCurrencyAffixes: true,\n  fieldData: true,\n  delay: true,\n  iterateKey: true,\n  uniqueKey: true,\n  bootstrapVersion: true,\n  unfold: true,\n  firstNonNil: true,\n  withSwitch: true,\n  observeOverload: true,\n  getContextComponents: true,\n  getContextButtons: true,\n  translateHTMLTemplate: true,\n  sanitize: true,\n  fastCloneDeep: true,\n  interpolate: true,\n  isInputComponent: true,\n  getArrayFromComponentPath: true,\n  hasInvalidComponent: true,\n  getStringFromComponentPath: true,\n  round: true,\n  getIEBrowserVersion: true,\n  getBrowserInfo: true,\n  getComponentPathWithoutIndicies: true,\n  getComponentPath: true,\n  getDataParentComponent: true,\n  isPromise: true,\n  isInsideScopingComponent: true,\n  getFocusableElements: true,\n  _: true,\n  jsonLogic: true,\n  moment: true,\n  Evaluator: true\n};\nObject.defineProperty(exports, \"Evaluator\", {\n  enumerable: true,\n  get: function get() {\n    return _Evaluator.default;\n  }\n});\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function get() {\n    return _lodash.default;\n  }\n});\nexports.boolValue = boolValue;\nexports.bootstrapVersion = bootstrapVersion;\nexports.checkCalculated = checkCalculated;\nexports.checkCondition = checkCondition;\nexports.checkCustomConditional = checkCustomConditional;\nexports.checkJsonConditional = checkJsonConditional;\nexports.checkSimpleConditional = checkSimpleConditional;\nexports.checkTrigger = checkTrigger;\nexports.convertFormatToFlatpickr = convertFormatToFlatpickr;\nexports.convertFormatToMask = convertFormatToMask;\nexports.convertFormatToMoment = convertFormatToMoment;\nexports.convertStringToHTMLElement = convertStringToHTMLElement;\nexports.currentTimezone = currentTimezone;\nexports.delay = delay;\nexports.evaluate = evaluate;\nexports.fastCloneDeep = fastCloneDeep;\nexports.fieldData = fieldData;\nexports.firstNonNil = void 0;\nexports.formatDate = formatDate;\nexports.formatOffset = formatOffset;\nexports.getArrayFromComponentPath = getArrayFromComponentPath;\nexports.getBrowserInfo = getBrowserInfo;\nexports.getComponentPath = getComponentPath;\nexports.getComponentPathWithoutIndicies = getComponentPathWithoutIndicies;\nexports.getContextButtons = getContextButtons;\nexports.getContextComponents = getContextComponents;\nexports.getCurrencyAffixes = getCurrencyAffixes;\nexports.getDataParentComponent = getDataParentComponent;\nexports.getDateSetting = getDateSetting;\nexports.getElementRect = getElementRect;\nexports.getFocusableElements = getFocusableElements;\nexports.getIEBrowserVersion = getIEBrowserVersion;\nexports.getInputMask = getInputMask;\nexports.getLocaleDateFormatInfo = getLocaleDateFormatInfo;\nexports.getNumberDecimalLimit = getNumberDecimalLimit;\nexports.getNumberSeparators = getNumberSeparators;\nexports.getPropertyValue = getPropertyValue;\nexports.getRandomComponentId = getRandomComponentId;\nexports.getStringFromComponentPath = getStringFromComponentPath;\nexports.guid = guid;\nexports.hasInvalidComponent = hasInvalidComponent;\nexports.interpolate = void 0;\nexports.isInputComponent = isInputComponent;\nexports.isInsideScopingComponent = isInsideScopingComponent;\nexports.isMongoId = isMongoId;\nexports.isPromise = isPromise;\nexports.isValidDate = isValidDate;\nexports.iterateKey = iterateKey;\nObject.defineProperty(exports, \"jsonLogic\", {\n  enumerable: true,\n  get: function get() {\n    return _jsonLogicJs.default;\n  }\n});\nexports.loadZones = loadZones;\nexports.matchInputMask = matchInputMask;\nObject.defineProperty(exports, \"moment\", {\n  enumerable: true,\n  get: function get() {\n    return _momentTimezone.default;\n  }\n});\nexports.momentDate = momentDate;\nexports.observeOverload = observeOverload;\nexports.offsetDate = offsetDate;\nexports.round = round;\nexports.sanitize = sanitize;\nexports.setActionProperty = setActionProperty;\nexports.shouldLoadZones = shouldLoadZones;\nexports.translateHTMLTemplate = translateHTMLTemplate;\nexports.unescapeHTML = unescapeHTML;\nexports.unfold = unfold;\nexports.uniqueKey = uniqueKey;\nexports.uniqueName = uniqueName;\nexports.unmaskValue = unmaskValue;\nexports.withSwitch = withSwitch;\nexports.zonesLoaded = zonesLoaded;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _fetchPonyfill2 = _interopRequireDefault(require(\"fetch-ponyfill\"));\n\nvar _jsonLogicJs = _interopRequireDefault(require(\"json-logic-js\"));\n\nvar _momentTimezone = _interopRequireDefault(require(\"moment-timezone/moment-timezone\"));\n\nvar _jstimezonedetect = _interopRequireDefault(require(\"jstimezonedetect\"));\n\nvar _operators = require(\"./jsonlogic/operators\");\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nvar _dompurify = _interopRequireDefault(require(\"dompurify\"));\n\nvar _formUtils = require(\"./formUtils\");\n\nObject.keys(_formUtils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _formUtils[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _formUtils[key];\n    }\n  });\n});\n\nvar _Evaluator = _interopRequireDefault(require(\"./Evaluator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nvar interpolate = _Evaluator.default.interpolate;\nexports.interpolate = interpolate;\n\nvar _fetchPonyfill = (0, _fetchPonyfill2.default)({\n  Promise: _nativePromiseOnly.default\n}),\n    fetch = _fetchPonyfill.fetch; // Configure JsonLogic\n\n\n_operators.lodashOperators.forEach(function (name) {\n  return _jsonLogicJs.default.add_operation(\"_\".concat(name), _lodash.default[name]);\n}); // Retrieve Any Date\n\n\n_jsonLogicJs.default.add_operation('getDate', function (date) {\n  return (0, _momentTimezone.default)(date).toISOString();\n}); // Set Relative Minimum Date\n\n\n_jsonLogicJs.default.add_operation('relativeMinDate', function (relativeMinDate) {\n  return (0, _momentTimezone.default)().subtract(relativeMinDate, 'days').toISOString();\n}); // Set Relative Maximum Date\n\n\n_jsonLogicJs.default.add_operation('relativeMaxDate', function (relativeMaxDate) {\n  return (0, _momentTimezone.default)().add(relativeMaxDate, 'days').toISOString();\n});\n\nfunction setPathToComponentAndPerentSchema(component) {\n  component.path = getComponentPath(component);\n  var dataParent = getDataParentComponent(component);\n\n  if (dataParent && _typeof(dataParent) === 'object') {\n    dataParent.path = getComponentPath(dataParent);\n  }\n}\n/**\n * Evaluate a method.\n *\n * @param func\n * @param args\n * @return {*}\n */\n\n\nfunction evaluate(func, args, ret, tokenize) {\n  var returnVal = null;\n  var component = args.component ? args.component : {\n    key: 'unknown'\n  };\n\n  if (!args.form && args.instance) {\n    args.form = _lodash.default.get(args.instance, 'root._form', {});\n  }\n\n  var componentKey = component.key;\n\n  if (typeof func === 'string') {\n    if (ret) {\n      func += \";return \".concat(ret);\n    }\n\n    if (tokenize) {\n      // Replace all {{ }} references with actual data.\n      func = func.replace(/({{\\s+(.*)\\s+}})/, function (match, $1, $2) {\n        if ($2.indexOf('data.') === 0) {\n          return _lodash.default.get(args.data, $2.replace('data.', ''));\n        } else if ($2.indexOf('row.') === 0) {\n          return _lodash.default.get(args.row, $2.replace('row.', ''));\n        } // Support legacy...\n\n\n        return _lodash.default.get(args.data, $2);\n      });\n    }\n\n    try {\n      func = _Evaluator.default.evaluator(func, args);\n      args = _lodash.default.values(args);\n    } catch (err) {\n      console.warn(\"An error occured within the custom function for \".concat(componentKey), err);\n      returnVal = null;\n      func = false;\n    }\n  }\n\n  if (typeof func === 'function') {\n    try {\n      returnVal = _Evaluator.default.evaluate(func, args);\n    } catch (err) {\n      returnVal = null;\n      console.warn(\"An error occured within custom function for \".concat(componentKey), err);\n    }\n  } else if (_typeof(func) === 'object') {\n    try {\n      returnVal = _jsonLogicJs.default.apply(func, args);\n    } catch (err) {\n      returnVal = null;\n      console.warn(\"An error occured within custom function for \".concat(componentKey), err);\n    }\n  } else if (func) {\n    console.warn(\"Unknown function type for \".concat(componentKey));\n  }\n\n  return returnVal;\n}\n\nfunction getRandomComponentId() {\n  return \"e\".concat(Math.random().toString(36).substring(7));\n}\n/**\n * Get a property value of an element.\n *\n * @param style\n * @param prop\n * @return {number}\n */\n\n\nfunction getPropertyValue(style, prop) {\n  var value = style.getPropertyValue(prop);\n  value = value ? value.replace(/[^0-9.]/g, '') : '0';\n  return parseFloat(value);\n}\n/**\n * Get an elements bounding rectagle.\n *\n * @param element\n * @return {{x: string, y: string, width: string, height: string}}\n */\n\n\nfunction getElementRect(element) {\n  var style = window.getComputedStyle(element, null);\n  return {\n    x: getPropertyValue(style, 'left'),\n    y: getPropertyValue(style, 'top'),\n    width: getPropertyValue(style, 'width'),\n    height: getPropertyValue(style, 'height')\n  };\n}\n/**\n * Determines the boolean value of a setting.\n *\n * @param value\n * @return {boolean}\n */\n\n\nfunction boolValue(value) {\n  if (_lodash.default.isBoolean(value)) {\n    return value;\n  } else if (_lodash.default.isString(value)) {\n    return value.toLowerCase() === 'true';\n  } else {\n    return !!value;\n  }\n}\n/**\n * Check to see if an ID is a mongoID.\n * @param text\n * @return {Array|{index: number, input: string}|Boolean|*}\n */\n\n\nfunction isMongoId(text) {\n  return text.toString().match(/^[0-9a-fA-F]{24}$/);\n}\n/**\n * Checks the calculated value for a provided component and data.\n *\n * @param {Object} component\n *   The component to check for the calculated value.\n * @param {Object} submission\n *   A submission object.\n * @param data\n *   The full submission data.\n */\n\n\nfunction checkCalculated(component, submission, rowData) {\n  // Process calculated value stuff if present.\n  if (component.calculateValue) {\n    _lodash.default.set(rowData, component.key, evaluate(component.calculateValue, {\n      value: undefined,\n      data: submission ? submission.data : rowData,\n      row: rowData,\n      util: this,\n      component: component\n    }, 'value'));\n  }\n}\n/**\n * Check if a simple conditional evaluates to true.\n *\n * @param condition\n * @param condition\n * @param row\n * @param data\n * @returns {boolean}\n */\n\n\nfunction checkSimpleConditional(component, condition, row, data) {\n  var value = null;\n\n  if (row) {\n    value = (0, _formUtils.getValue)({\n      data: row\n    }, condition.when);\n  }\n\n  if (data && _lodash.default.isNil(value)) {\n    value = (0, _formUtils.getValue)({\n      data: data\n    }, condition.when);\n  } // FOR-400 - Fix issue where falsey values were being evaluated as show=true\n\n\n  if (_lodash.default.isNil(value)) {\n    value = '';\n  }\n\n  var eq = String(condition.eq);\n  var show = String(condition.show); // Special check for selectboxes component.\n\n  if (_lodash.default.isObject(value) && _lodash.default.has(value, condition.eq)) {\n    return String(value[condition.eq]) === show;\n  } // FOR-179 - Check for multiple values.\n\n\n  if (Array.isArray(value) && value.map(String).includes(eq)) {\n    return show === 'true';\n  }\n\n  return String(value) === eq === (show === 'true');\n}\n/**\n * Check custom javascript conditional.\n *\n * @param component\n * @param custom\n * @param row\n * @param data\n * @returns {*}\n */\n\n\nfunction checkCustomConditional(component, custom, row, data, form, variable, onError, instance) {\n  if (typeof custom === 'string') {\n    custom = \"var \".concat(variable, \" = true; \").concat(custom, \"; return \").concat(variable, \";\");\n  }\n\n  var value = instance && instance.evaluate ? instance.evaluate(custom, {\n    row: row,\n    data: data,\n    form: form\n  }) : evaluate(custom, {\n    row: row,\n    data: data,\n    form: form\n  });\n\n  if (value === null) {\n    return onError;\n  }\n\n  return value;\n}\n\nfunction checkJsonConditional(component, json, row, data, form, onError) {\n  try {\n    return _jsonLogicJs.default.apply(json, {\n      data: data,\n      row: row,\n      form: form,\n      _: _lodash.default\n    });\n  } catch (err) {\n    console.warn(\"An error occurred in jsonLogic advanced condition for \".concat(component.key), err);\n    return onError;\n  }\n}\n\nfunction getRow(component, row, instance, conditional) {\n  var _condition$when;\n\n  var condition = conditional || component.conditional; // If no component's instance passed (happens only in 6.x server), calculate its path based on the schema\n\n  if (!instance) {\n    instance = _lodash.default.cloneDeep(component);\n    setPathToComponentAndPerentSchema(instance);\n  }\n\n  var dataParent = getDataParentComponent(instance);\n  var parentPath = dataParent ? getComponentPath(dataParent) : null;\n\n  if (dataParent && (_condition$when = condition.when) !== null && _condition$when !== void 0 && _condition$when.startsWith(parentPath)) {\n    var newRow = {};\n\n    _lodash.default.set(newRow, parentPath, row);\n\n    row = newRow;\n  }\n\n  return row;\n}\n/**\n * Checks the conditions for a provided component and data.\n *\n * @param component\n *   The component to check for the condition.\n * @param row\n *   The data within a row\n * @param data\n *   The full submission data.\n *\n * @returns {boolean}\n */\n\n\nfunction checkCondition(component, row, data, form, instance) {\n  var customConditional = component.customConditional,\n      conditional = component.conditional;\n\n  if (customConditional) {\n    return checkCustomConditional(component, customConditional, row, data, form, 'show', true, instance);\n  } else if (conditional && conditional.when) {\n    row = getRow(component, row, instance);\n    return checkSimpleConditional(component, conditional, row, data);\n  } else if (conditional && conditional.json) {\n    return checkJsonConditional(component, conditional.json, row, data, form, true);\n  } // Default to show.\n\n\n  return true;\n}\n/**\n * Test a trigger on a component.\n *\n * @param component\n * @param action\n * @param data\n * @param row\n * @returns {mixed}\n */\n\n\nfunction checkTrigger(component, trigger, row, data, form, instance) {\n  // If trigger is empty, don't fire it\n  if (!trigger[trigger.type]) {\n    return false;\n  }\n\n  switch (trigger.type) {\n    case 'simple':\n      row = getRow(component, row, instance, trigger.simple);\n      return checkSimpleConditional(component, trigger.simple, row, data);\n\n    case 'javascript':\n      return checkCustomConditional(component, trigger.javascript, row, data, form, 'result', false, instance);\n\n    case 'json':\n      return checkJsonConditional(component, trigger.json, row, data, form, false);\n  } // If none of the types matched, don't fire the trigger.\n\n\n  return false;\n}\n\nfunction setActionProperty(component, action, result, row, data, instance) {\n  var property = action.property.value;\n\n  switch (action.property.type) {\n    case 'boolean':\n      {\n        var currentValue = _lodash.default.get(component, property, false).toString();\n\n        var newValue = action.state.toString();\n\n        if (currentValue !== newValue) {\n          _lodash.default.set(component, property, newValue === 'true');\n        }\n\n        break;\n      }\n\n    case 'string':\n      {\n        var evalData = {\n          data: data,\n          row: row,\n          component: component,\n          result: result\n        };\n        var textValue = action.property.component ? action[action.property.component] : action.text;\n\n        var _currentValue = _lodash.default.get(component, property, '');\n\n        var _newValue = instance && instance.interpolate ? instance.interpolate(textValue, evalData) : _Evaluator.default.interpolate(textValue, evalData);\n\n        if (_newValue !== _currentValue) {\n          _lodash.default.set(component, property, _newValue);\n        }\n\n        break;\n      }\n  }\n\n  return component;\n}\n/**\n * Unescape HTML characters like &lt, &gt, &amp and etc.\n * @param str\n * @returns {string}\n */\n\n\nfunction unescapeHTML(str) {\n  if (typeof window === 'undefined' || !('DOMParser' in window)) {\n    return str;\n  }\n\n  var doc = new window.DOMParser().parseFromString(str, 'text/html');\n  return doc.documentElement.textContent;\n}\n/**\n * Make HTML element from string\n * @param str\n * @param selector\n * @returns {HTMLElement}\n */\n\n\nfunction convertStringToHTMLElement(str, selector) {\n  var doc = new window.DOMParser().parseFromString(str, 'text/html');\n  return doc.body.querySelector(selector);\n}\n/**\n * Make a filename guaranteed to be unique.\n * @param name\n * @param template\n * @param evalContext\n * @returns {string}\n */\n\n\nfunction uniqueName(name, template, evalContext) {\n  template = template || '{{fileName}}-{{guid}}'; //include guid in template anyway, to prevent overwriting issue if filename matches existing file\n\n  if (!template.includes('{{guid}}')) {\n    template = \"\".concat(template, \"-{{guid}}\");\n  }\n\n  var parts = name.split('.');\n  var fileName = parts.slice(0, parts.length - 1).join('.');\n  var extension = parts.length > 1 ? \".\".concat(_lodash.default.last(parts)) : ''; //allow only 100 characters from original name to avoid issues with filename length restrictions\n\n  fileName = fileName.substr(0, 100);\n  evalContext = Object.assign(evalContext || {}, {\n    fileName: fileName,\n    guid: guid()\n  }); //only letters, numbers, dots, dashes, underscores and spaces are allowed. Anything else will be replaced with dash\n\n  var uniqueName = \"\".concat(_Evaluator.default.interpolate(template, evalContext)).concat(extension).replace(/[^0-9a-zA-Z.\\-_ ]/g, '-');\n  return uniqueName;\n}\n\nfunction guid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * Return a translated date setting.\n *\n * @param date\n * @return {(null|Date)}\n */\n\n\nfunction getDateSetting(date) {\n  if (_lodash.default.isNil(date) || _lodash.default.isNaN(date) || date === '') {\n    return null;\n  }\n\n  if (date instanceof Date) {\n    return date;\n  } else if (typeof date.toDate === 'function') {\n    return date.isValid() ? date.toDate() : null;\n  }\n\n  var dateSetting = typeof date !== 'string' || date.indexOf('moment(') === -1 ? (0, _momentTimezone.default)(date) : null;\n\n  if (dateSetting && dateSetting.isValid()) {\n    return dateSetting.toDate();\n  }\n\n  dateSetting = null;\n\n  try {\n    var value = _Evaluator.default.evaluator(\"return \".concat(date, \";\"), 'moment')(_momentTimezone.default);\n\n    if (typeof value === 'string') {\n      dateSetting = (0, _momentTimezone.default)(value);\n    } else if (typeof value.toDate === 'function') {\n      dateSetting = (0, _momentTimezone.default)(value.toDate().toUTCString());\n    } else if (value instanceof Date) {\n      dateSetting = (0, _momentTimezone.default)(value);\n    }\n  } catch (e) {\n    return null;\n  }\n\n  if (!dateSetting) {\n    return null;\n  } // Ensure this is a date.\n\n\n  if (!dateSetting.isValid()) {\n    return null;\n  }\n\n  return dateSetting.toDate();\n}\n\nfunction isValidDate(date) {\n  return _lodash.default.isDate(date) && !_lodash.default.isNaN(date.getDate());\n}\n/**\n * Get the current timezone string.\n *\n * @return {string}\n */\n\n\nfunction currentTimezone() {\n  if (_momentTimezone.default.currentTimezone) {\n    return _momentTimezone.default.currentTimezone;\n  }\n\n  _momentTimezone.default.currentTimezone = _jstimezonedetect.default.determine().name();\n  return _momentTimezone.default.currentTimezone;\n}\n/**\n * Get an offset date provided a date object and timezone object.\n *\n * @param date\n * @param timezone\n * @return {Date}\n */\n\n\nfunction offsetDate(date, timezone) {\n  if (timezone === 'UTC') {\n    return {\n      date: new Date(date.getTime() + date.getTimezoneOffset() * 60000),\n      abbr: 'UTC'\n    };\n  }\n\n  var dateMoment = (0, _momentTimezone.default)(date).tz(timezone);\n  return {\n    date: new Date(date.getTime() + (dateMoment.utcOffset() + date.getTimezoneOffset()) * 60000),\n    abbr: dateMoment.format('z')\n  };\n}\n/**\n * Returns if the zones are loaded.\n *\n * @return {boolean}\n */\n\n\nfunction zonesLoaded() {\n  return _momentTimezone.default.zonesLoaded;\n}\n/**\n * Returns if we should load the zones.\n *\n * @param timezone\n * @return {boolean}\n */\n\n\nfunction shouldLoadZones(timezone) {\n  if (timezone === currentTimezone() || timezone === 'UTC') {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Externally load the timezone data.\n *\n * @return {Promise<any> | *}\n */\n\n\nfunction loadZones(timezone) {\n  if (timezone && !shouldLoadZones(timezone)) {\n    // Return non-resolving promise.\n    return new _nativePromiseOnly.default(_lodash.default.noop);\n  }\n\n  if (_momentTimezone.default.zonesPromise) {\n    return _momentTimezone.default.zonesPromise;\n  }\n\n  return _momentTimezone.default.zonesPromise = fetch('https://cdn.form.io/moment-timezone/data/packed/latest.json').then(function (resp) {\n    return resp.json().then(function (zones) {\n      _momentTimezone.default.tz.load(zones);\n\n      _momentTimezone.default.zonesLoaded = true; // Trigger a global event that the timezones have finished loading.\n\n      if (document && document.createEvent && document.body && document.body.dispatchEvent) {\n        var event = document.createEvent('Event');\n        event.initEvent('zonesLoaded', true, true);\n        document.body.dispatchEvent(event);\n      }\n    });\n  });\n}\n/**\n * Get the moment date object for translating dates with timezones.\n *\n * @param value\n * @param format\n * @param timezone\n * @return {*}\n */\n\n\nfunction momentDate(value, format, timezone) {\n  var momentDate = (0, _momentTimezone.default)(value);\n\n  if (timezone === 'UTC') {\n    timezone = 'Etc/UTC';\n  }\n\n  if ((timezone !== currentTimezone() || format && format.match(/\\s(z$|z\\s)/)) && _momentTimezone.default.zonesLoaded) {\n    return momentDate.tz(timezone);\n  }\n\n  return momentDate;\n}\n/**\n * Format a date provided a value, format, and timezone object.\n *\n * @param value\n * @param format\n * @param timezone\n * @return {string}\n */\n\n\nfunction formatDate(value, format, timezone, flatPickrInputFormat) {\n  var momentDate = (0, _momentTimezone.default)(value, flatPickrInputFormat || undefined);\n\n  if (timezone === currentTimezone()) {\n    // See if our format contains a \"z\" timezone character.\n    if (format.match(/\\s(z$|z\\s)/)) {\n      loadZones();\n\n      if (_momentTimezone.default.zonesLoaded) {\n        return momentDate.tz(timezone).format(convertFormatToMoment(format));\n      } else {\n        return momentDate.format(convertFormatToMoment(format.replace(/\\s(z$|z\\s)/, '')));\n      }\n    } // Return the standard format.\n\n\n    return momentDate.format(convertFormatToMoment(format));\n  }\n\n  if (timezone === 'UTC') {\n    var offset = offsetDate(momentDate.toDate(), 'UTC');\n    return \"\".concat((0, _momentTimezone.default)(offset.date).format(convertFormatToMoment(format)), \" UTC\");\n  } // Load the zones since we need timezone information.\n\n\n  loadZones();\n\n  if (_momentTimezone.default.zonesLoaded && timezone) {\n    return momentDate.tz(timezone).format(\"\".concat(convertFormatToMoment(format), \" z\"));\n  } else {\n    return momentDate.format(convertFormatToMoment(format));\n  }\n}\n/**\n * Pass a format function to format within a timezone.\n *\n * @param formatFn\n * @param date\n * @param format\n * @param timezone\n * @return {string}\n */\n\n\nfunction formatOffset(formatFn, date, format, timezone) {\n  if (timezone === currentTimezone()) {\n    return formatFn(date, format);\n  }\n\n  if (timezone === 'UTC') {\n    return \"\".concat(formatFn(offsetDate(date, 'UTC').date, format), \" UTC\");\n  } // Load the zones since we need timezone information.\n\n\n  loadZones();\n\n  if (_momentTimezone.default.zonesLoaded) {\n    var offset = offsetDate(date, timezone);\n    return \"\".concat(formatFn(offset.date, format), \" \").concat(offset.abbr);\n  } else {\n    return formatFn(date, format);\n  }\n}\n\nfunction getLocaleDateFormatInfo(locale) {\n  var formatInfo = {};\n  var day = 21;\n  var exampleDate = new Date(2017, 11, day);\n  var localDateString = exampleDate.toLocaleDateString(locale);\n  formatInfo.dayFirst = localDateString.slice(0, 2) === day.toString();\n  return formatInfo;\n}\n/**\n * Convert the format from the angular-datepicker module to flatpickr format.\n * @param format\n * @return {string}\n */\n\n\nfunction convertFormatToFlatpickr(format) {\n  return format // Remove the Z timezone offset, not supported by flatpickr.\n  .replace(/Z/g, '') // Year conversion.\n  .replace(/y/g, 'Y').replace('YYYY', 'Y').replace('YY', 'y') // Month conversion.\n  .replace('MMMM', 'F').replace(/M/g, 'n').replace('nnn', 'M').replace('nn', 'm') // Day in month.\n  .replace(/d/g, 'j').replace(/jj/g, 'd') // Day in week.\n  .replace('EEEE', 'l').replace('EEE', 'D') // Hours, minutes, seconds\n  .replace('HH', 'H').replace('hh', 'G').replace('mm', 'i').replace('ss', 'S').replace(/a/g, 'K');\n}\n/**\n * Convert the format from the angular-datepicker module to moment format.\n * @param format\n * @return {string}\n */\n\n\nfunction convertFormatToMoment(format) {\n  return format // Year conversion.\n  .replace(/y/g, 'Y') // Day in month.\n  .replace(/d/g, 'D') // Day in week.\n  .replace(/E/g, 'd') // AM/PM marker\n  .replace(/a/g, 'A') // Unix Timestamp\n  .replace(/U/g, 'X');\n}\n\nfunction convertFormatToMask(format) {\n  return format // Long month replacement.\n  .replace(/M{4}/g, 'MM') // Initial short month conversion.\n  .replace(/M{3}/g, '***') // Short month conversion if input as text.\n  .replace(/e/g, 'Q') // Year conversion.\n  .replace(/[ydhmsHMG]/g, '9') // AM/PM conversion.\n  .replace(/a/g, 'AA');\n}\n/**\n * Returns an input mask that is compatible with the input mask library.\n * @param {string} mask - The Form.io input mask.\n * @param {string} placeholderChar - Char which is used as a placeholder.\n * @returns {Array} - The input mask for the mask library.\n */\n\n\nfunction getInputMask(mask, placeholderChar) {\n  if (mask instanceof Array) {\n    return mask;\n  }\n\n  var maskArray = [];\n  maskArray.numeric = true;\n\n  for (var i = 0; i < mask.length; i++) {\n    switch (mask[i]) {\n      case '9':\n        maskArray.push(/\\d/);\n        break;\n\n      case 'A':\n        maskArray.numeric = false;\n        maskArray.push(/[a-zA-Z]/);\n        break;\n\n      case 'a':\n        maskArray.numeric = false;\n        maskArray.push(/[a-z]/);\n        break;\n\n      case '*':\n        maskArray.numeric = false;\n        maskArray.push(/[a-zA-Z0-9]/);\n        break;\n      // If char which is used inside mask placeholder was used in the mask, replace it with space to prevent errors\n\n      case placeholderChar:\n        maskArray.numeric = false;\n        maskArray.push(' ');\n        break;\n\n      default:\n        maskArray.numeric = false;\n        maskArray.push(mask[i]);\n        break;\n    }\n  }\n\n  return maskArray;\n}\n\nfunction unmaskValue(value, mask, placeholderChar) {\n  if (!mask || !value || value.length > mask.length) {\n    return value;\n  }\n\n  var unmaskedValue = value.split('');\n\n  for (var i = 0; i < mask.length; i++) {\n    var char = value[i] || '';\n    var charPart = mask[i];\n\n    if (!_lodash.default.isRegExp(charPart) && char === charPart) {\n      unmaskedValue[i] = '';\n    }\n  }\n\n  unmaskedValue = unmaskedValue.join('').replace(placeholderChar, '');\n  return unmaskedValue;\n}\n\nfunction matchInputMask(value, inputMask) {\n  if (!inputMask) {\n    return true;\n  } // If value is longer than mask, it isn't valid.\n\n\n  if (value.length > inputMask.length) {\n    return false;\n  }\n\n  for (var i = 0; i < inputMask.length; i++) {\n    var char = value[i] || '';\n    var charPart = inputMask[i];\n\n    if (!(_lodash.default.isRegExp(charPart) && charPart.test(char) || charPart === char)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getNumberSeparators() {\n  var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'en';\n  var formattedNumberString = 12345.6789.toLocaleString(lang);\n  var delimeters = formattedNumberString.match(/..(.)...(.)../);\n\n  if (!delimeters) {\n    return {\n      delimiter: ',',\n      decimalSeparator: '.'\n    };\n  }\n\n  return {\n    delimiter: delimeters.length > 1 ? delimeters[1] : ',',\n    decimalSeparator: delimeters.length > 2 ? delimeters[2] : '.'\n  };\n}\n\nfunction getNumberDecimalLimit(component, defaultLimit) {\n  if (_lodash.default.has(component, 'decimalLimit')) {\n    return _lodash.default.get(component, 'decimalLimit');\n  } // Determine the decimal limit. Defaults to 20 but can be overridden by validate.step or decimalLimit settings.\n\n\n  var decimalLimit = defaultLimit || 20;\n\n  var step = _lodash.default.get(component, 'validate.step', 'any');\n\n  if (step !== 'any') {\n    var parts = step.toString().split('.');\n\n    if (parts.length > 1) {\n      decimalLimit = parts[1].length;\n    }\n  }\n\n  return decimalLimit;\n}\n\nfunction getCurrencyAffixes(_ref) {\n  var _ref$currency = _ref.currency,\n      currency = _ref$currency === void 0 ? 'USD' : _ref$currency,\n      decimalLimit = _ref.decimalLimit,\n      decimalSeparator = _ref.decimalSeparator,\n      lang = _ref.lang; // Get the prefix and suffix from the localized string.\n\n  var regex = \"(.*)?\".concat(100 .toLocaleString(lang));\n\n  if (decimalLimit) {\n    regex += \"\".concat(decimalSeparator === '.' ? '\\\\.' : decimalSeparator).concat(0 .toLocaleString(lang), \"{\").concat(decimalLimit, \"}\");\n  }\n\n  regex += '(.*)?';\n  var parts = 100 .toLocaleString(lang, {\n    style: 'currency',\n    currency: currency,\n    useGrouping: true,\n    maximumFractionDigits: decimalLimit || 0,\n    minimumFractionDigits: decimalLimit || 0\n  }).replace('.', decimalSeparator).match(new RegExp(regex));\n  return {\n    prefix: (parts === null || parts === void 0 ? void 0 : parts[1]) || '',\n    suffix: (parts === null || parts === void 0 ? void 0 : parts[2]) || ''\n  };\n}\n/**\n * Fetch the field data provided a component.\n *\n * @param data\n * @param component\n * @return {*}\n */\n\n\nfunction fieldData(data, component) {\n  if (!data) {\n    return '';\n  }\n\n  if (!component || !component.key) {\n    return data;\n  }\n\n  if (component.key.includes('.')) {\n    var value = data;\n    var parts = component.key.split('.');\n    var key = '';\n\n    for (var i = 0; i < parts.length; i++) {\n      key = parts[i]; // Handle nested resources\n\n      if (value.hasOwnProperty('_id')) {\n        value = value.data;\n      } // Return if the key is not found on the value.\n\n\n      if (!value.hasOwnProperty(key)) {\n        return;\n      } // Convert old single field data in submissions to multiple\n\n\n      if (key === parts[parts.length - 1] && component.multiple && !Array.isArray(value[key])) {\n        value[key] = [value[key]];\n      } // Set the value of this key.\n\n\n      value = value[key];\n    }\n\n    return value;\n  } else {\n    // Convert old single field data in submissions to multiple\n    if (component.multiple && !Array.isArray(data[component.key])) {\n      data[component.key] = [data[component.key]];\n    } // Fix for checkbox type radio submission values in tableView\n\n\n    if (component.type === 'checkbox' && component.inputType === 'radio') {\n      return data[component.name] === component.value;\n    }\n\n    return data[component.key];\n  }\n}\n/**\n * Delays function execution with possibility to execute function synchronously or cancel it.\n *\n * @param fn Function to delay\n * @param delay Delay time\n * @return {*}\n */\n\n\nfunction delay(fn) {\n  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var timer = setTimeout.apply(void 0, [fn, delay].concat(args));\n\n  function cancel() {\n    clearTimeout(timer);\n  }\n\n  function earlyCall() {\n    cancel();\n    return fn.apply(void 0, args);\n  }\n\n  earlyCall.timer = timer;\n  earlyCall.cancel = cancel;\n  return earlyCall;\n}\n/**\n * Iterate the given key to make it unique.\n *\n * @param {String} key\n *   Modify the component key to be unique.\n *\n * @returns {String}\n *   The new component key.\n */\n\n\nfunction iterateKey(key) {\n  if (!key.match(/(\\d+)$/)) {\n    return \"\".concat(key, \"1\");\n  }\n\n  return key.replace(/(\\d+)$/, function (suffix) {\n    return Number(suffix) + 1;\n  });\n}\n/**\n * Determines a unique key within a map provided the base key.\n *\n * @param map\n * @param base\n * @return {*}\n */\n\n\nfunction uniqueKey(map, base) {\n  var newKey = base;\n\n  while (map.hasOwnProperty(newKey)) {\n    newKey = iterateKey(newKey);\n  }\n\n  return newKey;\n}\n/**\n * Determines the major version number of bootstrap.\n *\n * @return {number}\n */\n\n\nfunction bootstrapVersion(options) {\n  if (options.bootstrap) {\n    return options.bootstrap;\n  }\n\n  if (typeof $ === 'function' && typeof $().collapse === 'function') {\n    return parseInt($.fn.collapse.Constructor.VERSION.split('.')[0], 10);\n  }\n\n  return 0;\n}\n/**\n * Retrun provided argument.\n * If argument is a function, returns the result of a function call.\n * @param {*} e;\n *\n * @return {*}\n */\n\n\nfunction unfold(e) {\n  if (typeof e === 'function') {\n    return e();\n  }\n\n  return e;\n}\n/**\n * Map values through unfold and return first non-nil value.\n * @param {Array<T>} collection;\n *\n * @return {T}\n */\n\n\nvar firstNonNil = _lodash.default.flow([_lodash.default.partialRight(_lodash.default.map, unfold), _lodash.default.partialRight(_lodash.default.find, function (v) {\n  return !_lodash.default.isUndefined(v);\n})]);\n/*\n * Create enclosed state.\n * Returns functions to getting and cycling between states.\n * @param {*} a - initial state.\n * @param {*} b - next state.\n * @return {Functions[]} -- [get, toggle];\n */\n\n\nexports.firstNonNil = firstNonNil;\n\nfunction withSwitch(a, b) {\n  var state = a;\n  var next = b;\n\n  function get() {\n    return state;\n  }\n\n  function toggle() {\n    var prev = state;\n    state = next;\n    next = prev;\n  }\n\n  return [get, toggle];\n}\n\nfunction observeOverload(callback) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$limit = options.limit,\n      limit = _options$limit === void 0 ? 50 : _options$limit,\n      _options$delay = options.delay,\n      delay = _options$delay === void 0 ? 500 : _options$delay;\n  var callCount = 0;\n  var timeoutID = 0;\n\n  var reset = function reset() {\n    return callCount = 0;\n  };\n\n  return function () {\n    if (timeoutID !== 0) {\n      clearTimeout(timeoutID);\n      timeoutID = 0;\n    }\n\n    timeoutID = setTimeout(reset, delay);\n    callCount += 1;\n\n    if (callCount >= limit) {\n      clearTimeout(timeoutID);\n      reset();\n      return callback();\n    }\n  };\n}\n\nfunction getContextComponents(context) {\n  var values = [];\n  context.utils.eachComponent(context.instance.options.editForm.components, function (component, path) {\n    if (component.key !== context.data.key) {\n      values.push({\n        label: \"\".concat(component.label || component.key, \" (\").concat(path, \")\"),\n        value: path\n      });\n    }\n  });\n  return values;\n}\n\nfunction getContextButtons(context) {\n  var values = [];\n  context.utils.eachComponent(context.instance.options.editForm.components, function (component) {\n    if (component.type === 'button') {\n      values.push({\n        label: \"\".concat(component.key, \" (\").concat(component.label, \")\"),\n        value: component.key\n      });\n    }\n  });\n  return values;\n} // Tags that could be in text, that should be ommited or handled in a special way\n\n\nvar inTextTags = ['#text', 'A', 'B', 'EM', 'I', 'SMALL', 'STRONG', 'SUB', 'SUP', 'INS', 'DEL', 'MARK', 'CODE'];\n/**\n * Helper function for 'translateHTMLTemplate'. Translates text value of the passed html element.\n *\n * @param {HTMLElement} elem\n * @param {Function} translate\n *\n * @returns {String}\n *   Translated element template.\n */\n\nfunction translateElemValue(elem, translate) {\n  if (!elem.innerText) {\n    return elem.innerHTML;\n  }\n\n  var elemValue = elem.innerText.replace(_Evaluator.default.templateSettings.interpolate, '').replace(/\\s\\s+/g, ' ').trim();\n  var translatedValue = translate(elemValue);\n\n  if (elemValue !== translatedValue) {\n    var links = elem.innerHTML.match(/<a[^>]*>(.*?)<\\/a>/g);\n\n    if (links && links.length) {\n      if (links.length === 1 && links[0].length === elem.innerHTML.length) {\n        return elem.innerHTML.replace(elemValue, translatedValue);\n      }\n\n      var translatedLinks = links.map(function (link) {\n        var linkElem = document.createElement('a');\n        linkElem.innerHTML = link;\n        return translateElemValue(linkElem, translate);\n      });\n      return \"\".concat(translatedValue, \" (\").concat(translatedLinks.join(', '), \")\");\n    } else {\n      return elem.innerText.replace(elemValue, translatedValue);\n    }\n  } else {\n    return elem.innerHTML;\n  }\n}\n/**\n * Helper function for 'translateHTMLTemplate'. Goes deep through html tag children and calls function to translate their text values.\n *\n * @param {HTMLElement} tag\n * @param {Function} translate\n *\n * @returns {void}\n */\n\n\nfunction translateDeepTag(tag, translate) {\n  var children = tag.children.length && _toConsumableArray(tag.children);\n\n  var shouldTranslateEntireContent = children && children.every(function (child) {\n    return child.children.length === 0 && inTextTags.some(function (tag) {\n      return child.nodeName === tag;\n    });\n  });\n\n  if (!children || shouldTranslateEntireContent) {\n    tag.innerHTML = translateElemValue(tag, translate);\n  } else {\n    children.forEach(function (child) {\n      return translateDeepTag(child, translate);\n    });\n  }\n}\n/**\n * Translates text values in html template.\n *\n * @param {String} template\n * @param {Function} translate\n *\n * @returns {String}\n *   Html template with translated values.\n */\n\n\nfunction translateHTMLTemplate(template, translate) {\n  var isHTML = /<[^>]*>/.test(template);\n\n  if (!isHTML) {\n    return translate(template);\n  }\n\n  var tempElem = document.createElement('div');\n  tempElem.innerHTML = template;\n\n  if (tempElem.innerText && tempElem.children.length) {\n    translateDeepTag(tempElem, translate);\n    return tempElem.innerHTML;\n  }\n\n  return template;\n}\n/**\n * Sanitize an html string.\n *\n * @param string\n * @returns {*}\n */\n\n\nfunction sanitize(string, options) {\n  if (typeof _dompurify.default.sanitize !== 'function') {\n    return string;\n  } // Dompurify configuration\n\n\n  var sanitizeOptions = {\n    ADD_ATTR: ['ref', 'target'],\n    USE_PROFILES: {\n      html: true\n    }\n  }; // Add attrs\n\n  if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addAttr) && options.sanitizeConfig.addAttr.length > 0) {\n    options.sanitizeConfig.addAttr.forEach(function (attr) {\n      sanitizeOptions.ADD_ATTR.push(attr);\n    });\n  } // Add tags\n\n\n  if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addTags) && options.sanitizeConfig.addTags.length > 0) {\n    sanitizeOptions.ADD_TAGS = options.sanitizeConfig.addTags;\n  } // Allow tags\n\n\n  if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.allowedTags) && options.sanitizeConfig.allowedTags.length > 0) {\n    sanitizeOptions.ALLOWED_TAGS = options.sanitizeConfig.allowedTags;\n  } // Allow attributes\n\n\n  if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.allowedAttrs) && options.sanitizeConfig.allowedAttrs.length > 0) {\n    sanitizeOptions.ALLOWED_ATTR = options.sanitizeConfig.allowedAttrs;\n  } // Allowd URI Regex\n\n\n  if (options.sanitizeConfig && options.sanitizeConfig.allowedUriRegex) {\n    sanitizeOptions.ALLOWED_URI_REGEXP = options.sanitizeConfig.allowedUriRegex;\n  } // Allow to extend the existing array of elements that are safe for URI-like values\n\n\n  if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addUriSafeAttr) && options.sanitizeConfig.addUriSafeAttr.length > 0) {\n    sanitizeOptions.ADD_URI_SAFE_ATTR = options.sanitizeConfig.addUriSafeAttr;\n  }\n\n  return _dompurify.default.sanitize(string, sanitizeOptions);\n}\n/**\n * Fast cloneDeep for JSON objects only.\n */\n\n\nfunction fastCloneDeep(obj) {\n  return obj ? JSON.parse(JSON.stringify(obj)) : obj;\n}\n\nfunction isInputComponent(componentJson) {\n  if (componentJson.input === false || componentJson.input === true) {\n    return componentJson.input;\n  }\n\n  switch (componentJson.type) {\n    case 'htmlelement':\n    case 'content':\n    case 'columns':\n    case 'fieldset':\n    case 'panel':\n    case 'table':\n    case 'tabs':\n    case 'well':\n    case 'button':\n      return false;\n\n    default:\n      return true;\n  }\n}\n\nfunction getArrayFromComponentPath(pathStr) {\n  if (!pathStr || !_lodash.default.isString(pathStr)) {\n    if (!_lodash.default.isArray(pathStr)) {\n      return [pathStr];\n    }\n\n    return pathStr;\n  }\n\n  return pathStr.replace(/[[\\]]/g, '.').replace(/\\.\\./g, '.').replace(/(^\\.)|(\\.$)/g, '').split('.').map(function (part) {\n    return _lodash.default.defaultTo(_lodash.default.toNumber(part), part);\n  });\n}\n\nfunction hasInvalidComponent(component) {\n  return component.getComponents().some(function (comp) {\n    if (_lodash.default.isArray(comp.components)) {\n      return hasInvalidComponent(comp);\n    }\n\n    return comp.error;\n  });\n}\n\nfunction getStringFromComponentPath(path) {\n  if (!_lodash.default.isArray(path)) {\n    return path;\n  }\n\n  var strPath = '';\n  path.forEach(function (part, i) {\n    if (_lodash.default.isNumber(part)) {\n      strPath += \"[\".concat(part, \"]\");\n    } else {\n      strPath += i === 0 ? part : \".\".concat(part);\n    }\n  });\n  return strPath;\n}\n\nfunction round(number, precision) {\n  if (_lodash.default.isNumber(number)) {\n    return number.toFixed(precision);\n  }\n\n  return number;\n}\n/**\n * Check for Internet Explorer browser version\n *\n * @return {(number|null)}\n */\n\n\nfunction getIEBrowserVersion() {\n  var _getBrowserInfo = getBrowserInfo(),\n      ie = _getBrowserInfo.ie,\n      version = _getBrowserInfo.version;\n\n  return ie ? version : null;\n}\n/**\n * Get browser name and version (modified from 'jquery-browser-plugin')\n *\n * @return {Object} -- {{browser name, version, isWebkit?}}\n * Possible browser names: chrome, safari, ie, edge, opera, mozilla, yabrowser\n */\n\n\nfunction getBrowserInfo() {\n  var browser = {};\n\n  if (typeof window === 'undefined') {\n    return browser;\n  }\n\n  var ua = window.navigator.userAgent.toLowerCase();\n  var match = /(edge|edg)\\/([\\w.]+)/.exec(ua) || /(opr)[/]([\\w.]+)/.exec(ua) || /(yabrowser)[ /]([\\w.]+)/.exec(ua) || /(chrome)[ /]([\\w.]+)/.exec(ua) || /(iemobile)[/]([\\w.]+)/.exec(ua) || /(version)(applewebkit)[ /]([\\w.]+).*(safari)[ /]([\\w.]+)/.exec(ua) || /(webkit)[ /]([\\w.]+).*(version)[ /]([\\w.]+).*(safari)[ /]([\\w.]+)/.exec(ua) || /(webkit)[ /]([\\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ /]([\\w.]+)/.exec(ua) || /(msie) ([\\w.]+)/.exec(ua) || ua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua) || ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua) || [];\n  var matched = {\n    browser: match[5] || match[3] || match[1] || '',\n    version: match[4] || match[2] || '0'\n  };\n\n  if (matched.browser) {\n    browser[matched.browser] = true;\n    browser.version = parseInt(matched.version, 10);\n  } // Chrome, Opera 15+, Safari and Yandex.Browser are webkit based browsers\n\n\n  if (browser.chrome || browser.opr || browser.safari || browser.edg || browser.yabrowser) {\n    browser.isWebkit = true;\n  } // IE11 has a new token so we will assign it ie to avoid breaking changes\n\n\n  if (browser.rv || browser.iemobile) {\n    browser.ie = true;\n  } // Edge has a new token since it became webkit based\n\n\n  if (browser.edg) {\n    browser.edge = true;\n  } // Opera 15+ are identified as opr\n\n\n  if (browser.opr) {\n    browser.opera = true;\n  }\n\n  return browser;\n}\n\nfunction getComponentPathWithoutIndicies() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return path.replace(/\\[\\d+\\]/, '');\n}\n/**\n * Returns a path to the component which based on its schema\n * @param {*} component is a component's schema containing link to its parent's schema in the 'parent' property\n */\n\n\nfunction getComponentPath(component) {\n  var _component$_form;\n\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (!component || !component.key || (component === null || component === void 0 ? void 0 : (_component$_form = component._form) === null || _component$_form === void 0 ? void 0 : _component$_form.display) === 'wizard') {\n    // unlike the Webform, the Wizard has the key and it is a duplicate of the panel key\n    return path;\n  }\n\n  path = component.isInputComponent || component.input === true ? \"\".concat(component.key).concat(path ? '.' : '').concat(path) : path;\n  return getComponentPath(component.parent, path);\n}\n/**\n * Returns a parent component of the passed component instance skipping all the Layout components\n * @param {*} componentInstance\n * @return {(Component|undefined)}\n */\n\n\nfunction getDataParentComponent(componentInstance) {\n  if (!componentInstance) {\n    return;\n  }\n\n  var parent = componentInstance.parent;\n\n  if (parent && (parent.isInputComponent || parent.input)) {\n    return parent;\n  } else {\n    return getDataParentComponent(parent);\n  }\n}\n/**\n * Returns whether the value is a promise\n * @param value\n * @return {boolean}\n */\n\n\nfunction isPromise(value) {\n  return value && value.then && typeof value.then === 'function' && Object.prototype.toString.call(value) === '[object Promise]';\n}\n/**\n * Determines if the component has a scoping parent in tree (a component which scopes its children and manages its\n * changes by itself, e.g. EditGrid)\n * @param componentInstance\n * @param firstPass\n * @returns {boolean|boolean|*}\n */\n\n\nfunction isInsideScopingComponent(componentInstance) {\n  var firstPass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!firstPass && componentInstance !== null && componentInstance !== void 0 && componentInstance.hasScopedChildren) {\n    return true;\n  }\n\n  var dataParent = getDataParentComponent(componentInstance);\n\n  if (dataParent !== null && dataParent !== void 0 && dataParent.hasScopedChildren) {\n    return true;\n  } else if (dataParent !== null && dataParent !== void 0 && dataParent.parent) {\n    return isInsideScopingComponent(dataParent.parent, false);\n  }\n\n  return false;\n}\n\nfunction getFocusableElements(element) {\n  var focusableSelector = \"button:not([disabled]), input:not([disabled]), select:not([disabled]),\\n    textarea:not([disabled]), button:not([disabled]), [href]\";\n  return element.querySelectorAll(focusableSelector);\n} // Export lodash to save space with other libraries.","map":null,"metadata":{},"sourceType":"script"}